# phobos样本

## 利用管道通信传递参数

利用`CreateProcess`调用出cmd之后，如果直接将cmd的参数放进api中，则会被EDR进行记录，可以使用管道通信的形式去传递参数。可以使用`runas`命令提权或者是关闭防火墙命令。

### 进程间通信（IPC）机制

进程间通信（IPC）机制是指同一台计算机的不同进程之间或网络上不同计算机进程之间的通信。Windows下的方法包括邮槽（Mailslot）、管道（Pipes）、事件（Events）、文件映射（FileMapping）等。

管道分**有名**和**匿名**两种。

- 命名管道：可以在同台机器的不同进程间以及不同机器上的不同进程之间进行双向通信。
- 匿名管道：只在父子进程之间或者一个进程的两个子进程之间进行通信，它是单向的。

管道操作标示符是HANDLE，利用这个机制，直接使用`ReadFile` or `WriteFile`就可以实现了

> 若2个进程无“父子“关系，且子进程又未继承父进程资源，则这俩进程无法使用Pipe传递数据。

### 过程

- 创建两个匿名管道，一个读一个写。
- 创造一个子进程，将输入输出句柄重定向到管道
- 用`ReadFile()`和`WriteFile()`读写管道实现进程的通信

### 例子

利用程序创建cmd子进程执行一个弹出计算器的命令。

```c
#include<stdio.h>
#include<Windows.h>
#include<winnt.h>
#include <wchar.h>

int main()
{
	// frist create two pipe, because the anonymous pipe is unidirectional
	HANDLE hReadPipe;
	HANDLE hWritePipe;
	SECURITY_ATTRIBUTES sa = { 0 };
	sa.nLength = sizeof(SECURITY_ATTRIBUTES);
	sa.bInheritHandle = TRUE;

	if (!CreatePipe(&hReadPipe, &hWritePipe, &sa, 0))
	{
		printf("CreatePipe Failed %d\n", GetLastError());
		return 1;
	}

	HANDLE hReadPipe1;
	HANDLE hWritePipe1;
	if (!CreatePipe(&hReadPipe1, &hWritePipe1, &sa, 0))
	{
		printf("CreatePipe1 Failed %d\n", GetLastError());
		return 1;
	}

	// create a process cmd
	STARTUPINFO si = { 0 };
	PROCESS_INFORMATION pi = { 0 };

	ZeroMemory(&si, sizeof(si));
	ZeroMemory(&pi, sizeof(pi));

	
	//relocaltion stdout, 
	// Turn the input of the child process into a read pipe
	si.hStdInput = hReadPipe;
	// Turn the output of the child process into a write pipe
	si.hStdOutput = hWritePipe1;
	si.hStdError = hWritePipe1;
	si.dwFlags = STARTF_USESTDHANDLES;

	LPTSTR program = L"C:\\Windows\\System32\\cmd.exe";
	if (!CreateProcessW(program, NULL, 0, 0, TRUE, 0, 0, 0, &si, &pi))
	{
		printf("CreateProcess Failed %d\n", GetLastError());
		return 1;
	}

	// send command to cmd.exe, cmd.exe stop by "\r\n"
	char lpBuffer[] = "calc\r\n";
	if (!WriteFile(hWritePipe, lpBuffer, (DWORD)strlen(lpBuffer)+1, NULL, 0))
	{
		printf("WriteFile Failed %d\n", GetLastError());
		return 1;
	}

	CloseHandle(pi.hProcess);
	CloseHandle(pi.hThread);

	return 0;
}
```

上述代码执行之后可以调用cmd弹出一个calc。还可以通过设置

`CreateProcessW(program, NULL, 0, 0, TRUE, 0, 0, 0, &si, &pi)`的第六个参数来设置新进程不可见