{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction 欢迎来到我的gitbook，这是一个欢迎页，有任何问题或者建议以及bug可以通过邮件 crootkit@gmail.com 发我，不胜感激 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2022-11-18 11:15:01 "},"MyArticles/构建gitbook.html":{"url":"MyArticles/构建gitbook.html","title":"写在开始，how2gitbook","keywords":"","body":"如何在化工原理课堂构建gitbook作为自己的博客 hexo和gitbook对比 没啥好对比的，我就感觉hexo用起来比较方便，比如构建博客，挂在公网或者是github上比较方便；但是我认为那个适合作为一个交流平台，不适合用来笔记；所谓大道至简，hexo的便利性导致他的臃肿性。所以才来尝试使用gitbook来构建博客，与其说是博客，不如说是笔记系统，更加方便简单的笔记系统。 gitbook可以根据不同的类型进行分类，左边的目录支持二级目录，小母鹿都在文章里的右边。 而且book对于文章的目录管理非常自由，只有buil的时候可以索引到就可以。 可能别的也可以，但是我不知道，如果任何人来找我关于这个进行争论，别怪我没素质下限 gitbook搭建准备 记录搭建的过程，方便以后快速搭建。或者以备不时之需。 环境准备 需要： github账号，就像是hexo那种####.github.io的那种GitHub page仓库。 npm和node环境，npm需要低版本，高版本的不能匹配gitbook。 脑子，百度，google，梯子 git everything，可以帮助我更加方便的找到安装的文件在哪一个目录里 工具下载 npm install gitbook-cli -g 这里注意需要配置环境变量，在 查看高级系统设置 里，添加对应的目录 之前建议npm进行换源，不然下载可能会出问题。 下载结束之后，在cmd里输入 gitbook --version 需要注意的是如果显示找不到gitbook这个命令，则需要仔细的看一下自己的path有没有填入正确的值。 这时gitbook会进行自己的一个安装和配置。 可能的报错 gitbook报错1： npm版本太高，导致安装失败。 gitbook报错2： 找到报错的那个js文件，进去之后把67行左右的三个连续的代码注释掉，注意，一定不能注释报错行的代码，不然就无法自行安装配置gitbook。 解决上述错误之后重复指令 gitbook --version 出现警告无所谓，等一等等他安装完成。就行。成功后应该是 如果只有第一行的话说明不行，需要重新走一遍--version。并且注意一下那个可能会报错的js文件。 本地环境 自己找一个想放置文章的目录，当做gitbook的本地目录。然后进入目录 我这里用的目录是D:\\myGitbook，进入目录执行： gitbook init 如果没有在目录下生成两个md文件，说明你配错了。建议全部删除然后在npm官网下载msi文件进行安装，而不是下载zip，至于为啥我也不知道，你要是知道可以给我发邮件 crootkit@gmail.com 不胜感激。 目录下的 SUMMARY.md是很重要的，他决定了gitbook左边的目录。通过研究这个文件，可以发现他是怎么对文章进行索引的，这也可以根据他的格式来看到如何索引到我们的文章，所以我在该目录下创建了一个新的目录用来放置我的md文章。 通过命令 gitbook build 可以对本地的项目进行build，这个命令也集合到了gitbook serve里，但是我还是喜欢先build一下。 serve命令可以在本地起一个端口，类似于hexo s命令。 可以在本地起一个服务进行预览。 类似与这样的形势，就是成功了。 下载插件 在稀土掘金上找到了说是需要的12个插件，我稍微删改了一下。 插件需要写在D:\\myGitbook\\book.json中，我的是这样的。 { \"plugins\": [ \"back-to-top-button\", \"chapter-fold\", \"code\", \"splitter\", \"-lunr\", \"-search\", \"search-pro\", \"custom-favicon\", \"tbfed-pagefooter\", \"popup\", \"-sharing\", \"sharing-plus\", \"intopic-toc\" ], \"pluginsConfig\": { \"favicon\": \"./icon/book.ico\", \"tbfed-pagefooter\": { \"copyright\": \"没有版权，随便复制，免费的知识应该共享\", \"modify_label\": \"该文章修订时间：\", \"modify_format\": \"YYYY-MM-DD HH:mm:ss\" }, \"sharing\": { \"douban\": true, \"facebook\": true, \"google\": true, \"pocket\": true, \"qq\": true, \"qzone\": true, \"twitter\": true, \"weibo\": true, \"all\": [ \"douban\", \"facebook\", \"google\", \"instapaper\", \"linkedin\", \"twitter\", \"weibo\", \"messenger\", \"qq\", \"qzone\", \"viber\", \"whatsapp\" ] } } } 然后执行一下gitbook install就可以按部就班的下载了。 当你想添加一个插件时，我是这样解决的： 首先讲原先的book文件改名 建立新的book文件然后写入要更新的插件，进行install操作 然后讲两个book合并 如果新增插件的数量不是很多，可以采用单独下载的方式然后将插件的名称合并到之前book中。 注意：如果在build的时候没有将之前的book合并的话，会出现之前的插件无法索引的情况。 根据网络因素决定下载速度。 下载完成执行 gitbook build gitbook serve 托管到drootkit.github.io 明确一点 进行build之后，会在目录下生成一个_book目录，里面有一个index文件，这个文件就是整个完整的网页。 所以我们只需要把这个目录里的内容同步到github上去就行。 目录里的内容不全是网页需要用到的内容，我们可以创建一个.gitignore里面包含一些不需要提交到网页上的文件。 注意：每一次的build都会刷新_book目录下的所有的文件，导致.git会消失，所以就新建一个目录，每次生成的东西有用的放进去，既省去了gitignore也防止了git每次被刷没。 在这个新的目录里，build之后将生成的文件直接复制进去就可以，但是需要注意的是不要把里面的.git给覆盖掉，里面的git文件夹经过第一次配置好之后，后续就可以直接进行push了，相对比较方便。 上线gitbook 进行build之后，进入_book文件夹： git init #初始化本地git仓库 方法有很多，反正只要把这些文件push上去就行。 至于github的配置，参考hexo的github配置，那个信息比较多。 git config --global user.name \"###\" git config --global user.email \"###@4444.***\" 绑定远程仓库 git remote add origin 你的远程仓库地址 绑定之后因为本地还是master，远程一般是main，所以改一下本地分支 git config --global init.defaultBranch main 然后就三件套 git add . git commit -m \"必须写注释，不然报错\" git push #用-f来强制覆盖之前远程仓库里的东西 然后网页登录看看仓库里有没有东西，有了之后等一会，直接去访问网址就可以访问到gitbook了。 可能的报错 remote 1 遇到push失败（常见于更新的时候） 尝试强制覆盖 git push -u origin main -f 即可成功 2 遇到的新问题，当存在两个名称一样的标题的时候，会自动定位到第一个标题，所以这里的可能的报错我将其后面跟上了remote 玩的开心 可能的自动化脚本 能我哪天把这个搞差不多清楚了还是要写一个自动化的脚本的。不然每次都要手动复制可太麻烦了，一不注意再把我的git覆盖掉，那可是真的操了狗了。 每次加入新的文章之后都要修改summary那个md也是一件麻烦事，但是麻烦带来的高度的可操作性，这一点还是很难平衡的。总之我感觉这个是比hexo要好用的，依赖没有hexo那么多，相对来说也方便配置一点。 import os # 删除git目录中的没有用的md文件，只上传html文件，效果一样（md和png） def cleanGit(): path = 'D:\\\\myGitbook\\\\commit_dir\\\\MyArticles' for root, dirs, files in os.walk(path): for name in files: if (name.endswith(\".md\") or name.endswith(\".png\")): print(name) print(os.path.join(root, name)) os.remove(os.path.join(root, name)) # 删除空目录 # for root, dirs, files in os.walk(path): # if not os.listdir(root): # os.rmdir(root) # 清理本地的build目录，文本和图片 def cleanLocal(): path = 'D:\\\\myGitbook\\\\localOpreat\\\\_book\\\\MyArticles' for root, dirs, files in os.walk(path): for name in files: if (name.endswith(\".md\") or name.endswith(\".png\")): print(name) print(os.path.join(root, name)) os.remove(os.path.join(root, name)) # 删除空目录 # for root, dirs, files in os.walk(path): # if not os.listdir(root): # os.rmdir(root) cleanGit() 删除空目录的代码会出问题，暂时就不写了。 因为每一次写文章都要走一遍过程，相对比较麻烦，于是决定每周向github更新一次或者啥时候开心了就向github推送更新一次。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2022-11-20 21:44:40 "},"MyArticles/Reverse.html":{"url":"MyArticles/Reverse.html","title":"Reverse","keywords":"","body":"记录关于在CTF竞赛中的一些逆向题目的题解和一些在五湖四海学来的逆向知识。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2022-11-18 16:39:04 "},"MyArticles/PWN.html":{"url":"MyArticles/PWN.html","title":"PWN","keywords":"","body":"二进制pwn和reverse是不分家的，只不过侧重点不同罢了。 抓住主要矛盾的主要方面不代表可以放弃次要矛盾的次要方面。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2022-11-18 16:40:53 "},"MyArticles/Basics.html":{"url":"MyArticles/Basics.html","title":"Basics","keywords":"","body":"研究任何东西都需要基础的支撑，没有坚固的基础就无法企及至高的巅峰。 不积跬步无以至千里，不积小流难以成江海。泰山不让土壤，故能成其大；河海不择细流，故能就其深；王者不却众庶，故能明其德。合抱之木，生于毫末；百丈之台，起于垒土；千里之行，始于足下。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2022-11-18 16:27:11 "},"MyArticles/Basics/elf文件结构.html":{"url":"MyArticles/Basics/elf文件结构.html","title":"ELF structure","keywords":"","body":"PE是Windows下的文件，elf是linux下的文件。学习网络前端Windows是主要市场，后端服务端则是linux的天下。学习pe文件结构也要学习elf文件结构。前端的Windows病毒来势凶猛，后端的linux攻击也是防不胜防。挖矿病毒肆虐；僵尸网络横行，不懂elf文件结构怎能进入网络安全这一大主题的门槛。 当时在进行pwn入门的时候，没有学习elf的文件结构，只是知道了怎么用，在哪里用，现在了解了文件结构，对以往的pwn知识有了更加深入的理解。 结构综述 ELF文件由四部分组成：ELF头、程序头、节、节头 本文以一个简单的C语言文件当作例子 #include int main() { printf(\"hello world\\n\"); return 0; } 为了方便正常人的思路，记录顺序做了一下调整。 ELF头 可以在文件：/usr/include/elf.h中找到定义 #define EI_NIDENT (16) typedef struct { unsigned char e_ident[EI_NIDENT]; /* Magic number and other info */ Elf32_Half e_type; /* Object file type */ Elf32_Half e_machine; /* Architecture */ Elf32_Word e_version; /* Object file version */ Elf32_Addr e_entry; /* Entry point virtual address */ Elf32_Off e_phoff; /* Program header table file offset */ Elf32_Off e_shoff; /* Section header table file offset */ Elf32_Word e_flags; /* Processor-specific flags */ Elf32_Half e_ehsize; /* ELF header size in bytes */ Elf32_Half e_phentsize; /* Program header table entry size */ Elf32_Half e_phnum; /* Program header table entry count */ Elf32_Half e_shentsize; /* Section header table entry size */ Elf32_Half e_shnum; /* Section header table entry count */ Elf32_Half e_shstrndx; /* Section header string table index */ } Elf32_Ehdr; typedef struct { unsigned char e_ident[EI_NIDENT]; /* Magic number and other info */ Elf64_Half e_type; /* Object file type */ Elf64_Half e_machine; /* Architecture */ Elf64_Word e_version; /* Object file version */ Elf64_Addr e_entry; /* Entry point virtual address */ Elf64_Off e_phoff; /* Program header table file offset */ Elf64_Off e_shoff; /* Section header table file offset */ Elf64_Word e_flags; /* Processor-specific flags */ Elf64_Half e_ehsize; /* ELF header size in bytes */ Elf64_Half e_phentsize; /* Program header table entry size */ Elf64_Half e_phnum; /* Program header table entry count */ Elf64_Half e_shentsize; /* Section header table entry size */ Elf64_Half e_shnum; /* Section header table entry count */ Elf64_Half e_shstrndx; /* Section header string table index */ } Elf64_Ehdr; 存在32和64两种类型，基本一样的。 Elf64_Half和Elf64_Word是uint16_t uint32_t的预定义 在里面挑了几个重要的，记录一下，其他的不重要的就让他在书上吧。 e_ident数组 该数组首先以特定的4字节字符串开头\\x7fELF，这可以让文件加载器快速的认出来他是一个二进制文件， 通过命令readelf -h learnS 如果在编译的时候不添加-no-pie，这里的entry point addtress就是一个偏移。 e_type 这个多字节数组指定了elf文件的类型，一般有三种类型 ET_REL: 可重定位的对象文件 ET_EXEC：可执行的二进制文件 ET_DYN：共享对象文件（共享库） 例如下面的这个so.2程序 e_phoff和e_shoff e_shoff：section header offset,另一个同理是程序段的偏移，根据这两个值可以找到程序头和节头，一个是64字节，一个是6632字节。 注意：这里可以设置为0，意味着程序不包含程序头表和节头表；这里的地址不是虚拟地址，而是偏移量。 e_ehsize 该字段阐述了elf头部的大小，对于64位程序来说，大小就是64字节；对于32位的程序来说，elf头部的大小是52字节 e_shstrndx 该字段中包含一个名为.shstrndx的和特殊字符串表节相关的头索引。 这个.shstrtab在节头表中，这是一个专用节，包含一个以NULL值结尾的一个ascii数组。一个节一个名称。 readelf -x .shstrtab learnS 通过这个可以用16进制的形势查看内容。 在该头里其他的部分看起来对于逆向分析没有什么作用。 节头表 1.节：elf文件中代码和数据在逻辑上被分为连续的非重叠块，称为节（section）。 2.对于节的描述：没有任何预设的结构体，每个节的结构体取决于内容。每个节由节头描述，节头指定了节的属性。二进制中所有的节的节头都在节头表中。 3.节只是为链接器提供视图，因此是可选部分，不需要链接的二进制文件就不需要节头表，没有节头表，就将e_shoff的值设为 0.当二进制文件创建进程开始执行的时候，并不是所有的节都会载入内存，比如符号信息或者重定位信息。 段和节 二进制文件制定了另一种逻辑组织，称为段，段在文件执行的时候被使用；而节在连接时被使用。 同样在上述目录中，可以找到关于节头的定义 /* Section header. */ typedef struct { Elf32_Word sh_name; /* Section name (string tbl index) */ Elf32_Word sh_type; /* Section type */ Elf32_Word sh_flags; /* Section flags */ Elf32_Addr sh_addr; /* Section virtual addr at execution */ Elf32_Off sh_offset; /* Section file offset */ Elf32_Word sh_size; /* Section size in bytes */ Elf32_Word sh_link; /* Link to another section */ Elf32_Word sh_info; /* Additional section information */ Elf32_Word sh_addralign; /* Section alignment */ Elf32_Word sh_entsize; /* Entry size if section holds table */ } Elf32_Shdr; typedef struct { Elf64_Word sh_name; /* Section name (string tbl index) */ Elf64_Word sh_type; /* Section type */ Elf64_Xword sh_flags; /* Section flags */ Elf64_Addr sh_addr; /* Section virtual addr at execution */ Elf64_Off sh_offset; /* Section file offset */ Elf64_Xword sh_size; /* Section size in bytes */ Elf64_Word sh_link; /* Link to another section */ Elf64_Word sh_info; /* Additional section information */ Elf64_Xword sh_addralign; /* Section alignment */ Elf64_Xword sh_entsize; /* Entry size if section holds table */ } Elf64_Shdr; sh_name 这是节头的第一个字段，如果被设置，则在字符串表中包含索引；如果索引是0，则该节没有名称。 这里存在一个大致这样的流程。 sh_type 该字段阐述了节的类型，存在多种类型，在链接时会用到，内容不重要。 sh_flags 关于节的其他信息，其中最重要的有三种：SHF_WRITE、SHF_ALLOC 、SHF_EXECINSTR。 SHF_WRITE 在运行时可写，可以用来区分包含静态数据的节和包含变量的节。 SHF_ALLOC 指示在执行二进制文件的时候将该节的内容加载到虚拟内存，虽然在执行时是按照段视图。 SHF_EXECINSTR 指示该节包含可执行指令。 sh_addr、sh_offset、sh_size 描述该节的虚拟地址、文件偏移、节大小。 当设置sh_addr的值为0时，表示节不会加载到虚拟内存中。 其他 其他字段都不重要了 节 通过命令readelf --sections --wide learnS来查看节信息。可以看到节头表第一项由一个NULL项，这是标准的。 Section Headers: [Nr] Name Type Address Off Size ES Flg Lk Inf Al [ 0] NULL 0000000000000000 000000 000000 00 0 0 0 [ 1] .interp PROGBITS 0000000000400238 000238 00001c 00 A 0 0 1 [ 2] .note.ABI-tag NOTE 0000000000400254 000254 000020 00 A 0 0 4 [ 3] .note.gnu.build-id NOTE 0000000000400274 000274 000024 00 A 0 0 4 [ 4] .gnu.hash GNU_HASH 0000000000400298 000298 00001c 00 A 5 0 8 [ 5] .dynsym DYNSYM 00000000004002b8 0002b8 000060 18 A 6 1 8 [ 6] .dynstr STRTAB 0000000000400318 000318 00003f 00 A 0 0 1 [ 7] .gnu.version VERSYM 0000000000400358 000358 000008 02 A 5 0 2 [ 8] .gnu.version_r VERNEED 0000000000400360 000360 000020 00 A 6 1 8 [ 9] .rela.dyn RELA 0000000000400380 000380 000030 18 A 5 0 8 [10] .rela.plt RELA 00000000004003b0 0003b0 000018 18 AI 5 22 8 [11] .init PROGBITS 00000000004003c8 0003c8 000017 00 AX 0 0 4 [12] .plt PROGBITS 00000000004003e0 0003e0 000020 10 AX 0 0 16 [13] .text PROGBITS 0000000000400400 000400 000182 00 AX 0 0 16 [14] .fini PROGBITS 0000000000400584 000584 000009 00 AX 0 0 4 [15] .rodata PROGBITS 0000000000400590 000590 000010 00 A 0 0 4 [16] .eh_frame_hdr PROGBITS 00000000004005a0 0005a0 00003c 00 A 0 0 4 [17] .eh_frame PROGBITS 00000000004005e0 0005e0 000100 00 A 0 0 8 [18] .init_array INIT_ARRAY 0000000000600e10 000e10 000008 08 WA 0 0 8 [19] .fini_array FINI_ARRAY 0000000000600e18 000e18 000008 08 WA 0 0 8 [20] .dynamic DYNAMIC 0000000000600e20 000e20 0001d0 10 WA 6 0 8 [21] .got PROGBITS 0000000000600ff0 000ff0 000010 08 WA 0 0 8 [22] .got.plt PROGBITS 0000000000601000 001000 000020 08 WA 0 0 8 [23] .data PROGBITS 0000000000601020 001020 000010 00 WA 0 0 8 [24] .bss NOBITS 0000000000601030 001030 000008 00 WA 0 0 1 [25] .comment PROGBITS 0000000000000000 001030 000029 01 MS 0 0 1 [26] .symtab SYMTAB 0000000000000000 001060 0005b8 18 27 43 8 [27] .strtab STRTAB 0000000000000000 001618 0001cc 00 0 0 1 [28] .shstrtab STRTAB 0000000000000000 0017e4 000103 00 0 0 1 .init和.fini节 .init .init节中包含可执行代码，用来初始化程序。在程序将控制权移动到main函数之前，由init里的代码掌握。可以看作是构造函数。 .fini节 在程序执行结束之后执行的，和析构函数一样。 .text节 该节包含了程序的主要代码。 一般来说，可执行的节是不可写的，可写的是不可执行的（出于安全考虑） 在本例中（标准gcc编译的程序）中text节中包含多个开始任务和结束任务的标准函数： _start register_tm_clones frame_dummy这仨比较重要。 _start 函数 通过objdump -M intel -d learnS可以看到不同函数的反汇编。 在地址0x400424的地址处，调用了__libc_start_main函数，这里查看rdi寄存器，可以看到是程序main函数的地址。 这就是为什么gdb里下断点会下在这里，查看rdi的值获得main函数的地址 .bss和.data还有.rodata 因为代码节不可写，所以变量会保存在多个可写的专用节中。 .rodata read only data代表.rodata ，用来存储常量。 .data 初始化变量的默认值存放在这个节里。因为变量会被修改，所以标记为可写的节。 .bss 为了未初始化变量保留的空间，该节不会占用磁盘上的空间，只在二进制文件创建执行环境的时候为没有初始化的变量分配内存。该节是可写的。 延迟绑定plt、got plt表：（过程链接表）Procedure Linkage Table； got表：（全局偏移表）Gobal Offset Table； 为什么要延迟绑定：保证了动态链接器不会在重定位上浪费时间，只在需要的时候执行。 注意：若程序有实时性能的要求，则可以通过在bash中exportLD_BIND_NOW=1来取消动态绑定。 .got.plt（GOT表）这是一个单独的节，是运行时可写的，如果程序开启了RELRO（重定位只读）防御got表覆盖攻击，那么got表不可写，这时就将会变化的值放在了这个表中，方便运行时改变。 .plt.got（PLT表）这是一个备用的plt表，他的大小是8字节，在开启got不可写之后该表会代替16字节的plt表。 got节用于引用数据项，got,plt节用来存放通过plt访问（已经解析的）的库函数地址 执行流程 00000000004003e0 : 4003e0: ff 35 22 0c 20 00 push QWORD PTR [rip+0x200c22] # 601008 4003e6: ff 25 24 0c 20 00 jmp QWORD PTR [rip+0x200c24] # 601010 4003ec: 0f 1f 40 00 nop DWORD PTR [rax+0x0] 00000000004003f0 : 4003f0: ff 25 22 0c 20 00 jmp QWORD PTR [rip+0x200c22] # 601018 4003f6: 68 00 00 00 00 push 0x0 4003fb: e9 e0 ff ff ff jmp 4003e0 通过命令objdump -M intel --section .plt -d learnS可以看到上面的汇编结构。 地址4003e0处作为 “默认存根” 地址4003f0处作为“函数存根” plt存根以间接跳转指令开头，这导致他跳转到存储在.got.plt节中的地址（4003f0处的行为）。 在延迟绑定之前，该地址是函数存根下一条（push）指令的地址，间接跳转将控制权交给地址4003f6. 将0x0压入栈中（这是plt存根的标识符）。 4003fb地址的行为跳转到所有plt函数存根之间共享的通用默认存根。 默认存根push另一个标识符（从got中获得）表示可执行文件自身。间接的通过got跳转到动态链接器。 标识符 通过push plt存根的标识符，动态链接器可以确定puts函数的位置，并且这样还代表main函数已经加载到内存中了。 重要的是：同一个进程中会加载多个库，每一个库都有自己的PLT和GOT，动态链接器会寻找puts函数的地址，将函数的地址插入与put@plt相关的got条目中，完成延迟绑定。 GOT存在的意义 对于每个进程来说，相同的库代码也会映射到不同的虚拟地址中，所以不能直接将解析库函数的地址修补到程序中。因为该地址只在该进程的上下文起作用。但是每个进程都有got表的专用副本，这就可以了。 安全问题。 .dynamic节 充当的是操作系统和动态链接器的“路线图”，具体内容我觉的没啥用，不写了。 .init_array 节 包含一个指向构造函数的指针数组，在main函数被调用前会执行的一系列的构造函数。 init节包含可执行代码 init_array节是一个包含了“所需数量的函数指针”的数据节，也包括了指向自定义构造函数的指针， 在GCC中，可以通过 __attribute__((constructor)) 来修饰函数，将其标记为构造函数。 通过命令objdump -M intel --section .init_array -d learnS,看到该程序中的构造函数只有一个 验证得到： ​ 地址正好指向了函数，这是一个默认的初始化函数，在ida中查看该函数 .fini_array 节 作用和上述.init_array节相反，存放的是一些“析构函数”的指针。 这个程序的析构函数是0x4004b0地址处的函数。 另外：这两个节区的指针很容易被修改，所以是一个方便下钩子（hook）的地方。钩子将初始化甚至结束代码添加到二进制程序中并修改他的行为。 .shstrtab和.dynsym还有.dynstr节区 .shstrtab：一个以NULL结尾的字符串数组，包含了二进制文件中所有节的名称，并根据节头进行索引。可以帮助readelf之类的工具找到节的名称。 .dynsym还有.dynstr：包含了动态链接需要的符号和字符串，所以是不能去掉的。 可以用strip filename的形式去除表中的符号。 程序头 从相同的文件中找到关于elf程序头的定义 typedef struct { Elf32_Word p_type; /* Segment type */ Elf32_Off p_offset; /* Segment file offset */ Elf32_Addr p_vaddr; /* Segment virtual address */ Elf32_Addr p_paddr; /* Segment physical address */ Elf32_Word p_filesz; /* Segment size in file */ Elf32_Word p_memsz; /* Segment size in memory */ Elf32_Word p_flags; /* Segment flags */ Elf32_Word p_align; /* Segment alignment */ } Elf32_Phdr; typedef struct { Elf64_Word p_type; /* Segment type */ Elf64_Word p_flags; /* Segment flags */ Elf64_Off p_offset; /* Segment file offset */ Elf64_Addr p_vaddr; /* Segment virtual address */ Elf64_Addr p_paddr; /* Segment physical address */ Elf64_Xword p_filesz; /* Segment size in file */ Elf64_Xword p_memsz; /* Segment size in memory */ Elf64_Xword p_align; /* Segment alignment */ } Elf64_Phdr; 程序头表提供的是段的视图 通过命令readelf --wide --segments learnS可以看到程序中的程序头 通过下的描述可以发现，段是由节简单的捆绑组成的。 对于重要的字段进行说明。 Program Headers: Type Offset VirtAddr PhysAddr FileSiz MemSiz Flg Align PHDR 0x000040 0x0000000000400040 0x0000000000400040 0x0001f8 0x0001f8 R 0x8 INTERP 0x000238 0x0000000000400238 0x0000000000400238 0x00001c 0x00001c R 0x1 [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2] LOAD 0x000000 0x0000000000400000 0x0000000000400000 0x0006e0 0x0006e0 R E 0x200000 LOAD 0x000e10 0x0000000000600e10 0x0000000000600e10 0x000220 0x000228 RW 0x200000 DYNAMIC 0x000e20 0x0000000000600e20 0x0000000000600e20 0x0001d0 0x0001d0 RW 0x8 NOTE 0x000254 0x0000000000400254 0x0000000000400254 0x000044 0x000044 R 0x4 GNU_EH_FRAME 0x0005a0 0x00000000004005a0 0x00000000004005a0 0x00003c 0x00003c R 0x4 GNU_STACK 0x000000 0x0000000000000000 0x0000000000000000 0x000000 0x000000 RW 0x10 GNU_RELRO 0x000e10 0x0000000000600e10 0x0000000000600e10 0x0001f0 0x0001f0 R 0x1 p_type 标识了段的类型，该字段存在三个重要的类型： PT_LOAD PT_DYNAMIC PT_INTERP PT_LOAD 具有该表示的段在创建进程 时候会加载到内存中去，在上述代码中可以看到有两个具有 LOAD标识的段，一个包含了可写数据节（off:0x000e10），一个包含不可写数据节(off:0x000000)。 PT_INTERP & PT_INTERP 该段包含了.INTERP节，该节提供了加载二进制文件解释器的名称；PT_INTERP段包含了.dynamic节，该节通知解释器如何运行该二进制文件。 其他的就不重要了。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2022-11-19 13:13:18 "},"MyArticles/Basics/Pe File Structer.html":{"url":"MyArticles/Basics/Pe File Structer.html","title":"PE structure","keywords":"","body":"写在前面 微软基于COFF（通用项目文件格式）来设计的可执行文件，本篇学习笔记是基于《黑客免杀攻防》一书来学习记录的，之前有一篇记录是基于《逆向工程核心原理》写的逆向工程学习-PE文件格式 | R-o-o-t-k-i-t (hellorootkit.github.io)这两篇相互独立，只不过是不同的时间再次学习一下罢了。 可以在文件WinNt.h文件中找到。 一些缩写。 RAW：文件偏移 RVA：相对虚拟地址（是指相对与ImageBase的偏移） VA：虚拟地址，也就是程序被加载到内存中的地址 利用010editor 首先下载对应的模板，然后在010里运行模板，然后alt+f4显示模板变量，这样看起来比较方便，效果如下： 这里分析起来结构就如虎添翼了。 MS-DOS头 普遍存在于PE文件中的一个没啥用的节区，当PE文件运行在dos系统（DOS作为微软公司在个人计算机上使用的一个操作系统载体，1981年 - 1995年）时会执行，告诉你这个程序不能在dos系统里执行。在winnt.h文件的14889行可以找到DOS头的信息 // DOS .EXE header typedef struct _IMAGE_DOS_HEADER{ WORD e_magic; // Magic number WORD e_cblp; // Bytes on last page of file WORD e_cp; // Pages in file WORD e_crlc; // Relocations WORD e_cparhdr; // Size of header in paragraphs WORD e_minalloc; // Minimum extra paragraphs needed WORD e_maxalloc; // Maximum extra paragraphs needed WORD e_ss; // Initial (relative) SS value WORD e_sp; // Initial SP value WORD e_csum; // Checksum WORD e_ip; // Initial IP value WORD e_cs; // Initial (relative) CS value WORD e_lfarlc; // File address of relocation table WORD e_ovno; // Overlay number WORD e_res[4]; // Reserved words WORD e_oemid; // OEM identifier (for e_oeminfo) WORD e_oeminfo; // OEM information; e_oemid specific WORD e_res2[10]; // Reserved words LONG e_lfanew; // File address of new exe header } IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER; e_magic 就是4D 5A这两个字节，表示这是一个DOS下的可执行文件 e_ss; e_sp…… 这两个值用来在程序开始的时候初始化SS SP的两个寄存器的值，剩下的后面的几个就是初始化各个对应的寄存器的值。 e_lfarlc 这个头指向了程序中重定位表的地址 e_lfanew 这个值指向的是PE文件头（NT头）的偏移，这个数字的偏移是0x3c（从MZ那开始算起） DOS签名 这里就是一串字符串，和一些汇编代码，可以在dos里显示出这个字符串的汇编代码。 PE头（NT头） 在哪个头文件的15186行可以找对对应的描述 typedef struct _IMAGE_NT_HEADERS64 { DWORD Signature; IMAGE_FILE_HEADER FileHeader; IMAGE_OPTIONAL_HEADER64 OptionalHeader; } IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64; typedef struct _IMAGE_NT_HEADERS { DWORD Signature; IMAGE_FILE_HEADER FileHeader; IMAGE_OPTIONAL_HEADER32 OptionalHeader; } IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32; 不论是64位的程序还是32位的程序，这个结构体包含的内容基本是一样的。 Signature DWORD Signature; 这个字段由四个字节组成PE\\x00\\x00 IMAGE_FILE_HEADER IMAGE_FILE_HEADER FileHeader; 这个结构中包含了整个PE文件的概览信息，文件的15006行。 typedef struct _IMAGE_FILE_HEADER { WORD Machine; WORD NumberOfSections; DWORD TimeDateStamp; DWORD PointerToSymbolTable; DWORD NumberOfSymbols; WORD SizeOfOptionalHeader; WORD Characteristics; } IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER; Machine 一个两字节的值，表示了该程序运行在何种CPU上。在15034行可以看到宏定义，很重要的值，但是利用起来没啥用。 #define IMAGE_FILE_MACHINE_UNKNOWN 0 #define IMAGE_FILE_MACHINE_I386 0x014c // Intel 386. #define IMAGE_FILE_MACHINE_R3000 0x0162 // MIPS little-endian, 0x160 big-endian #define IMAGE_FILE_MACHINE_R4000 0x0166 // MIPS little-endian #define IMAGE_FILE_MACHINE_R10000 0x0168 // MIPS little-endian #define IMAGE_FILE_MACHINE_WCEMIPSV2 0x0169 // MIPS little-endian WCE v2 #define IMAGE_FILE_MACHINE_ALPHA 0x0184 // Alpha_AXP #define IMAGE_FILE_MACHINE_SH3 0x01a2 // SH3 little-endian #define IMAGE_FILE_MACHINE_SH3DSP 0x01a3 #define IMAGE_FILE_MACHINE_SH3E 0x01a4 // SH3E little-endian #define IMAGE_FILE_MACHINE_SH4 0x01a6 // SH4 little-endian #define IMAGE_FILE_MACHINE_SH5 0x01a8 // SH5 #define IMAGE_FILE_MACHINE_ARM 0x01c0 // ARM Little-Endian #define IMAGE_FILE_MACHINE_THUMB 0x01c2 // ARM Thumb/Thumb-2 Little-Endian #define IMAGE_FILE_MACHINE_ARMNT 0x01c4 // ARM Thumb-2 Little-Endian #define IMAGE_FILE_MACHINE_AM33 0x01d3 #define IMAGE_FILE_MACHINE_POWERPC 0x01F0 // IBM PowerPC Little-Endian #define IMAGE_FILE_MACHINE_POWERPCFP 0x01f1 #define IMAGE_FILE_MACHINE_IA64 0x0200 // Intel 64 #define IMAGE_FILE_MACHINE_MIPS16 0x0266 // MIPS #define IMAGE_FILE_MACHINE_ALPHA64 0x0284 // ALPHA64 #define IMAGE_FILE_MACHINE_MIPSFPU 0x0366 // MIPS #define IMAGE_FILE_MACHINE_MIPSFPU16 0x0466 // MIPS #define IMAGE_FILE_MACHINE_AXP64 IMAGE_FILE_MACHINE_ALPHA64 #define IMAGE_FILE_MACHINE_TRICORE 0x0520 // Infineon #define IMAGE_FILE_MACHINE_CEF 0x0CEF #define IMAGE_FILE_MACHINE_EBC 0x0EBC // EFI Byte Code #define IMAGE_FILE_MACHINE_AMD64 0x8664 // AMD64 (K8) #define IMAGE_FILE_MACHINE_M32R 0x9041 // M32R little-endian #define IMAGE_FILE_MACHINE_CEE 0xC0EE NumberOfSections 这个文件中节区的数目，如果说要新增一个节区的话，就要更改这里。 TimeDateStamp 文件的时间戳，在样本分析中可以根据时间戳来进行画像和溯源，这是比系统的日期和时间更加精确的时间。 可以看到都精确到秒了。 NumberOfSymbols 符号表中的符号的数量，COFF文件的符号表 长度固定，只有通过这个结构才能算出来符号表的结尾 SizeOfOptionalHeader 可选头（拓展头）的大小，这个头就在该结构体的后面。可以通过这个大小来判断32位（E0 00）和64位（F0 00）。 Characteristics 这个字段阐述了PE文件的属性，这个值是由众多的属性的值组合成的一个数字，看起来只有两个字节，但是包含了很多的二进制文件的属性。 IMAGE_OPTIONAL_HEADER 从这个块开始，就开始复杂了，就真正进入PE文件结构的核心了。 IMAGE_OPTIONAL_HEADER64 OptionalHeader; 为什么叫可选头，虽然他是必须的，没有就寄了。这是因为文件结构的设计是仿照的COFF文件，所以就传下来了这么一个不合理的名称。 这个头在64位和32位的程序中的结构不同（上面说了，大小不同，所以结构肯定不一样啊）。 这两个头合并成为PE文件头 typedef struct _IMAGE_OPTIONAL_HEADER { // // Standard fields. // WORD Magic; BYTE MajorLinkerVersion; BYTE MinorLinkerVersion; DWORD SizeOfCode; DWORD SizeOfInitializedData; DWORD SizeOfUninitializedData; DWORD AddressOfEntryPoint; DWORD BaseOfCode; DWORD BaseOfData; // // NT additional fields. // DWORD ImageBase; DWORD SectionAlignment; DWORD FileAlignment; WORD MajorOperatingSystemVersion; WORD MinorOperatingSystemVersion; WORD MajorImageVersion; WORD MinorImageVersion; WORD MajorSubsystemVersion; WORD MinorSubsystemVersion; DWORD Win32VersionValue; DWORD SizeOfImage; DWORD SizeOfHeaders; DWORD CheckSum; WORD Subsystem; WORD DllCharacteristics; DWORD SizeOfStackReserve; DWORD SizeOfStackCommit; DWORD SizeOfHeapReserve; DWORD SizeOfHeapCommit; DWORD LoaderFlags; DWORD NumberOfRvaAndSizes; IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]; } IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32; // 64位的程序的结构 typedef struct _IMAGE_OPTIONAL_HEADER64 { WORD Magic; BYTE MajorLinkerVersion; BYTE MinorLinkerVersion; DWORD SizeOfCode; DWORD SizeOfInitializedData; DWORD SizeOfUninitializedData; DWORD AddressOfEntryPoint; DWORD BaseOfCode; ULONGLONG ImageBase; DWORD SectionAlignment; DWORD FileAlignment; WORD MajorOperatingSystemVersion; WORD MinorOperatingSystemVersion; WORD MajorImageVersion; WORD MinorImageVersion; WORD MajorSubsystemVersion; WORD MinorSubsystemVersion; DWORD Win32VersionValue; DWORD SizeOfImage; DWORD SizeOfHeaders; DWORD CheckSum; WORD Subsystem; WORD DllCharacteristics; ULONGLONG SizeOfStackReserve; ULONGLONG SizeOfStackCommit; ULONGLONG SizeOfHeapReserve; ULONGLONG SizeOfHeapCommit; DWORD LoaderFlags; DWORD NumberOfRvaAndSizes; IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]; } IMAGE_OPTIONAL_HEADER64, *PIMAGE_OPTIONAL_HEADER64; Magic 文件类型标识，这个分开了PE32+文件（0x020b）,ROM文件（0x0170）,普通可执行文件（0x010b）。 MajorLinkerVersion 链接器的主版本号 MinorLinkerVersion 链接器的子版本号 SizeOfCode 所有的IMAGE_SCN_CNT_CODE的属性的代码的总大小，这是磁盘扇区字节数的整倍数计算，15353行 #define IMAGE_SCN_CNT_CODE 0x00000020 // Section contains code. 就是节区中包含可执行的代码的属性，相当于是可执行属性 AddressOfEntryPoint 程序执行入口RVA地址，一般指向运行时库代码，程序的main之类的入口点由这些库函数调用；在DLL文件中，这个值一般设置为0。 BaseOfCode 代码段的RVA地址，下面那个是数据段的代码段DataOfCode ImageBase 文件装入内存的首选地址，加载器会首先尝试在这个地址加载文件，加载成功就跳过装载器的重定位过程，如果这个地址在内存中被占用的话，装载器就会重新找一个合法的地址装载文件。 SizeOfImage 映像装入内存之后的大小，从ImageBase到最后一个区段的总大小 SizeOfHeaders 前面这些个各种头的总大小 CheckSum 映像文件的校验和，这个对于一般的文件没啥要求，一般就是0，但是对于内核模式的驱动和系统dll的这个值必须有这个合适的值 IMAGE_DATA_DIRECTORY #define IMAGE_NUMBEROF_DIRECTORY_ENTRIES 16 // 15047行 IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]; PE文件中各种数据结构的索引目录，由数个结构相同的IMAGE_DATA_DIRECTORY组成 typedef struct _IMAGE_DATA_DIRECTORY { DWORD VirtualAddress; DWORD Size; } IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY; 在文件中是这么描述的 #define IMAGE_DIRECTORY_ENTRY_EXPORT 0 // Export Directory #define IMAGE_DIRECTORY_ENTRY_IMPORT 1 // Import Directory #define IMAGE_DIRECTORY_ENTRY_RESOURCE 2 // Resource Directory #define IMAGE_DIRECTORY_ENTRY_EXCEPTION 3 // Exception Directory #define IMAGE_DIRECTORY_ENTRY_SECURITY 4 // Security Directory #define IMAGE_DIRECTORY_ENTRY_BASERELOC 5 // Base Relocation Table #define IMAGE_DIRECTORY_ENTRY_DEBUG 6 // Debug Directory // IMAGE_DIRECTORY_ENTRY_COPYRIGHT 7 // (X86 usage) #define IMAGE_DIRECTORY_ENTRY_ARCHITECTURE 7 // Architecture Specific Data #define IMAGE_DIRECTORY_ENTRY_GLOBALPTR 8 // RVA of GP #define IMAGE_DIRECTORY_ENTRY_TLS 9 // TLS Directory #define IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG 10 // Load Configuration Directory #define IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT 11 // Bound Import Directory in headers #define IMAGE_DIRECTORY_ENTRY_IAT 12 // Import Address Table #define IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT 13 // Delay Load Import Descriptors #define IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14 // COM Runtime descriptor IMAGE_DIRECTORY_ENTRY_SECURITY 安全目录，一般用来存放数字签名或者证书之类的。 IMAGE_DIRECTORY_ENTRY_BASERELOC 基址重定位表，存放这一个偏移，是需要执行重定位的代码的偏移信息 IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT 绑定输入目录，存储的是一些API绑定信息，这些可以加速程序的加载时间。 IMAGE_DIRECTORY_ENTRY_IAT 导入地址表，保存导入函数的真正地址 节表（区块表） 该表用来描述后面的这些个区段的各种属性，一个PE文件起码要一个节区才能跑，哪怕剩一个也得剩下text节区，连代码段都没了，跑尼玛呢。 该表由首位相连的数个结构相同的结构体构成 可以看到这个表的主要构成就是一堆IMAGE_SECTION_HEADER结构体构成，每一个结构体代表了之后的一个节区 IMAGE_SECTION_HEADER typedef struct _IMAGE_SECTION_HEADER { BYTE Name[IMAGE_SIZEOF_SHORT_NAME]; union { DWORD PhysicalAddress; DWORD VirtualSize; } Misc; DWORD VirtualAddress; DWORD SizeOfRawData; DWORD PointerToRawData; DWORD PointerToRelocations; DWORD PointerToLinenumbers; WORD NumberOfRelocations; WORD NumberOfLinenumbers; DWORD Characteristics; } IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER; Name 这个字段就是阐述的该节的名称，一个8字节的字符串，开头一般都是.，如果用$开头的同名的区段会合并成一个区段。 VirtualSize 这个和PhysicalAddress字段在一个联合体中，在obj文件中他的值是0x00000000; 其他文件表示的是该节区实际被使用的区段大小（没有经过对齐）。 VirtualAddress 文件载入内存中的RVA，这个地址是按照页内存对齐的，永远是可选头中的SectionAlignment的整数倍。 SizeOfRawData 这个区段在文件中的占用磁盘的大小，按照页内存对齐的，永远是可选头中的FileAlignment的整倍数 PointerToRawData 该区段在文件中的偏移 PointerToRelocations 该区段重定位表的偏移，指向了IMAGE_RELOCATION结构数组 IMAGE_RELOCATION typedef struct _IMAGE_RELOCATION { union { DWORD VirtualAddress; DWORD RelocCount; // Set to the real count when IMAGE_SCN_LNK_NRELOC_OVFL is set } DUMMYUNIONNAME; DWORD SymbolTableIndex; WORD Type; } IMAGE_RELOCATION; typedef IMAGE_RELOCATION UNALIGNED *PIMAGE_RELOCATION; Characteristics 阐述了区段的一些属性，比如读写情况和其他状态。这些属性有些事可以合并的，在程序中可以通过|来合并属性 区段的命名 区段名称可以自定义，但是一般是使用默认的区段名称。 可以通过如下形式对程序中的数据段进行改名。 #pragma data_seg(\"任意的名字\"); 区段的对齐 在文件中不论是什么内容，都要遵守一个页对齐的规则。对于PE文件来说，只要是2的倍数就可以 以text区段为例 看到这个段的VirtualSize是0x1d18，然后再看VirtualAddress和SizeOfRawData这两个字段 VirtualAddress：0x1000 所以这个区段在内存中的大小应该是0x2000，缺的字节用0x00补齐。用x64dbg可以证明： SizeOfRawData：0x1E00 根据上述大小，这个区段在硬盘中的大小应该是0x1E00的整倍数，所以理论上应该是0x1E00。 后续： 根据书上介绍，后面的内容都会教你如何定位，但是现在的CFF，PE studio这么方便，没必要再去研究怎么手动定位了。 IMAGE_EXPORT_DIRECTORY（导出表） 在头文件的16148行找到了这个结构体的描述 typedef struct _IMAGE_EXPORT_DIRECTORY { DWORD Characteristics; //默认是0，作为保留值 DWORD TimeDateStamp; //导出表创建时间 WORD MajorVersion; WORD MinorVersion; DWORD Name; //指向模块的名称的RVA地址 DWORD Base; DWORD NumberOfFunctions; //导出地址表（EAT）中成员个数 DWORD NumberOfNames; //导出名称表（ENT）中成员个数 DWORD AddressOfFunctions; // RVA from base of image DWORD AddressOfNames; // RVA from base of image DWORD AddressOfNameOrdinals; // RVA from base of image } IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY; 导出表主要是存放的程序的导出函数，exe文件一般没有这个表，普遍存在dll文件中。 不知道为啥，这个资料用了很大的章节来阐述如何定位到导出表……， 导出表在逻辑上分为三部分：名称表；序号表；函数表。 调用者通过前两者进行索引，找到真正的函数表。我们平时调用dll时用到的序号，需要减去DWORD Base;的值才能得到真正的保存的序号。但是不知道这个有什么实际用处 IMAGE_IMPORT_DIRECTORY（导入表） 这个表是重要的一个表。这个表存在的意义是：该程序调用第三方API函数供本地使用的调用机制。这个表普遍存在于PE文件中。 typedef struct _IMAGE_IMPORT_DESCRIPTOR { union { DWORD Characteristics; // 0 for terminating null import descriptor DWORD OriginalFirstThunk; // 输入表名称（INT）的RVA } DUMMYUNIONNAME; DWORD TimeDateStamp; // 0 if not bound, // -1 if bound, and real date\\time stamp // in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND) // O.W. date/time stamp of DLL bound to (Old BIND) DWORD ForwarderChain; // -1 if no forwarders DWORD Name; // 指出导入此映像文件的名字 DWORD FirstThunk; // RVA to IAT (if bound this IAT has actual addresses) } IMAGE_IMPORT_DESCRIPTOR; 该结构并不能完成PE文件整个的导入文件，只是帮助装载器找到程序真正的保存有导入信息的结构。真正保存导入函数的是如下两个结构体_IMAGE_IMPORT_BY_NAME和_IMAGE_THUNK_DATA。16166行 typedef struct _IMAGE_IMPORT_BY_NAME { WORD Hint; CHAR Name[1]; } IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME; typedef struct _IMAGE_THUNK_DATA64 { union { ULONGLONG ForwarderString; // 转发字符串的RVA ULONGLONG Function; // 被导出函数的地址 ULONGLONG Ordinal; ULONGLONG AddressOfData; // PIMAGE_IMPORT_BY_NAME } u1; } IMAGE_THUNK_DATA64; typedef struct _IMAGE_THUNK_DATA32 { union { DWORD ForwarderString; // PBYTE DWORD Function; // PDWORD DWORD Ordinal; DWORD AddressOfData; // PIMAGE_IMPORT_BY_NAME } u1; } IMAGE_THUNK_DATA32; IMAGE_IMPORT_DIRECTORY结构的个数由导入函数的数量决定，最后以一个空的IMAGE_IMPORT_DIRECTORY结构结尾 这个实例程序中只有两个结构，一个是kernel32的一个是msvcrt的 包含最后一个空结构： OriginalFirstThunk 包含指向INT的RVA，INT就是一个_IMAGE_THUNK_DATA类型的数组，结尾是一个空的_IMAGE_THUNK_DATA结构体；一般情况下，每一个_IMAGE_THUNK_DATA结构会指向_IMAGE_IMPORT_BY_NAME结构。 _IMAGE_IMPORT_BY_NAME结构体 typedef struct _IMAGE_IMPORT_BY_NAME { WORD Hint; // 导入表需要导入的函数的符号 CHAR Name[1]; // 导入表需要导入的函数的名称 } IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME; 该结构最后也是一个全空的结构体结尾， FirstThunk 指向导入地址表（IAT）的RVA地址 异常 异常目录常用来存放用于描述异常处理的相关的异常处理函数、SEH相关的地址等信息，这些信息一般位于pdata区段中。 PE文件结构中的异常目录目前只在： X64 ARMv7 ARM MIPS PowerPC 这些平台上才有实际作用。 在16551行可以找到这个结构体的描述 typedef struct _IMAGE_RUNTIME_FUNCTION_ENTRY { DWORD BeginAddress; // SEH代码起始地址 DWORD EndAddress; // SEH代码的结束地址 union { DWORD UnwindInfoAddress; DWORD UnwindData; } DUMMYUNIONNAME; } _IMAGE_RUNTIME_FUNCTION_ENTRY, *_PIMAGE_RUNTIME_FUNCTION_ENTRY; 安全 数据目录的IMAGE_DIRECTORY_ENTRY_SECURITY指向这个结构。这个目录也被称为“安全目录”或者“属性证书目录”，一般存放的是文件的数字签名。 安全目录结构 在wintrust.h文件中1398行可以找到描述 typedef struct _WIN_CERTIFICATE { DWORD dwLength; // 当前结构体的长度 WORD wRevision; // 签名的版本号 WORD wCertificateType; // WIN_CERT_TYPE_xxx BYTE bCertificate[ANYSIZE_ARRAY]; // 包含了许多证书 } WIN_CERTIFICATE, *LPWIN_CERTIFICATE; 基质重定向表 在运行的时候，总是exe文件被优先加载，所以这个表普遍存在于dll文件中，当exe文件或者其他文件运行占据了dll的默认地址，就会进行重定向。 一般情况下.reloc的段中存在这个基址重定位表；将PE文件中所有需要重定位的地址放在一个数组里。 IMAGE_BASE_RELOCATION typedef struct _IMAGE_BASE_RELOCATION { DWORD VirtualAddress; DWORD SizeOfBlock; // WORD TypeOffset[1]; } IMAGE_BASE_RELOCATION; 在一个PE文件中，重定位结构由众多的上述结构组成。根据书上说：每个这个结构管理的只有4kb大小的分页内的重定位信息，PE文件中每隔0x1000字节的大小就需要一个这个结构与其对应，所以这个结构中的VirtualAddress的值永远是0x1000的倍数。 调试 数据结构目录中的IMAGE_DIRECTORY_ENTRY_DEBUG结构指向了这个结构，该结构也被成为是调试目录，一般保存在.debug区段中。 IMAGE_DEBUG_DIRECTORY typedef struct _IMAGE_DEBUG_DIRECTORY { DWORD Characteristics; // 保留字段 DWORD TimeDateStamp; // 调试数据建立的时间和日期 WORD MajorVersion; WORD MinorVersion; DWORD Type; DWORD SizeOfData; DWORD AddressOfRawData; // 加载到内存的调试数据RVA DWORD PointerToRawData; // 调式数据的文件偏移 } IMAGE_DEBUG_DIRECTORY, *PIMAGE_DEBUG_DIRECTORY; 这个结构体不是很严格，在type里可以自定义一些类型，但是我也没有实际操作，所以我不清楚这个节区具体有什么用处 TLS 见另一笔记，本篇只用来记录PE结构的一些内容。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-02-13 15:26:36 "},"MyArticles/Practice.html":{"url":"MyArticles/Practice.html","title":"Practice","keywords":"","body":"《冬夜读书示子聿》 陆游 古人学问无遗力，少壮工夫老始成。 纸上得来终觉浅，绝知此事要躬行。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2022-11-18 16:34:38 "},"MyArticles/Dailynotes.html":{"url":"MyArticles/Dailynotes.html","title":"Daily notes","keywords":"","body":"《寒窑赋》 --------吕蒙正 天有不测风云，人有旦夕祸福。 蜈蚣百足，行不如蛇；雄鸡扇翼，飞不如鸦。 马有千里之能，非人力不能自往；人有凌云之志，非时运不能腾达。 文章盖世，孔子厄于陈、蔡；武略超群，姜公钓于渭水。 颜渊命短，原非凶恶之徒；盗跖延年，岂是善良之辈? 尧舜圣明，却生不肖之子；瞽鲧愚顽，反生大孝之儿。 张良原是布衣，萧何曾为县吏。 晏子无五尺之躯，封为齐国宰相；孔明无缚鸡之力，拜作蜀汉军师。 霸王英雄，难免乌江自刎；汉王柔弱，竟有江山万里。 李广有射虎之威，到老无封；冯唐有安邦之志，一生不遇。 韩信未遇，乞食瓢母，受辱胯下，及至运通，腰系三齐之印；白起受命，统兵百万，坑灭赵卒，一旦时衰，死于阴人之手。 是故人生在世，富贵不能淫，贫贱不能移。 才疏学浅，少年及第登科；满腹经纶，皓首仍居深山。 青楼女子，时来配作夫人；深闺娇娥，运退反为娼妓。 窈窕淑女，却招愚莽之夫；俊秀才郎，反配粗丑之妇。 蛟龙无雨，潜身鱼鳖之中；君子失时，拱手小人之下。 衣蔽蕴袍，常存礼仪之容；面带忧愁，每抱怀安之量。 时遭不遇，只宜安贫守分；心若不欺，必然扬眉吐气。 初贫君子，已成天然骨骼；乍富小人，不脱贫寒肌体。 有先贫而后富，有老壮而少衰。 天不得时，日月无光；地不得时，草木不生；水不得时，风浪不平；人不得时，利运不通。 昔居洛阳，日乞僧食，夜宿寒窑。思衣则不能遮其体，思食则不能饱其饥。夏日求瓜，失足短墙之下；冬日取暖，废襟炉火之中。上人憎，下人厌，人道吾贱也。非吾贱也，此乃时也，运也，命也。 今在朝堂，官至极品，位居三公。鞠躬一人之下，列职万人之上。拥挞百僚之杖，握斩鄙吝之剑。思衣则有绫罗绸缎，思食则有山珍海味。出则有虎将相随，入则有佳人临侧。上人趋，下人羡。人道吾贵也。非吾贵也，此乃时也，运也，命也。 嗟呼!人生在世，富贵不可尽恃，贫贱不可尽欺。听由天地循环，周而复始焉。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2022-11-18 16:32:42 "},"MyArticles/Dailynotes/pdf解析重组.html":{"url":"MyArticles/Dailynotes/pdf解析重组.html","title":"电子书清晰化的尝试 利用python","keywords":"","body":"在网上下载了一个扫描版的pdf电子书，但是书籍看起来不清楚，很模糊。于是想到通过将pdf里的每一页的图片提取出来然后经过锐化，最后再组成pdf的一个形式来使图片里的文字变的清晰。通过python来实现。 因为这是一本绝版书，淘宝上买的高于原价不少，所以决定直接操作pdf。网上找了很多pdf，大小都是一样的（60多MB），所以判定为这是唯一pdf版本，其他版本很难找了。 原画质 文字模糊，给人一种神秘感，通过一定手段来进行锐化处理。 import fitz import glob import os import cv2 import numpy as np def pdf2img(): doc = fitz.open(\"test.pdf\") pages = 20 for i in range(0, pages): page=doc.load_page(i) pix = page.get_pixmap() pix.save(\"img\\\\pdf\"+str(i)+\".png\") # 将图片进行锐化 def changes(): img_dir = \"C:\\\\Users\\\\rootkit\\\\Desktop\\\\pyclean\\\\img\" for img in sorted(glob.glob(\"{}/*\".format(img_dir))): # 读取图片，确保按文件名排序 print(img) image = cv2.imread(img) kernel = np.array([[0, -1, 0], [-1, 5, -1], [0, -1, 0]], np.float32) dst = cv2.filter2D(image, -1, kernel=kernel) cv2.imshow(\"custom_blur_demo\", dst) path = img+\"_c.png\" print(path) cv2.imwrite(path, dst) # print(\"success\") # 将锐化之后的图片重新组合成为pdf def img2pdf(): img_dir = \"C:\\\\Users\\\\rootkit\\\\Desktop\\\\pyclean\\\\img\" doc = fitz.open() for img in sorted(glob.glob(\"{}/*\".format(img_dir))): # 读取图片，确保按文件名排序 if \"_c\" in img: print(img) imgdoc = fitz.open(img) # 打开图片 pdfbytes = imgdoc.convertToPDF() # 使用图片创建单页的 PDF imgpdf = fitz.open(\"pdf\", pdfbytes) doc.insertPDF(imgpdf) # 将当前页插入文档 if os.path.exists(\"allimages.pdf\"): os.remove(\"allimages.pdf\") doc.save(\"allimages.pdf\") # 保存pdf文件 doc.close() print(\"######################\") # 先把pdf转图片，并存储在指定的目录中 pdf2img() # 对图片进行锐化处理 changes() # 图片转pdf img2pdf() 新画质 经过锐化之后，看到图片的效果得到明显改进，黑白对照更加明显了 看上去好像是更像是扫描的了，实际上如下 😅更不清楚了，真他奶奶滴服气啦。 解决方案 去孔夫子旧书网淘本二手书，麻了还有10块的运费，操。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2022-11-21 20:01:48 "},"MyArticles/Development.html":{"url":"MyArticles/Development.html","title":"Development","keywords":"","body":"正在的hacker从来都是一名合格的开发人员。 大丈夫生居天地间，岂能郁郁久居人下。 总是用别人的工具，这不太像一个黑客的作为吧？ 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2022-11-18 16:43:55 "},"MyArticles/CyberSec.html":{"url":"MyArticles/CyberSec.html","title":"CyberSec","keywords":"","body":"《从军行》 烽火照西京，心中自不平。 牙璋辞凤阙，铁骑绕龙城。 雪暗凋旗画，风多杂鼓声。 宁为百夫长，胜作一书生。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2022-11-18 16:35:52 "},"MyArticles/ToolUsage.html":{"url":"MyArticles/ToolUsage.html","title":"Tool usage","keywords":"","body":"子贡问为仁。子曰：“工欲善其事，必先利其器。居是邦也，事其大夫之贤者，友其士之仁者。”——孔子《论语·卫灵公》 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2022-11-18 16:37:33 "}}