{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction 欢迎来到我的gitbook，这是一个欢迎页，有任何问题或者建议以及bug可以通过邮件 crootkit@gmail.com 发我，不胜感激 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2022-11-18 11:15:01 "},"MyArticles/构建gitbook.html":{"url":"MyArticles/构建gitbook.html","title":"写在开始，how2gitbook","keywords":"","body":"如何在化工原理课堂构建gitbook作为自己的博客 hexo和gitbook对比 没啥好对比的，我就感觉hexo用起来比较方便，比如构建博客，挂在公网或者是github上比较方便；但是我认为那个适合作为一个交流平台，不适合用来笔记；所谓大道至简，hexo的便利性导致他的臃肿性。所以才来尝试使用gitbook来构建博客，与其说是博客，不如说是笔记系统，更加方便简单的笔记系统。 gitbook可以根据不同的类型进行分类，左边的目录支持二级目录，小母鹿都在文章里的右边。 而且book对于文章的目录管理非常自由，只有buil的时候可以索引到就可以。 可能别的也可以，但是我不知道，如果任何人来找我关于这个进行争论，别怪我没素质下限 gitbook搭建准备 记录搭建的过程，方便以后快速搭建。或者以备不时之需。 环境准备 需要： github账号，就像是hexo那种####.github.io的那种GitHub page仓库。 npm和node环境，npm需要低版本，高版本的不能匹配gitbook。 脑子，百度，google，梯子 git everything，可以帮助我更加方便的找到安装的文件在哪一个目录里 工具下载 npm install gitbook-cli -g 这里注意需要配置环境变量，在 查看高级系统设置 里，添加对应的目录 之前建议npm进行换源，不然下载可能会出问题。 下载结束之后，在cmd里输入 gitbook --version 需要注意的是如果显示找不到gitbook这个命令，则需要仔细的看一下自己的path有没有填入正确的值。 这时gitbook会进行自己的一个安装和配置。 可能的报错 gitbook报错1： npm版本太高，导致安装失败。 gitbook报错2： 找到报错的那个js文件，进去之后把67行左右的三个连续的代码注释掉，注意，一定不能注释报错行的代码，不然就无法自行安装配置gitbook。 解决上述错误之后重复指令 gitbook --version 出现警告无所谓，等一等等他安装完成。就行。成功后应该是 如果只有第一行的话说明不行，需要重新走一遍--version。并且注意一下那个可能会报错的js文件。 本地环境 自己找一个想放置文章的目录，当做gitbook的本地目录。然后进入目录 我这里用的目录是D:\\myGitbook，进入目录执行： gitbook init 如果没有在目录下生成两个md文件，说明你配错了。建议全部删除然后在npm官网下载msi文件进行安装，而不是下载zip，至于为啥我也不知道，你要是知道可以给我发邮件 crootkit@gmail.com 不胜感激。 目录下的 SUMMARY.md是很重要的，他决定了gitbook左边的目录。通过研究这个文件，可以发现他是怎么对文章进行索引的，这也可以根据他的格式来看到如何索引到我们的文章，所以我在该目录下创建了一个新的目录用来放置我的md文章。 通过命令 gitbook build 可以对本地的项目进行build，这个命令也集合到了gitbook serve里，但是我还是喜欢先build一下。 serve命令可以在本地起一个端口，类似于hexo s命令。 可以在本地起一个服务进行预览。 类似与这样的形势，就是成功了。 下载插件 在稀土掘金上找到了说是需要的12个插件，我稍微删改了一下。 插件需要写在D:\\myGitbook\\book.json中，我的是这样的。 { \"plugins\": [ \"back-to-top-button\", \"chapter-fold\", \"code\", \"splitter\", \"-lunr\", \"-search\", \"search-pro\", \"custom-favicon\", \"tbfed-pagefooter\", \"popup\", \"-sharing\", \"sharing-plus\", \"intopic-toc\" ], \"pluginsConfig\": { \"favicon\": \"./icon/book.ico\", \"tbfed-pagefooter\": { \"copyright\": \"没有版权，随便复制，免费的知识应该共享\", \"modify_label\": \"该文章修订时间：\", \"modify_format\": \"YYYY-MM-DD HH:mm:ss\" }, \"sharing\": { \"douban\": true, \"facebook\": true, \"google\": true, \"pocket\": true, \"qq\": true, \"qzone\": true, \"twitter\": true, \"weibo\": true, \"all\": [ \"douban\", \"facebook\", \"google\", \"instapaper\", \"linkedin\", \"twitter\", \"weibo\", \"messenger\", \"qq\", \"qzone\", \"viber\", \"whatsapp\" ] } } } 然后执行一下gitbook install就可以按部就班的下载了。 当你想添加一个插件时，我是这样解决的： 首先讲原先的book文件改名 建立新的book文件然后写入要更新的插件，进行install操作 然后讲两个book合并 如果新增插件的数量不是很多，可以采用单独下载的方式然后将插件的名称合并到之前book中。 注意：如果在build的时候没有将之前的book合并的话，会出现之前的插件无法索引的情况。 根据网络因素决定下载速度。 下载完成执行 gitbook build gitbook serve 托管到drootkit.github.io 明确一点 进行build之后，会在目录下生成一个_book目录，里面有一个index文件，这个文件就是整个完整的网页。 所以我们只需要把这个目录里的内容同步到github上去就行。 目录里的内容不全是网页需要用到的内容，我们可以创建一个.gitignore里面包含一些不需要提交到网页上的文件。 注意：每一次的build都会刷新_book目录下的所有的文件，导致.git会消失，所以就新建一个目录，每次生成的东西有用的放进去，既省去了gitignore也防止了git每次被刷没。 在这个新的目录里，build之后将生成的文件直接复制进去就可以，但是需要注意的是不要把里面的.git给覆盖掉，里面的git文件夹经过第一次配置好之后，后续就可以直接进行push了，相对比较方便。 上线gitbook 进行build之后，进入_book文件夹： git init #初始化本地git仓库 方法有很多，反正只要把这些文件push上去就行。 至于github的配置，参考hexo的github配置，那个信息比较多。 git config --global user.name \"###\" git config --global user.email \"###@4444.***\" 绑定远程仓库 git remote add origin 你的远程仓库地址 绑定之后因为本地还是master，远程一般是main，所以改一下本地分支 git config --global init.defaultBranch main 然后就三件套 git add . git commit -m \"必须写注释，不然报错\" git push #用-f来强制覆盖之前远程仓库里的东西 然后网页登录看看仓库里有没有东西，有了之后等一会，直接去访问网址就可以访问到gitbook了。 可能的报错 remote 1 遇到push失败（常见于更新的时候） 尝试强制覆盖 git push -u origin main -f 即可成功 2 遇到的新问题，当存在两个名称一样的标题的时候，会自动定位到第一个标题，所以这里的可能的报错我将其后面跟上了remote 玩的开心 可能的自动化脚本 能我哪天把这个搞差不多清楚了还是要写一个自动化的脚本的。不然每次都要手动复制可太麻烦了，一不注意再把我的git覆盖掉，那可是真的操了狗了。 每次加入新的文章之后都要修改summary那个md也是一件麻烦事，但是麻烦带来的高度的可操作性，这一点还是很难平衡的。总之我感觉这个是比hexo要好用的，依赖没有hexo那么多，相对来说也方便配置一点。 import os # 删除git目录中的没有用的md文件，只上传html文件，效果一样（md和png） def cleanGit(): path = 'D:\\\\myGitbook\\\\commit_dir\\\\MyArticles' for root, dirs, files in os.walk(path): for name in files: if (name.endswith(\".md\") or name.endswith(\".png\")): print(name) print(os.path.join(root, name)) os.remove(os.path.join(root, name)) # 删除空目录 # for root, dirs, files in os.walk(path): # if not os.listdir(root): # os.rmdir(root) # 清理本地的build目录，文本和图片 def cleanLocal(): path = 'D:\\\\myGitbook\\\\localOpreat\\\\_book\\\\MyArticles' for root, dirs, files in os.walk(path): for name in files: if (name.endswith(\".md\") or name.endswith(\".png\")): print(name) print(os.path.join(root, name)) os.remove(os.path.join(root, name)) # 删除空目录 # for root, dirs, files in os.walk(path): # if not os.listdir(root): # os.rmdir(root) cleanGit() 删除空目录的代码会出问题，暂时就不写了。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2022-11-19 13:57:19 "},"MyArticles/Reverse.html":{"url":"MyArticles/Reverse.html","title":"Reverse","keywords":"","body":"记录关于在CTF竞赛中的一些逆向题目的题解和一些在五湖四海学来的逆向知识。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2022-11-18 16:39:04 "},"MyArticles/PWN.html":{"url":"MyArticles/PWN.html","title":"PWN","keywords":"","body":"二进制pwn和reverse是不分家的，只不过侧重点不同罢了。 抓住主要矛盾的主要方面不代表可以放弃次要矛盾的次要方面。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2022-11-18 16:40:53 "},"MyArticles/Basics.html":{"url":"MyArticles/Basics.html","title":"Basics","keywords":"","body":"研究任何东西都需要基础的支撑，没有坚固的基础就无法企及至高的巅峰。 不积跬步无以至千里，不积小流难以成江海。泰山不让土壤，故能成其大；河海不择细流，故能就其深；王者不却众庶，故能明其德。合抱之木，生于毫末；百丈之台，起于垒土；千里之行，始于足下。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2022-11-18 16:27:11 "},"MyArticles/Basics/elf文件结构.html":{"url":"MyArticles/Basics/elf文件结构.html","title":"ELF structure","keywords":"","body":"PE是Windows下的文件，elf是linux下的文件。学习网络前端Windows是主要市场，后端服务端则是linux的天下。学习pe文件结构也要学习elf文件结构。前端的Windows病毒来势凶猛，后端的linux攻击也是防不胜防。挖矿病毒肆虐；僵尸网络横行，不懂elf文件结构怎能进入网络安全这一大主题的门槛。 当时在进行pwn入门的时候，没有学习elf的文件结构，只是知道了怎么用，在哪里用，现在了解了文件结构，对以往的pwn知识有了更加深入的理解。 结构综述 ELF文件由四部分组成：ELF头、程序头、节、节头 本文以一个简单的C语言文件当作例子 #include int main() { printf(\"hello world\\n\"); return 0; } 为了方便正常人的思路，记录顺序做了一下调整。 ELF头 可以在文件：/usr/include/elf.h中找到定义 #define EI_NIDENT (16) typedef struct { unsigned char e_ident[EI_NIDENT]; /* Magic number and other info */ Elf32_Half e_type; /* Object file type */ Elf32_Half e_machine; /* Architecture */ Elf32_Word e_version; /* Object file version */ Elf32_Addr e_entry; /* Entry point virtual address */ Elf32_Off e_phoff; /* Program header table file offset */ Elf32_Off e_shoff; /* Section header table file offset */ Elf32_Word e_flags; /* Processor-specific flags */ Elf32_Half e_ehsize; /* ELF header size in bytes */ Elf32_Half e_phentsize; /* Program header table entry size */ Elf32_Half e_phnum; /* Program header table entry count */ Elf32_Half e_shentsize; /* Section header table entry size */ Elf32_Half e_shnum; /* Section header table entry count */ Elf32_Half e_shstrndx; /* Section header string table index */ } Elf32_Ehdr; typedef struct { unsigned char e_ident[EI_NIDENT]; /* Magic number and other info */ Elf64_Half e_type; /* Object file type */ Elf64_Half e_machine; /* Architecture */ Elf64_Word e_version; /* Object file version */ Elf64_Addr e_entry; /* Entry point virtual address */ Elf64_Off e_phoff; /* Program header table file offset */ Elf64_Off e_shoff; /* Section header table file offset */ Elf64_Word e_flags; /* Processor-specific flags */ Elf64_Half e_ehsize; /* ELF header size in bytes */ Elf64_Half e_phentsize; /* Program header table entry size */ Elf64_Half e_phnum; /* Program header table entry count */ Elf64_Half e_shentsize; /* Section header table entry size */ Elf64_Half e_shnum; /* Section header table entry count */ Elf64_Half e_shstrndx; /* Section header string table index */ } Elf64_Ehdr; 存在32和64两种类型，基本一样的。 Elf64_Half和Elf64_Word是uint16_t uint32_t的预定义 在里面挑了几个重要的，记录一下，其他的不重要的就让他在书上吧。 e_ident数组 该数组首先以特定的4字节字符串开头\\x7fELF，这可以让文件加载器快速的认出来他是一个二进制文件， 通过命令readelf -h learnS 如果在编译的时候不添加-no-pie，这里的entry point addtress就是一个偏移。 e_type 这个多字节数组指定了elf文件的类型，一般有三种类型 ET_REL: 可重定位的对象文件 ET_EXEC：可执行的二进制文件 ET_DYN：共享对象文件（共享库） 例如下面的这个so.2程序 e_phoff和e_shoff e_shoff：section header offset,另一个同理是程序段的偏移，根据这两个值可以找到程序头和节头，一个是64字节，一个是6632字节。 注意：这里可以设置为0，意味着程序不包含程序头表和节头表；这里的地址不是虚拟地址，而是偏移量。 e_ehsize 该字段阐述了elf头部的大小，对于64位程序来说，大小就是64字节；对于32位的程序来说，elf头部的大小是52字节 e_shstrndx 该字段中包含一个名为.shstrndx的和特殊字符串表节相关的头索引。 这个.shstrtab在节头表中，这是一个专用节，包含一个以NULL值结尾的一个ascii数组。一个节一个名称。 readelf -x .shstrtab learnS 通过这个可以用16进制的形势查看内容。 在该头里其他的部分看起来对于逆向分析没有什么作用。 节头表 1.节：elf文件中代码和数据在逻辑上被分为连续的非重叠块，称为节（section）。 2.对于节的描述：没有任何预设的结构体，每个节的结构体取决于内容。每个节由节头描述，节头指定了节的属性。二进制中所有的节的节头都在节头表中。 3.节只是为链接器提供视图，因此是可选部分，不需要链接的二进制文件就不需要节头表，没有节头表，就将e_shoff的值设为 0.当二进制文件创建进程开始执行的时候，并不是所有的节都会载入内存，比如符号信息或者重定位信息。 段和节 二进制文件制定了另一种逻辑组织，称为段，段在文件执行的时候被使用；而节在连接时被使用。 同样在上述目录中，可以找到关于节头的定义 /* Section header. */ typedef struct { Elf32_Word sh_name; /* Section name (string tbl index) */ Elf32_Word sh_type; /* Section type */ Elf32_Word sh_flags; /* Section flags */ Elf32_Addr sh_addr; /* Section virtual addr at execution */ Elf32_Off sh_offset; /* Section file offset */ Elf32_Word sh_size; /* Section size in bytes */ Elf32_Word sh_link; /* Link to another section */ Elf32_Word sh_info; /* Additional section information */ Elf32_Word sh_addralign; /* Section alignment */ Elf32_Word sh_entsize; /* Entry size if section holds table */ } Elf32_Shdr; typedef struct { Elf64_Word sh_name; /* Section name (string tbl index) */ Elf64_Word sh_type; /* Section type */ Elf64_Xword sh_flags; /* Section flags */ Elf64_Addr sh_addr; /* Section virtual addr at execution */ Elf64_Off sh_offset; /* Section file offset */ Elf64_Xword sh_size; /* Section size in bytes */ Elf64_Word sh_link; /* Link to another section */ Elf64_Word sh_info; /* Additional section information */ Elf64_Xword sh_addralign; /* Section alignment */ Elf64_Xword sh_entsize; /* Entry size if section holds table */ } Elf64_Shdr; sh_name 这是节头的第一个字段，如果被设置，则在字符串表中包含索引；如果索引是0，则该节没有名称。 这里存在一个大致这样的流程。 sh_type 该字段阐述了节的类型，存在多种类型，在链接时会用到，内容不重要。 sh_flags 关于节的其他信息，其中最重要的有三种：SHF_WRITE、SHF_ALLOC 、SHF_EXECINSTR。 SHF_WRITE 在运行时可写，可以用来区分包含静态数据的节和包含变量的节。 SHF_ALLOC 指示在执行二进制文件的时候将该节的内容加载到虚拟内存，虽然在执行时是按照段视图。 SHF_EXECINSTR 指示该节包含可执行指令。 sh_addr、sh_offset、sh_size 描述该节的虚拟地址、文件偏移、节大小。 当设置sh_addr的值为0时，表示节不会加载到虚拟内存中。 其他 其他字段都不重要了 节 通过命令readelf --sections --wide learnS来查看节信息。可以看到节头表第一项由一个NULL项，这是标准的。 Section Headers: [Nr] Name Type Address Off Size ES Flg Lk Inf Al [ 0] NULL 0000000000000000 000000 000000 00 0 0 0 [ 1] .interp PROGBITS 0000000000400238 000238 00001c 00 A 0 0 1 [ 2] .note.ABI-tag NOTE 0000000000400254 000254 000020 00 A 0 0 4 [ 3] .note.gnu.build-id NOTE 0000000000400274 000274 000024 00 A 0 0 4 [ 4] .gnu.hash GNU_HASH 0000000000400298 000298 00001c 00 A 5 0 8 [ 5] .dynsym DYNSYM 00000000004002b8 0002b8 000060 18 A 6 1 8 [ 6] .dynstr STRTAB 0000000000400318 000318 00003f 00 A 0 0 1 [ 7] .gnu.version VERSYM 0000000000400358 000358 000008 02 A 5 0 2 [ 8] .gnu.version_r VERNEED 0000000000400360 000360 000020 00 A 6 1 8 [ 9] .rela.dyn RELA 0000000000400380 000380 000030 18 A 5 0 8 [10] .rela.plt RELA 00000000004003b0 0003b0 000018 18 AI 5 22 8 [11] .init PROGBITS 00000000004003c8 0003c8 000017 00 AX 0 0 4 [12] .plt PROGBITS 00000000004003e0 0003e0 000020 10 AX 0 0 16 [13] .text PROGBITS 0000000000400400 000400 000182 00 AX 0 0 16 [14] .fini PROGBITS 0000000000400584 000584 000009 00 AX 0 0 4 [15] .rodata PROGBITS 0000000000400590 000590 000010 00 A 0 0 4 [16] .eh_frame_hdr PROGBITS 00000000004005a0 0005a0 00003c 00 A 0 0 4 [17] .eh_frame PROGBITS 00000000004005e0 0005e0 000100 00 A 0 0 8 [18] .init_array INIT_ARRAY 0000000000600e10 000e10 000008 08 WA 0 0 8 [19] .fini_array FINI_ARRAY 0000000000600e18 000e18 000008 08 WA 0 0 8 [20] .dynamic DYNAMIC 0000000000600e20 000e20 0001d0 10 WA 6 0 8 [21] .got PROGBITS 0000000000600ff0 000ff0 000010 08 WA 0 0 8 [22] .got.plt PROGBITS 0000000000601000 001000 000020 08 WA 0 0 8 [23] .data PROGBITS 0000000000601020 001020 000010 00 WA 0 0 8 [24] .bss NOBITS 0000000000601030 001030 000008 00 WA 0 0 1 [25] .comment PROGBITS 0000000000000000 001030 000029 01 MS 0 0 1 [26] .symtab SYMTAB 0000000000000000 001060 0005b8 18 27 43 8 [27] .strtab STRTAB 0000000000000000 001618 0001cc 00 0 0 1 [28] .shstrtab STRTAB 0000000000000000 0017e4 000103 00 0 0 1 .init和.fini节 .init .init节中包含可执行代码，用来初始化程序。在程序将控制权移动到main函数之前，由init里的代码掌握。可以看作是构造函数。 .fini节 在程序执行结束之后执行的，和析构函数一样。 .text节 该节包含了程序的主要代码。 一般来说，可执行的节是不可写的，可写的是不可执行的（出于安全考虑） 在本例中（标准gcc编译的程序）中text节中包含多个开始任务和结束任务的标准函数： _start register_tm_clones frame_dummy这仨比较重要。 _start 函数 通过objdump -M intel -d learnS可以看到不同函数的反汇编。 在地址0x400424的地址处，调用了__libc_start_main函数，这里查看rdi寄存器，可以看到是程序main函数的地址。 这就是为什么gdb里下断点会下在这里，查看rdi的值获得main函数的地址 .bss和.data还有.rodata 因为代码节不可写，所以变量会保存在多个可写的专用节中。 .rodata read only data代表.rodata ，用来存储常量。 .data 初始化变量的默认值存放在这个节里。因为变量会被修改，所以标记为可写的节。 .bss 为了未初始化变量保留的空间，该节不会占用磁盘上的空间，只在二进制文件创建执行环境的时候为没有初始化的变量分配内存。该节是可写的。 延迟绑定plt、got plt表：（过程链接表）Procedure Linkage Table； got表：（全局偏移表）Gobal Offset Table； 为什么要延迟绑定：保证了动态链接器不会在重定位上浪费时间，只在需要的时候执行。 注意：若程序有实时性能的要求，则可以通过在bash中exportLD_BIND_NOW=1来取消动态绑定。 .got.plt（GOT表）这是一个单独的节，是运行时可写的，如果程序开启了RELRO（重定位只读）防御got表覆盖攻击，那么got表不可写，这时就将会变化的值放在了这个表中，方便运行时改变。 .plt.got（PLT表）这是一个备用的plt表，他的大小是8字节，在开启got不可写之后该表会代替16字节的plt表。 got节用于引用数据项，got,plt节用来存放通过plt访问（已经解析的）的库函数地址 执行流程 00000000004003e0 : 4003e0: ff 35 22 0c 20 00 push QWORD PTR [rip+0x200c22] # 601008 4003e6: ff 25 24 0c 20 00 jmp QWORD PTR [rip+0x200c24] # 601010 4003ec: 0f 1f 40 00 nop DWORD PTR [rax+0x0] 00000000004003f0 : 4003f0: ff 25 22 0c 20 00 jmp QWORD PTR [rip+0x200c22] # 601018 4003f6: 68 00 00 00 00 push 0x0 4003fb: e9 e0 ff ff ff jmp 4003e0 通过命令objdump -M intel --section .plt -d learnS可以看到上面的汇编结构。 地址4003e0处作为 “默认存根” 地址4003f0处作为“函数存根” plt存根以间接跳转指令开头，这导致他跳转到存储在.got.plt节中的地址（4003f0处的行为）。 在延迟绑定之前，该地址是函数存根下一条（push）指令的地址，间接跳转将控制权交给地址4003f6. 将0x0压入栈中（这是plt存根的标识符）。 4003fb地址的行为跳转到所有plt函数存根之间共享的通用默认存根。 默认存根push另一个标识符（从got中获得）表示可执行文件自身。间接的通过got跳转到动态链接器。 标识符 通过push plt存根的标识符，动态链接器可以确定puts函数的位置，并且这样还代表main函数已经加载到内存中了。 重要的是：同一个进程中会加载多个库，每一个库都有自己的PLT和GOT，动态链接器会寻找puts函数的地址，将函数的地址插入与put@plt相关的got条目中，完成延迟绑定。 GOT存在的意义 对于每个进程来说，相同的库代码也会映射到不同的虚拟地址中，所以不能直接将解析库函数的地址修补到程序中。因为该地址只在该进程的上下文起作用。但是每个进程都有got表的专用副本，这就可以了。 安全问题。 .dynamic节 充当的是操作系统和动态链接器的“路线图”，具体内容我觉的没啥用，不写了。 .init_array 节 包含一个指向构造函数的指针数组，在main函数被调用前会执行的一系列的构造函数。 init节包含可执行代码 init_array节是一个包含了“所需数量的函数指针”的数据节，也包括了指向自定义构造函数的指针， 在GCC中，可以通过 __attribute__((constructor)) 来修饰函数，将其标记为构造函数。 通过命令objdump -M intel --section .init_array -d learnS,看到该程序中的构造函数只有一个 验证得到： ​ 地址正好指向了函数，这是一个默认的初始化函数，在ida中查看该函数 .fini_array 节 作用和上述.init_array节相反，存放的是一些“析构函数”的指针。 这个程序的析构函数是0x4004b0地址处的函数。 另外：这两个节区的指针很容易被修改，所以是一个方便下钩子（hook）的地方。钩子将初始化甚至结束代码添加到二进制程序中并修改他的行为。 .shstrtab和.dynsym还有.dynstr节区 .shstrtab：一个以NULL结尾的字符串数组，包含了二进制文件中所有节的名称，并根据节头进行索引。可以帮助readelf之类的工具找到节的名称。 .dynsym还有.dynstr：包含了动态链接需要的符号和字符串，所以是不能去掉的。 可以用strip filename的形式去除表中的符号。 程序头 从相同的文件中找到关于elf程序头的定义 typedef struct { Elf32_Word p_type; /* Segment type */ Elf32_Off p_offset; /* Segment file offset */ Elf32_Addr p_vaddr; /* Segment virtual address */ Elf32_Addr p_paddr; /* Segment physical address */ Elf32_Word p_filesz; /* Segment size in file */ Elf32_Word p_memsz; /* Segment size in memory */ Elf32_Word p_flags; /* Segment flags */ Elf32_Word p_align; /* Segment alignment */ } Elf32_Phdr; typedef struct { Elf64_Word p_type; /* Segment type */ Elf64_Word p_flags; /* Segment flags */ Elf64_Off p_offset; /* Segment file offset */ Elf64_Addr p_vaddr; /* Segment virtual address */ Elf64_Addr p_paddr; /* Segment physical address */ Elf64_Xword p_filesz; /* Segment size in file */ Elf64_Xword p_memsz; /* Segment size in memory */ Elf64_Xword p_align; /* Segment alignment */ } Elf64_Phdr; 程序头表提供的是段的视图 通过命令readelf --wide --segments learnS可以看到程序中的程序头 通过下的描述可以发现，段是由节简单的捆绑组成的。 对于重要的字段进行说明。 Program Headers: Type Offset VirtAddr PhysAddr FileSiz MemSiz Flg Align PHDR 0x000040 0x0000000000400040 0x0000000000400040 0x0001f8 0x0001f8 R 0x8 INTERP 0x000238 0x0000000000400238 0x0000000000400238 0x00001c 0x00001c R 0x1 [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2] LOAD 0x000000 0x0000000000400000 0x0000000000400000 0x0006e0 0x0006e0 R E 0x200000 LOAD 0x000e10 0x0000000000600e10 0x0000000000600e10 0x000220 0x000228 RW 0x200000 DYNAMIC 0x000e20 0x0000000000600e20 0x0000000000600e20 0x0001d0 0x0001d0 RW 0x8 NOTE 0x000254 0x0000000000400254 0x0000000000400254 0x000044 0x000044 R 0x4 GNU_EH_FRAME 0x0005a0 0x00000000004005a0 0x00000000004005a0 0x00003c 0x00003c R 0x4 GNU_STACK 0x000000 0x0000000000000000 0x0000000000000000 0x000000 0x000000 RW 0x10 GNU_RELRO 0x000e10 0x0000000000600e10 0x0000000000600e10 0x0001f0 0x0001f0 R 0x1 p_type 标识了段的类型，该字段存在三个重要的类型： PT_LOAD PT_DYNAMIC PT_INTERP PT_LOAD 具有该表示的段在创建进程 时候会加载到内存中去，在上述代码中可以看到有两个具有 LOAD标识的段，一个包含了可写数据节（off:0x000e10），一个包含不可写数据节(off:0x000000)。 PT_INTERP & PT_INTERP 该段包含了.INTERP节，该节提供了加载二进制文件解释器的名称；PT_INTERP段包含了.dynamic节，该节通知解释器如何运行该二进制文件。 其他的就不重要了。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2022-11-19 13:13:18 "},"MyArticles/Practice.html":{"url":"MyArticles/Practice.html","title":"Practice","keywords":"","body":"《冬夜读书示子聿》 陆游 古人学问无遗力，少壮工夫老始成。 纸上得来终觉浅，绝知此事要躬行。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2022-11-18 16:34:38 "},"MyArticles/Dailynotes.html":{"url":"MyArticles/Dailynotes.html","title":"Daily notes","keywords":"","body":"《寒窑赋》 --------吕蒙正 天有不测风云，人有旦夕祸福。 蜈蚣百足，行不如蛇；雄鸡扇翼，飞不如鸦。 马有千里之能，非人力不能自往；人有凌云之志，非时运不能腾达。 文章盖世，孔子厄于陈、蔡；武略超群，姜公钓于渭水。 颜渊命短，原非凶恶之徒；盗跖延年，岂是善良之辈? 尧舜圣明，却生不肖之子；瞽鲧愚顽，反生大孝之儿。 张良原是布衣，萧何曾为县吏。 晏子无五尺之躯，封为齐国宰相；孔明无缚鸡之力，拜作蜀汉军师。 霸王英雄，难免乌江自刎；汉王柔弱，竟有江山万里。 李广有射虎之威，到老无封；冯唐有安邦之志，一生不遇。 韩信未遇，乞食瓢母，受辱胯下，及至运通，腰系三齐之印；白起受命，统兵百万，坑灭赵卒，一旦时衰，死于阴人之手。 是故人生在世，富贵不能淫，贫贱不能移。 才疏学浅，少年及第登科；满腹经纶，皓首仍居深山。 青楼女子，时来配作夫人；深闺娇娥，运退反为娼妓。 窈窕淑女，却招愚莽之夫；俊秀才郎，反配粗丑之妇。 蛟龙无雨，潜身鱼鳖之中；君子失时，拱手小人之下。 衣蔽蕴袍，常存礼仪之容；面带忧愁，每抱怀安之量。 时遭不遇，只宜安贫守分；心若不欺，必然扬眉吐气。 初贫君子，已成天然骨骼；乍富小人，不脱贫寒肌体。 有先贫而后富，有老壮而少衰。 天不得时，日月无光；地不得时，草木不生；水不得时，风浪不平；人不得时，利运不通。 昔居洛阳，日乞僧食，夜宿寒窑。思衣则不能遮其体，思食则不能饱其饥。夏日求瓜，失足短墙之下；冬日取暖，废襟炉火之中。上人憎，下人厌，人道吾贱也。非吾贱也，此乃时也，运也，命也。 今在朝堂，官至极品，位居三公。鞠躬一人之下，列职万人之上。拥挞百僚之杖，握斩鄙吝之剑。思衣则有绫罗绸缎，思食则有山珍海味。出则有虎将相随，入则有佳人临侧。上人趋，下人羡。人道吾贵也。非吾贵也，此乃时也，运也，命也。 嗟呼!人生在世，富贵不可尽恃，贫贱不可尽欺。听由天地循环，周而复始焉。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2022-11-18 16:32:42 "},"MyArticles/Development.html":{"url":"MyArticles/Development.html","title":"Development","keywords":"","body":"正在的hacker从来都是一名合格的开发人员。 大丈夫生居天地间，岂能郁郁久居人下。 总是用别人的工具，这不太像一个黑客的作为吧？ 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2022-11-18 16:43:55 "},"MyArticles/CyberSec.html":{"url":"MyArticles/CyberSec.html","title":"CyberSec","keywords":"","body":"《从军行》 烽火照西京，心中自不平。 牙璋辞凤阙，铁骑绕龙城。 雪暗凋旗画，风多杂鼓声。 宁为百夫长，胜作一书生。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2022-11-18 16:35:52 "},"MyArticles/ToolUsage.html":{"url":"MyArticles/ToolUsage.html","title":"Tool usage","keywords":"","body":"子贡问为仁。子曰：“工欲善其事，必先利其器。居是邦也，事其大夫之贤者，友其士之仁者。”——孔子《论语·卫灵公》 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2022-11-18 16:37:33 "}}